<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://mrh1s.top').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="mrh929&#39;s home">
<meta property="og:url" content="https://mrh1s.top/page/8/index.html">
<meta property="og:site_name" content="mrh929&#39;s home">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mrh929&#39;s home">
<meta name="twitter:description" content="Blog">

<link rel="canonical" href="https://mrh1s.top/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>mrh929's home</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mrh929's home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/6c3f6e84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/6c3f6e84/" class="post-title-link" itemprop="url">字符串hash，康托展开总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:44:39" itemprop="dateCreated datePublished" datetime="2018-12-06T23:44:39+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:18:29" itemprop="dateModified" datetime="2019-05-05T13:18:29+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>字符串hash，康托展开总结</h1>
<strong>各种字符串hash函数：</strong>

<p><strong>ELF Hash<u>BKDRHash</u>APHashDJBHashJSHashRSHashSDBMHashPJWHashELFHash</strong></p>
<p><strong>字符串hash之BKDRhash函数</strong></p>
<p><strong>有研究表明BKDRhash函数冲突率较低，且变成复杂度低，所以可以用来作为常用hash函数</strong></p>
<table class=" cke_show_border" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td><strong>Hash函数</strong></td>
<td><strong>数据1</strong></td>
<td><strong>数据2</strong></td>
<td><strong>数据3</strong></td>
<td><strong>数据4</strong></td>
<td><strong>数据1得分</strong></td>
<td><strong>数据2得分</strong></td>
<td><strong>数据3得分</strong></td>
<td><strong>数据4得分</strong></td>
<td><strong>平均分</strong></td>
</tr>
<tr>
<td><strong>BKDRHash</strong></td>
<td><strong>2</strong></td>
<td><strong>0</strong></td>
<td><strong>4774</strong></td>
<td><strong>481</strong></td>
<td><strong>96.55</strong></td>
<td><strong>100</strong></td>
<td><strong>90.95</strong></td>
<td><strong>82.05</strong></td>
<td><strong>92.64</strong></td>
</tr>
<tr>
<td><strong>APHash</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4754</strong></td>
<td><strong>493</strong></td>
<td><strong>96.55</strong></td>
<td><strong>88.46</strong></td>
<td><strong>100</strong></td>
<td><strong>51.28</strong></td>
<td><strong>86.28</strong></td>
</tr>
<tr>
<td><strong>DJBHash</strong></td>
<td><strong>2</strong></td>
<td><strong>2</strong></td>
<td><strong>4975</strong></td>
<td><strong>474</strong></td>
<td><strong>96.55</strong></td>
<td><strong>92.31</strong></td>
<td><strong>0</strong></td>
<td><strong>100</strong></td>
<td><strong>83.43</strong></td>
</tr>
<tr>
<td><strong>JSHash</strong></td>
<td><strong>1</strong></td>
<td><strong>4</strong></td>
<td><strong>4761</strong></td>
<td><strong>506</strong></td>
<td><strong>100</strong></td>
<td><strong>84.62</strong></td>
<td><strong>96.83</strong></td>
<td><strong>17.95</strong></td>
<td><strong>81.94</strong></td>
</tr>
<tr>
<td><strong>RSHash</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>4861</strong></td>
<td><strong>505</strong></td>
<td><strong>100</strong></td>
<td><strong>100</strong></td>
<td><strong>51.58</strong></td>
<td><strong>20.51</strong></td>
<td><strong>75.96</strong></td>
</tr>
<tr>
<td><strong>SDBMHash</strong></td>
<td><strong>3</strong></td>
<td><strong>2</strong></td>
<td><strong>4849</strong></td>
<td><strong>504</strong></td>
<td><strong>93.1</strong></td>
<td><strong>92.31</strong></td>
<td><strong>57.01</strong></td>
<td><strong>23.08</strong></td>
<td><strong>72.41</strong></td>
</tr>
<tr>
<td><strong>PJWHash</strong></td>
<td><strong>30</strong></td>
<td><strong>26</strong></td>
<td><strong>4878</strong></td>
<td><strong>513</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>43.89</strong></td>
<td><strong>0</strong></td>
<td><strong>21.95</strong></td>
</tr>
<tr>
<td><strong>ELFHash</strong></td>
<td><strong>30</strong></td>
<td><strong>26</strong></td>
<td><strong>4878</strong></td>
<td><strong>513</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>43.89</strong></td>
<td><strong>0</strong></td>
<td><strong>21.95</strong></td>
</tr>
</tbody>
</table>
<strong> </strong>

<p><strong> </strong></p>
<p><strong>unsigned int bkdr_hash(const char* str)</strong></p>
<p><strong>{            </strong></p>
<p><strong>      unsignedint seed = 31; // 31 131 1313 13131 131313 etc.. 37（最好是质数）</strong></p>
<p><strong>      unsignedint hash = 0;</strong></p>
<p><strong>      while(<em>str) hash = (hash * seed + (</em>str++))%P;//P是一个较大质数</strong></p>
<p><strong>      returnhash;</strong></p>
<p><strong>}</strong></p>
<p><strong>各种证明：</strong></p>
<p><strong><a href="http://www.it165.net/pro/html/201410/24949.html" data-cke-saved-href="http://www.it165.net/pro/html/201410/24949.html" target="_blank" rel="noopener">http://www.it165.net/pro/html/201410/24949.html</a></strong></p>
<p><strong> </strong></p>
<p><strong> </strong></p>
<p><strong> </strong></p>
<p><strong>双hash优化：</strong></p>
<p><strong>在hash表中想要用线性探查的方式处理hash表的冲突，那么每次比对要查找的元素与当前元素是否相等就显得十分麻烦，特别是两个数据是字符串的时候，strcmp超级耗时，此时我们就可以在存储新元素时通过另一hash算法算出两者的hash值，将这两个hash存入结构体，并且排序，用二分查找第一个hash值，并比较第二个hash值，若符合则相同</strong></p>
<p><strong> </strong></p>
<p><strong>另外本人想到一个貌似还可以的做法，目前都AC了所做的所有Hash题目</strong></p>
<p><strong>做法：用两种截然不同的hash算法，hash1算出取模压缩后的值，而hash2算出BKDRhash算法，其中P（较大质数）为10^9+7，算出字符串完整的hash2值，把hash1当作地址，hash2当作数据：HashTable[hash1]=hash2;</strong></p>
<p><strong>当然有冲突时先比较hash2值是否相同，不相同则继续探查直到所在地址数据为空，hash2相同时就基本可以说明两个字符串是相等的。。。。</strong></p>
<p><strong>康托展开</strong></p>
<p><strong>叙述：有一个数字序列，所有数都是[1,n]的，且任意两者互异，此时我们用一一对应的方式存储这些数据就有n！种可能，康托算法对处理这种序列提供了完美的解决方法。称为康托展开。我们把这个数列看作全排列，数字所对hash值就为全排列的大小（第几大）。</strong></p>
<p><strong> </strong></p>
<p><strong>公式：hash(key)=a[n]<em>(n-1)!+a[n-1]</em>(n-2)!+…+a[2]<em>(2-1)!+a[1]</em>(1-1)!</strong></p>
<p><strong>其中，a[n]所存的值为在第n个数（从小到大的顺序）之前比n小的数的个数</strong></p>
<p><strong>Hash值完全可以通过循环在n次内算出，且数列与hash完全一一对应，可谓完美算法。</strong></p>
<p><strong> </strong></p>
<p><strong>康托逆展开：</strong></p>
<p><strong>由于康托展开的一一对应性，我们同样可以算出原来的全排列。</strong></p>
<p><strong>n为康托展开式，k为总阶乘</strong></p>
<p><strong>第一位：(n-1)/(k-1)余n’</strong></p>
<p><strong>第二位：n’/(k-2)余n’’</strong></p>
<p><strong>以此类推。。。</strong></p>
<p><strong> </strong></p>
<p><strong>Poj1200</strong></p>
<p><strong>描述</strong></p>
<p>许多人喜欢解决难题。一个这样的难题是在一个给定的文本中找到一个隐藏的素数。这个数字是所给字符串中不同子串的个数。当你很快会发现，你真的需要一台计算机和一个很好的算法来解决这样的难题。</p>
<p>你的任务是编写一个程序，文本中不同字符的数量不超过NC，给出这样的字符串，求长度为n的不同的子串有多少个。</p>
<p>举一个例子，当n = 3，NC = 4，字符串为“daababac”。可以在字符串中到到符合条件的子串为：”daa”;”aab”; “aba”; “bab”; “bac”。因此，答案应该是5。</p>
<p><strong>输入：</strong></p>
<p>第一行：两个数：n，nc</p>
<p>第二行：要搜索的字符串；</p>
<p>你可以假设，最后你所搜索出来符合要求的子串个数不大于16000000；</p>
<p><strong>输出</strong></p>
<p>不同子串的个数</p>
<p><strong>样例输入</strong></p>
<p>3 4</p>
<p>daababac</p>
<p><strong>样例输出</strong></p>
<p>5</p>
<p><strong>提示</strong></p>
<p>输入数据巨大，不用cin</p>
<p><strong>数据巨大，seed不宜太大，看了poj题解，有一个很棒的方法，seed就是当前字符在整个字符串出现过的个数，刚好可以做到一一对应</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_wrapper_has cke_widget_selected" tabindex="-1" role="region" contenteditable="false" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="2" aria-label="代码段 小部件">
<pre class="has cke_widget_element" data-cke-widget-data="{&quot;lang&quot;:&quot;cpp&quot;,&quot;code&quot;:&quot;#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int Z1=1000000007;\nbool hashtable[Z1+100];\nint n,nc,ans=0,asc[300],num,len,sum;\nchar str[8000000];\nint main(){\n//\tfreopen(\&quot;in.txt\&quot;,\&quot;r\&quot;,stdin);\n\tscanf(\&quot;%d%d\&quot;,&amp;n,&amp;nc);\n\tscanf(\&quot;%s\&quot;,str);\n\tlen=strlen(str);\n\tfor(int i=0;i&lt;len;i++)\n\t\tif(!asc[str[i]])\n\t\t\tasc[str[i]]=++num;\n\tfor(int i=0;i&lt;len-n+1;i++){\n\t\tsum=0;\n\t\tfor(int j=i;j&lt;i+n;j++)\n\t\t\tsum+=sum*nc+asc[str[j]];//该字符的个数作为seed \n\t\tif(!hashtable[sum])\n\t\t\thashtable[sum]=1,ans++;\n\t}\n\tprintf(\&quot;%d\&quot;,ans);\n\t\n\treturn 0;\n}&quot;,&quot;classes&quot;:{&quot;has&quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><cstdio></cstdio></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><cstring></cstring></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><algorithm></algorithm></span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Z1=<span class="hljs-number">1000000007</span>;
<span class="hljs-keyword">bool</span> hashtable[Z1+<span class="hljs-number">100</span>];
<span class="hljs-keyword">int</span> n,nc,ans=<span class="hljs-number">0</span>,asc[<span class="hljs-number">300</span>],num,len,sum;
<span class="hljs-keyword">char</span> str[<span class="hljs-number">8000000</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
<span class="hljs-comment">//    freopen("in.txt","r",stdin);</span>
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&n,&nc);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,str);
    len=<span class="hljs-built_in">strlen</span>(str);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i<len;i++) <span class="hljs-keyword">if(!asc[str[i]])
            asc[str[i]]=++num;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i<len-n+<span class="hljs-number">1;i++){
        sum=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j<i+n;j++) sum+="sum*nc+asc[str[j]];<span" class="hljs-comment">//该字符的个数作为seed 
        <span class="hljs-keyword">if</span>(!hashtable[sum])
            hashtable[sum]=<span class="hljs-number">1</span>,ans++;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans);

<pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;</code></pre><p>}
<strong>POJ2503-</strong><strong>Babelfish</strong></p>
<p><strong>描述：</strong></p>
<p>你刚从滑铁卢搬到一个大城市，但是你却不懂他们的语言，还好你有一本词典可以帮助你。</p>
<p><strong>输入格式</strong></p>
<p>输入包括高达10万词条，之后是一个空行，然后是长达10万个单词查询。每个字典条目是包含一个英文单词，后面跟一个空格和一个当地语言。没有当地语言在字典中出现超过一次。每行一个词，输入中的每个词至多10小写字母。</p>
<p><strong>输出格式</strong></p>
<p>输出翻译成英语的消息，每行一个单词。没有在字典中的外来词应该被译为“en”。</p>
<p><strong>样例输入</strong></p>
<p>dog ogday</p>
<p>cat atcay</p>
<p>pig igpay</p>
<p>froot ootfray</p>
<p>loops oopslay</p>
<p>atcay</p>
<p>ittenkay</p>
<p>oopslay</p>
<p><strong>样例输出</strong></p>
<p>cat</p>
<p>eh</p>
<p>loops</p>
<p><strong>这里读入就是个问题，我是这样的：先读入s1，在getchar()，如果get到空格就继续读s2</strong></p>
<p><strong>否则就进行翻译步骤</strong></p>
<p><strong>这里我使用的方式是双哈希，将字符串的第一个hash作为地址，第二个hash作为数据，线性探查相应单词就会省时省力</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_wrapper_has cke_widget_selected" tabindex="-1" role="region" contenteditable="false" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="1" aria-label="代码段 小部件">
<pre class="has cke_widget_element" data-cke-widget-data="{&quot;lang&quot;:&quot;cpp&quot;,&quot;code&quot;:&quot;#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int MAX=1000000;\nchar data[MAX+20][11],s1[11],s2[11];\nunsigned int hashtable[MAX+20];\nunsigned int Hash1(const char* str){ \n\tunsigned int h=0;\n\tunsigned int seed=31;\n\twhile(*str) h+=(h*seed+(*str++))%MAX;\n\treturn (h%MAX+h+1311)%MAX;\n}\n\nunsigned int Hash2(const char* str){\n\tunsigned int h=0;\n\tunsigned int seed=131;\n\twhile(*str) h+=(h*seed+(*str++))%(MAX+3);\n\treturn h%MAX;\n}\n\n\nint main(){\n//\tfreopen(\&quot;in.txt\&quot;,\&quot;r\&quot;,stdin);\n\tunsigned int h1,h2;\n\twhile(scanf(\&quot;%s\&quot;,s1)!=EOF){\n\t\tif(getchar()!=' ') break;\n\t\tscanf(\&quot;%s\&quot;,s2);\n\t\th1=Hash1(s2);\n\t\th2=Hash2(s2);\n\t\twhile(data[h1][0]!=0){\n\t\t\tif(h2==hashtable[h1]) break;\n\t\t\th1+=2333;\n\t\t\tif(h1&gt;MAX) h1%=MAX;\n\t\t}\n\t\thashtable[h1]=h2;\n\t\tstrcpy(data[h1],s1);\n\t}\n\tdo{\n\t\th1=Hash1(s1);\n\t\th2=Hash2(s1);\n\t\twhile(h2!=hashtable[h1]){\n\t\t\tif(data[h1][0]==0) break;\n\t\t\th1+=2333;\n\t\t\tif(h1&gt;MAX) h1%=MAX;\n\t\t}\n\t\tif(data[h1][0]==0) printf(\&quot;eh\\n\&quot;);\n\t\telse printf(\&quot;%s\\n\&quot;,data[h1]);\n\t}while(scanf(\&quot;%s\&quot;,s1)!=EOF);\n\t\n\t\n\treturn 0;\n}&quot;,&quot;classes&quot;:{&quot;has&quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><cstdio></cstdio></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><cstring></cstring></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><algorithm></algorithm></span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">1000000</span>;
<span class="hljs-keyword">char</span> data[MAX+<span class="hljs-number">20</span>][<span class="hljs-number">11</span>],s1[<span class="hljs-number">11</span>],s2[<span class="hljs-number">11</span>];
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hashtable[MAX+<span class="hljs-number">20</span>];
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Hash1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>{ 
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> h=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seed=<span class="hljs-number">31</span>;
    <span class="hljs-keyword">while</span>(*str) h+=(h*seed+(*str++))%MAX;
    <span class="hljs-keyword">return</span> (h%MAX+h+<span class="hljs-number">1311</span>)%MAX;
}

<p><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Hash2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> h=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seed=<span class="hljs-number">131</span>;
    <span class="hljs-keyword">while</span>(<em>str) h+=(h</em>seed+(*str++))%(MAX+<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> h%MAX;<br>}</p>
<p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
<span class="hljs-comment">//    freopen(“in.txt”,”r”,stdin);</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> h1,h2;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">“%s”</span>,s1)!=EOF){<br>        <span class="hljs-keyword">if</span>(getchar()!=<span class="hljs-string">‘ ‘</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">“%s”</span>,s2);<br>        h1=Hash1(s2);<br>        h2=Hash2(s2);<br>        <span class="hljs-keyword">while</span>(data[h1][0]!=<span class="hljs-number">0</span>){<br>            <span class="hljs-keyword">if</span>(h2==hashtable[h1]) <span class="hljs-keyword">break</span>;
            h1+=<span class="hljs-number">2333</span>;
            <span class="hljs-keyword">if</span>(h1&gt;MAX) h1%=MAX;<br>        }<br>        hashtable[h1]=h2;<br>        <span class="hljs-built_in">strcpy</span>(data[h1],s1);<br>    }<br>    <span class="hljs-keyword">do</span>{
        h1=Hash1(s1);<br>        h2=Hash2(s1);<br>        <span class="hljs-keyword">while</span>(h2!=hashtable[h1]){<br>            <span class="hljs-keyword">if</span>(data[h1][0]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
            h1+=<span class="hljs-number">2333</span>;
            <span class="hljs-keyword">if</span>(h1&gt;MAX) h1%=MAX;<br>        }<br>        <span class="hljs-keyword">if</span>(data[h1][0]==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">“eh\n”</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">“%s\n”</span>,data[h1]);<br>    }<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">“%s”</span>,s1)!=EOF);</p>
<p><strong>POJ1002- 487-3279</strong></p>
<p><strong>描述：</strong></p>
<p>企业喜欢用容易被记住的电话号码。让电话号码容易被记住的一个办法是将它写成一个容易记住的单词或者短语。例如，你需要给滑铁卢大学打电话时，可以拨打TUT-GLOP。有时，只将电话号码中部分数字拼写成单词。当你晚上回到酒店，可以通过拨打310-GINO来向Gino’s订一份pizza。让电话号码容易被记住的另一个办法是以一种好记的方式对号码的数字进行分组。通过拨打必胜客的“三个十”号码3-10-10-10，你可以从他们那里订pizza。</p>
<p>电话号码的标准格式是七位十进制数，并在第三、第四位数字之间有一个连接符。电话拨号盘提供了从字母到数字的映射，映射关系如下：<br>A, B, 和C映射到 2<br>D, E, 和F映射到 3<br>G, H, 和I映射到 4<br>J, K, 和L映射到 5<br>M, N, 和O映射到 6<br>P, R, 和S映射到 7<br>T, U, 和V映射到 8<br>W, X, 和Y映射到 9</p>
<p>ITS-EASY</p>
<p>4873279</p>
<p>Q和Z没有映射到任何数字，连字符不需要拨号，可以任意添加和删除。 TUT-GLOP的标准格式是888-4567，310-GINO的标准格式是310-4466，3-10-10-10的标准格式是310-1010。</p>
<p>如果两个号码有相同的标准格式，那么他们就是等同的（相同的拨号）</p>
<p>你的公司正在为本地的公司编写一个电话号码薄。作为质量控制的一部分，你想要检查是否有两个和多个公司拥有相同的电话号码。</p>
<p><strong>输入格式：</strong></p>
<p>输入的格式是，第一行是一个正整数，指定电话号码薄中号码的数量（最多100000）。余下的每行是一个电话号码。每个电话号码由数字，大写字母（除了Q和Z）以及连接符组成。每个电话号码中只会刚好有7个数字或者字母。</p>
<p><strong>输出格式：</strong></p>
<p>对于每个出现重复的号码产生一行输出，输出是号码的标准格式紧跟一个空格然后是它的重复次数。如果存在多个重复的号码，则按照号码的字典升序输出。如果输入数据中没有重复的号码，输出一行：<br>No duplicates.</p>
<p><strong>样例输入：</strong></p>
<p>12</p>
<p>4873279</p>
<p>ITS-EASY</p>
<p>888-4567</p>
<p>3-10-10-10</p>
<p>888-GLOP</p>
<p>TUT-GLOP</p>
<p>967-11-11</p>
<p>310-GINO</p>
<p>F101010</p>
<p>888-1200</p>
<p>-4-8-7-3-2-7-9-</p>
<p>487-3279</p>
<p><strong> </strong></p>
<p><strong>样例输出：</strong></p>
<pre class><code class="language-html hljs">310-1010 2</code></pre>
<pre class><code class="language-html hljs">487-3279 4</code></pre>
<pre class><code class="language-html hljs">888-4567 3</code></pre>
<p><strong>个人认为这道题不用hash，直接开一个足够大的数组即可，只是在读入数据方面要小心</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_wrapper_has cke_widget_selected" tabindex="-1" role="region" contenteditable="false" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="0" aria-label="代码段 小部件">
<pre class="has cke_widget_element" data-cke-widget-data="{&quot;lang&quot;:&quot;cpp&quot;,&quot;code&quot;:&quot;#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int MAX=10000000;\nchar str[200];\nint data[MAX+200],log[10000000],tot;\n\nint Translate(char c){\n\tif(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0';\n\tif(c=='Q'||c=='Z'||c=='-') return -1;\n\tif(c&lt;='P') return (c-'A')/3+2;\n\treturn (c-'A'-1)/3+2;\n}\n\nint Hash(char* str){\n\tint k=1000000,sum=0,a;\n\tdo{\n\t\tif((a=Translate(*str))!=-1){\n\t\t\tsum+=k*a;\n\t\t\tk/=10;\n\t\t}\t\n\t}while(*str++);\n\treturn sum;\n}\n\nvoid Print(int data,int tot){\n\tint p[7]={0,0,0,0,0,0,0},k=1000000;\n\tfor(int i=0;i&lt;=6;i++){\n\t\tp[i]=data/k;\n\t\tdata%=k;\n\t\tk/=10;\n\t}\n\tfor(int i=0;i&lt;=2;i++)\n\t\tprintf(\&quot;%d\&quot;,p[i]);\n\tprintf(\&quot;-\&quot;);\n\tfor(int i=3;i&lt;=6;i++)\n\t\tprintf(\&quot;%d\&quot;,p[i]);\n\tprintf(\&quot; %d\\n\&quot;,tot);\n}\n\nint main(){\n//\tfreopen(\&quot;in.txt\&quot;,\&quot;r\&quot;,stdin);\n\tint n,h;\n\tscanf(\&quot;%d\&quot;,&amp;n);\n\tfor(int i=1;i&lt;=n;i++){\n\t\tscanf(\&quot;%s\&quot;,str);\n\t\th=Hash(str);\n\t\tif(data[h]==1) log[++tot]=h;\n\t\tdata[h]++;\n\t}\n\tsort(log+1,log+1+tot);\n\tfor(int i=1;i&lt;=tot;i++)\n\t\tPrint(log[i],data[log[i]]);\n\tif(tot==0)\n\t\tprintf(\&quot;No duplicates.\&quot;);\n\t\n/*\tprintf(\&quot;%d\&quot;,Translate('M'));\n\tchar sr[10]=\&quot;ITS-EASY\&quot;;\n\tprintf(\&quot;%d\&quot;,Hash(sr));*/\n\t\n\t\n\treturn 0;\n}&quot;,&quot;classes&quot;:{&quot;has&quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><cstdio></cstdio></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><cstring></cstring></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string"><algorithm></algorithm></span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">10000000</span>;
<span class="hljs-keyword">char</span> str[<span class="hljs-number">200</span>];
<span class="hljs-keyword">int</span> data[MAX+<span class="hljs-number">200</span>],<span class="hljs-built_in">log</span>[<span class="hljs-number">10000000</span>],tot;

<p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Translate</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{
    <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">‘0’</span>&amp;&amp;c&lt;=<span class="hljs-string">‘9’</span>) <span class="hljs-keyword">return</span> c-<span class="hljs-string">‘0’</span>;
    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">‘Q’</span>||c==<span class="hljs-string">‘Z’</span>||c==<span class="hljs-string">‘-‘</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span>(c&lt;=<span class="hljs-string">‘P’</span>) <span class="hljs-keyword">return</span> (c-<span class="hljs-string">‘A’</span>)/<span class="hljs-number">3</span>+<span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> (c-<span class="hljs-string">‘A’</span><span class="hljs-number">-1</span>)/<span class="hljs-number">3</span>+<span class="hljs-number">2</span>;
}</p>
<p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>{
    <span class="hljs-keyword">int</span> k=<span class="hljs-number">1000000</span>,sum=<span class="hljs-number">0</span>,a;<br>    <span class="hljs-keyword">do</span>{
        <span class="hljs-keyword">if</span>((a=Translate(<em>str))!=<span class="hljs-number">-1</span>){<br>            sum+=k</em>a;<br>            k/=<span class="hljs-number">10</span>;
        }<br>    }<span class="hljs-keyword">while</span>(*str++);<br>    <span class="hljs-keyword">return</span> sum;<br>}</p>
<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data,<span class="hljs-keyword">int</span> tot)</span></span>{
    <span class="hljs-keyword">int</span> p[<span class="hljs-number">7</span>]={<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>},k=<span class="hljs-number">1000000</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">6</span>;i++){<br>        p[i]=data/k;<br>        data%=k;<br>        k/=<span class="hljs-number">10</span>;
    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">“%d”</span>,p[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">“-“</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">6</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">“%d”</span>,p[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">“ %d\n”</span>,tot);<br>}</p>
<p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
<span class="hljs-comment">//    freopen(“in.txt”,”r”,stdin);</span><br>    <span class="hljs-keyword">int</span> n,h;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">“%d”</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">“%s”</span>,str);<br>        h=Hash(str);<br>        <span class="hljs-keyword">if</span>(data[h]==<span class="hljs-number">1</span>) <span class="hljs-built_in">log</span>[++tot]=h;<br>        data[h]++;<br>    }<br>    sort(<span class="hljs-built_in">log</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">log</span>+<span class="hljs-number">1</span>+tot);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)<br>        Print(<span class="hljs-built_in">log</span>[i],data[<span class="hljs-built_in">log</span>[i]]);<br>    <span class="hljs-keyword">if</span>(tot==<span class="hljs-number">0</span>)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">“No duplicates.”</span>);</p>
<p><span class="hljs-comment">/*    printf(“%d”,Translate(‘M’));<br>    char sr[10]=”ITS-EASY”;<br>    printf(“%d”,Hash(sr));*/</span></p>
<pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;</code></pre><p>}</p></code></pre><br><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" role="presentation" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" data-cke-widget-drag-handler="1"></span></div><br>FZOJ1639魔板<p></p>
<p><strong>题目描述</strong></p>
<p>在魔方风靡全球之后，小Y发明了它的简化版——魔板，如图1所示，魔板由8个同样大小的方块组成，每个方块的颜色均不相同，本题中分别用数字1~8表示，它们可能出现在魔板的任一位置。任一时刻魔板的状态可以用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各个颜色块的颜色代号，得到数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示如图1所示魔板的状态，这也是本题中魔板的初始状态。</p>
<table class=" cke_show_border" border="0" cellspacing="0" cellpadding="0" align="left">
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>






<p><strong>图 1 魔板的初始状态</strong></p>
<p>对于魔板，可以施加三种不同的操作，分别以A,B,C标识。具体操作方法如下：</p>
<p>A:上下行互换。</p>
<p>B：每一行同时循环右移一格。</p>
<p>C：中间4个方块顺时针旋转一格。</p>
<p>应用这三种基本操作，可以由任一种状态达到任意另外一种状态。</p>
<p><strong>图 2 魔板的操作方法</strong></p>
<p>图2描述了上述3种操作的具体含义，图中方格外面的数字标识魔板的8个方块位置，方格内数字表示此次操作前该小方块所在位置，即：如果位置P对应的方格中数字为I，则表示此次操作前该方块在位置I。</p>
<p>任务一：请编一程序，对于输入的一个目标状态寻找一种操作的序列，使得从初始状态开始，经过此操作序列后使该魔板变为目标状态。</p>
<p>任务二：如果你的程序寻找到的操作序列在300步以内，会得到任务二的分数。</p>
<p>输入数据只有一行，内容是8个以一个空隔分隔的正整数，表示目标状态。输入样例对应的状态如图3所示。输出数据要求第一行输出你的程序寻找到的操作序列的步数L，随后L行是相应的操作序列，每行的行首输出一个字符，代表相应的操作。</p>
<table class=" cke_show_border" border="0" cellspacing="0" cellpadding="0" align="left">
<tbody>
<tr>
<td>2</td>
<td>6</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>7</td>
<td>5</td>
</tr>
</tbody>
</table>






<p><strong>图 3 魔板的输入样例的状态</strong></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>第一行输出你的程序寻找到的操作序列的步数L，随后L行是相应的操作序列，每行的行首输出一个字符，代表相应的操作。</p>
<p><strong>样例输入</strong></p>
<p>2 6 8 4 5 7 3 1</p>
<p><strong>样例输出</strong></p>
<p>7</p>
<p>B</p>
<p>C</p>
<p>A</p>
<p>B</p>
<p>C</p>
<p>C</p>
<p>B</p>
<p><strong> </strong></p>
<p><strong>学过康托展开，此题的算法就可以大大简化，正好，魔板是标准的全排列，用康托展开的方法算出hash值，并且在这个hash地址上存储相应的步数、是否被遍历等数据，十分方便。</strong></p>
</code></pre></div></i+n;j++)></len-n+<span></len;i++)></code></pre></div>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/c1dd3892/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/c1dd3892/" class="post-title-link" itemprop="url">离散hash优化总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:44:06" itemprop="dateCreated datePublished" datetime="2018-12-06T23:44:06+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:30:12" itemprop="dateModified" datetime="2019-05-05T13:30:12+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散优化总结"><a href="#离散优化总结" class="headerlink" title="离散优化总结"></a>离散优化总结</h1><p><strong>离散优化是一种常见的高效数据结构，它通过建立数据与存储结构（数组）之间（不一定）一一对应的映射关系来达到对复杂数据的优化。</strong> <strong>离散优化最重要的一点是建立映射，对于特殊的线段、点而言，这些映射可以是对一个区间的映射，即将某段线或者某块区域映射到数组里面去，从而在计算时降低时间复杂度。</strong> <strong>Hash优化：是对于字符串和数字的一种优化方式。它通过将数据映射到数组内的某个元素从而达到节省空间的效果。</strong> <strong>根据hash算法的不同，可能会引起数据的碰撞，即hash(key1)==hash(key2)，会使得数据存储出现错误。有两个方法可以解决：</strong></p>
<ol>
<li><strong>拉链法，将hash所对密码指向链表头，每次查找元素遍历整串链表，直到找到该元素为止（编程复杂度较高）</strong></li>
<li><strong>开地址法，当hash所对密码冲突时，将数据存入另外的位置（可以是下一个空位置，也可以是计算出的任意位置），当然如果使用线性开地址法，只要有一个数据碰撞，那么其余所有数据都很有可能进行至少一次碰撞，非常耗费时间。所以我们运用hash算出另一个位置并存储：</strong></li>
</ol>
<p><strong>while(hashtable[ad]!=0){</strong>    ad+=ad%3+1;//可以是异于主hash算法的另一hash算法** <strong>}</strong>    通常Hash算法分为两个板块：</p>
<ol>
<li><p><strong>查找元素，hash(key)对应的不一定是目标元素，需要对目标进行搜索，推荐使用开地址法进行搜索</strong></p>
</li>
<li><p><strong>插入元素，与查找同理，在插入之前必须检查此元素是否已被插入，再用开地址法存入相应的地址</strong></p>
<p><strong>Hash可用的构造方法</strong></p>
</li>
<li><p><strong>直接定址</strong></p>
</li>
<li><p><strong>取模法</strong></p>
</li>
<li><p><strong>平均取中值</strong></p>
</li>
<li><p><strong>随机数</strong></p>
</li>
<li><p><strong>数字分析法，将最有代表特色的位置作为特征码</strong></p>
</li>
<li><p><strong>折叠法，将数拆分成几部分并求和</strong></p>
</li>
<li><p><strong>基数法，将低进制数当作高进制数转化为原进制的数，并进行分析，取特征码（两个进制之间应该是互质的关系）</strong></p>
</li>
</ol>
<h2 id="1640-线段覆盖"><a href="#1640-线段覆盖" class="headerlink" title="1640: 线段覆盖"></a>1640: 线段覆盖</h2><p>时间限制:1 Sec  内存限制: 128 MB 提交:43  解决: 27 [<a href="http://fzoj.xndxfz.com/JudgeOnline/submitpage.php?id=1640" target="_blank" rel="noopener">提交</a>][<a href="http://fzoj.xndxfz.com/JudgeOnline/problemstatus.php?id=1640" target="_blank" rel="noopener">状态</a>][<a href="http://fzoj.xndxfz.com/JudgeOnline/bbs.php?pid=1640" target="_blank" rel="noopener">讨论版</a>]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>X轴上方有若干条平行于X轴的线段，求这些线段能覆盖到的X轴的总长度？</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数n(n&lt;=1000)，表示线段的个数； 接下来n行，每行两个整数ai,bi （-10^8&lt;=ai,bi&lt;=10^8)，代表一个线段的两个端点。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出覆盖x轴的长度。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>2

10 12

2 4</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>4</code></pre><p><strong>将每个点存入数组进行排序，然后遍历所有线段，将线段所覆盖到的点全部记录，输出结果</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">1200</span>],b[<span class="number">1200</span>],t[<span class="number">2400</span>],flag[<span class="number">2400</span>],tot,sum;</span><br><span class="line"><span class="comment">//flag[i]表示i到i+1之间是否被覆盖 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(s&lt;=e)&#123;</span><br><span class="line">		mid=(s+e)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(t[mid]==aim)&#123;</span><br><span class="line">			<span class="keyword">while</span>(t[mid<span class="number">-1</span>]==t[mid]) mid--;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(t[mid]&gt;aim)</span><br><span class="line">			e=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> s=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;b[i]) swap(a[i],b[i]);</span><br><span class="line">		t[++tot]=a[i]; t[++tot]=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(t+<span class="number">1</span>,t+<span class="number">1</span>+tot);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(t[i]==t[i<span class="number">-1</span>]) flag[i]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> top=find(<span class="number">1</span>,tot,a[i]),tail=find(<span class="number">1</span>,tot,b[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=top;j&lt;=tail<span class="number">-1</span>;j++)</span><br><span class="line">			<span class="keyword">if</span>(flag[j]!=<span class="number">-1</span>) flag[j]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> nxt=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(flag[nxt]==<span class="number">-1</span>) nxt++;</span><br><span class="line">		<span class="keyword">if</span>(flag[i]==<span class="number">1</span>) sum+=t[nxt]-t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<h2 id="1234-图形面积"><a href="#1234-图形面积" class="headerlink" title="1234: 图形面积"></a>1234: 图形面积</h2><p>时间限制:0 Sec  内存限制: 128 MB 提交:11  解决: 2 [<a href="http://fzoj.xndxfz.com/JudgeOnline/submitpage.php?id=1234" target="_blank" rel="noopener">提交</a>][<a href="http://fzoj.xndxfz.com/JudgeOnline/problemstatus.php?id=1234" target="_blank" rel="noopener">状态</a>][<a href="http://fzoj.xndxfz.com/JudgeOnline/bbs.php?pid=1234" target="_blank" rel="noopener">讨论版</a>]</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>桌面上放了N个矩形，这N个矩形可能有互相覆盖的部分，求它们组成的图形的面积。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入第一行为一个数N（1≤N≤100），表示矩形的数量。下面N行，每行四个整数，分别表示每个矩形的左下角和右上角的坐标，坐标范围为–10^8到10^8之间的整数。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出只有一行，一个整数，表示图形的面积。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>3

1 1 4 3

2 -1 3 2

4 0 5 2</code></pre><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>10</code></pre><p><strong>二维离散优化，将图形在x轴上投影的点找出，并且分析相邻两点间的距离（即图形的宽），以及投影这段线的图形在y轴上的投影（即图形的高），ans+=d*h即可</strong> <a href="http://noi.openjudge.cn/ch0305/1551/" target="_blank" rel="noopener">http://noi.openjudge.cn/ch0305/1551/</a> <strong>Sumsets</strong> <strong>描述</strong> 给出一个整数集合s，找到集合中最大的d，让等式a+b+c=d成立， 其中，a,b,c,d是集合S中不同的元素。 输入 Several S, each consisting of a line containing an integer 1 &lt;= n&lt;= 1000 indicating the number of elements in S, followed by the elements ofS, one per line. Each element of S is a distinct integer between -536870912 and+536870911 inclusive. The last line of input contains 0. 输出 For each S, a single line containing d, or a single line containing”no solution”. 样例输入 5 2 3 5 7 12 5 2 16 64 256 1024 0 样例输出 12 no solution <strong>经过变形可得a+b=d-c，先枚举a+b用hash表存储</strong> <strong>再枚举d-c，如果在hash表中有值,且该值对应的a，b异于d，c，那么将此时的d存起来，取最大值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ADD=<span class="number">536870911</span>;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">1000020</span>],in[<span class="number">1020</span>],ha1[<span class="number">1000020</span>],ha2[<span class="number">1000020</span>],data[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashh</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="comment">//	key+=ADD;</span></span><br><span class="line">	<span class="keyword">int</span> ad=((key%<span class="number">1000000</span>)+<span class="number">10061894</span>)%<span class="number">1000000</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag[ad]!=<span class="number">0</span>)&#123;</span><br><span class="line">		ad+=ad%<span class="number">11</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ad&gt;<span class="number">1000000</span>) ad%=<span class="number">1000000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="comment">//	key+=ADD;</span></span><br><span class="line">	<span class="keyword">int</span> ad=((key%<span class="number">1000000</span>)+<span class="number">10061894</span>)%<span class="number">1000000</span>;</span><br><span class="line">	<span class="keyword">while</span>(data[ad]!=key&amp;&amp;flag[ad]!=<span class="number">0</span>)&#123;</span><br><span class="line">		ad+=ad%<span class="number">11</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ad&gt;<span class="number">1000000</span>) ad%=<span class="number">1000000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag[ad]==<span class="number">0</span>?<span class="number">-1</span>:ad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,maxx;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">		maxx=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> ans=hashh(in[i]+in[j]);</span><br><span class="line">				flag[ans]=<span class="number">1</span>,ha1[ans]=in[i],ha2[ans]=in[j],data[ans]=in[i]+in[j];</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> ans=find(in[i]-in[j]);</span><br><span class="line">				<span class="keyword">if</span>(i==j||ans==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(flag[ans]&amp;&amp;ha1[ans]!=in[i]&amp;&amp;ha1[ans]!=in[j]&amp;&amp;ha2[ans]!=in[i]&amp;&amp;ha2[ans]!=in[j])</span><br><span class="line">					maxx=max(maxx,in[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(maxx!=<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxx);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"no solution\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<h2 id="1807-正方形"><a href="#1807-正方形" class="headerlink" title="1807:正方形"></a>1807:正方形</h2><p><a href="http://noi.openjudge.cn/ch0305/1807/" target="_blank" rel="noopener">http://noi.openjudge.cn/ch0305/1807/</a> </p>
<p>描述 给出平面上一些点的坐标，统计由这些点可以组成多少个正方形。注意：正方形的边不一定平行于坐标轴。 </p>
<p>输入 输入包括多组测试数据。每组的第一行是一个整数n (1 &lt;= n &lt;= 1000)，表示平面上点的数目，接下来n行，每行包括两个整数，分别给出一个点在平面上的x坐标和y坐标。输入保证：平面上点的位置是两两不同的，而且坐标的绝对值都不大于20000。最后一组输入数据中n = 0，这组数据表示输入的结束，不用进行处理。</p>
<p> 输出 对每组输入数据，输出一行，表示这些点能够组成的正方形的数目。 </p>
<p>样例输入 4 1 0 0 1 1 1 0 0 9 0 0 1 0 2 0 0 2 1 2 2 2 0 1 1 1 2 1 4 -2 5 3 7 0 0 5 2 0 </p>
<p>样例输出 1 6 1</p>
<p> <strong>将每个点用hash表存起来，这里有个小技巧，可以开longlong数组，从而实现一个变量存一个点的功效。然后枚举任意两个未枚举的点，将它们作为正方形的一条边，通过规律我们可以确定两个待定的正方形，寻找计算出的正方形另两个点的位置，搜索hash表，如果都有相应的元素对应，那么即为找到一个正方形。注意：每两个点都会被遍历，即每条边都会被遍历，所以正方形的个数是边数d&gt;&gt;2</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">30000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;poi[MAX+<span class="number">500</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> hashtable[MAX+<span class="number">500</span>];</span><br><span class="line"><span class="comment">//任意选取两个点，可确定两个正方形，将两个正方形除已选择外的点hash存储 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ad=(x*x+y*y)%<span class="number">30000</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> aim=x*<span class="number">100000</span>+y;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		ad+=ad%<span class="number">31</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ad&gt;MAX) ad%=MAX;</span><br><span class="line">		<span class="keyword">if</span>(hashtable[ad]==aim) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(hashtable[ad]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;hashtable[ad]=aim;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindHash</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ad=(x*x+y*y)%<span class="number">30000</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> aim=x*<span class="number">100000</span>+y;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		ad+=ad%<span class="number">31</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ad&gt;MAX) ad%=MAX;</span><br><span class="line">		<span class="keyword">if</span>(hashtable[ad]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(hashtable[ad]==aim) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,x,y,ans;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(hashtable,<span class="number">0</span>,<span class="keyword">sizeof</span>(hashtable));</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;poi[i].x,&amp;poi[i].y);</span><br><span class="line">			poi[i].x+=<span class="number">20001</span>; poi[i].y+=<span class="number">20001</span>;</span><br><span class="line">			InsertHash(poi[i].x,poi[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/*	for(int i=1;i&lt;=MAX;i++)</span></span><br><span class="line"><span class="comment">			if(hashtable[i]!=0)</span></span><br><span class="line"><span class="comment">				printf("%lld\n",hashtable[i]);*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> x1,x2,y1,y2,delx,dely;</span><br><span class="line">				delx=poi[i].x-poi[j].x;</span><br><span class="line">				dely=poi[i].y-poi[j].y;</span><br><span class="line">				x1=poi[i].x+dely; y1=poi[i].y-delx;</span><br><span class="line">				x2=poi[j].x+dely; y2=poi[j].y-delx;</span><br><span class="line">				<span class="keyword">if</span>(FindHash(x1,y1)&amp;&amp;FindHash(x2,y2)) ans++;</span><br><span class="line">				</span><br><span class="line">				x1=poi[i].x-dely; y1=poi[i].y+delx;</span><br><span class="line">				x2=poi[j].x-dely; y2=poi[j].y+delx;</span><br><span class="line">				<span class="keyword">if</span>(FindHash(x1,y1)&amp;&amp;FindHash(x2,y2)) ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans&gt;&gt;<span class="number">2</span>);<span class="comment">//根据两个点找正方形会找四次 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p>FZOJ1639魔板</p>
<p> <strong>题目描述</strong> 在魔方风靡全球之后，小Y发明了它的简化版——魔板，如图1所示，魔板由8个同样大小的方块组成，每个方块的颜色均不相同，本题中分别用数字1~8表示，它们可能出现在魔板的任一位置。任一时刻魔板的状态可以用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各个颜色块的颜色代号，得到数字序列即可表示此时魔板的状态。</p>
<p>例如，序列(1,2,3,4,5,6,7,8)表示如图1所示魔板的状态，这也是本题中魔板的初始状态。</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>8</p>
<p>7</p>
<p>6</p>
<p>5</p>
<pre><code>**图 1 魔板的初始状态** 对于魔板，可以施加三种不同的操作，分别以A,B,C标识。具体操作方法如下： A:上下行互换。 B：每一行同时循环右移一格。 C：中间4个方块顺时针旋转一格。 应用这三种基本操作，可以由任一种状态达到任意另外一种状态。</code></pre><p> <strong>图 2 魔板的操作方法</strong> 图2描述了上述3种操作的具体含义，图中方格外面的数字标识魔板的8个方块位置，方格内数字表示此次操作前该小方块所在位置，即：如果位置P对应的方格中数字为I，则表示此次操作前该方块在位置I。 任务一：请编一程序，对于输入的一个目标状态寻找一种操作的序列，使得从初始状态开始，经过此操作序列后使该魔板变为目标状态。 任务二：如果你的程序寻找到的操作序列在300步以内，会得到任务二的分数。 输入数据只有一行，内容是8个以一个空隔分隔的正整数，表示目标状态。输入样例对应的状态如图3所示。输出数据要求第一行输出你的程序寻找到的操作序列的步数L，随后L行是相应的操作序列，每行的行首输出一个字符，代表相应的操作。</p>
<p>2</p>
<p>6</p>
<p>8</p>
<p>4</p>
<p>1</p>
<p>3</p>
<p>7</p>
<p>5</p>
<pre><code>**图 3 魔板的输入样例的状态** </code></pre><p><strong>输入</strong> <strong>输出</strong> 第一行输出你的程序寻找到的操作序列的步数L，随后L行是相应的操作序列，每行的行首输出一个字符，代表相应的操作。 </p>
<p><strong>样例输入</strong> 2 6 8 4 5 7 3 1 <strong>样例输出</strong> 7 B C A B C C B  </p>
<p><strong>如果魔板数据太小，可用直接地址法，但本题魔板有10^8种可能，不现实。又考虑到在300步内可得到目标魔板，于是想到使用hash表存储已经遍历过的走法。</strong> <strong>从初始状态开始，进行BFS，取出一个元素，每次考虑三种可能的变化情况，搜索hash表，如果还未考虑此情况，就加入队列，继续搜索，同时记录每种走法的上一步father[]</strong> <strong>直到程序找到了目标解，那么依次遍历father[]，输出结果即可</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/675d1a4b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/675d1a4b/" class="post-title-link" itemprop="url">求最大网络流（最小割）总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:43:33" itemprop="dateCreated datePublished" datetime="2018-12-06T23:43:33+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-04 23:39:44" itemprop="dateModified" datetime="2019-05-04T23:39:44+08:00">2019-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  <strong>求最大网络流总结</strong> </p>
<p>一个有向图，每条边都有最大可能的数据传输量c，要求一个点到某个点一次能传输的最大数据量，即为求最大网络流，每条边实际的数据传输量称为流量。**  <strong>基本思路：使用贪心算法，每次找出能使总流量更大的边，将数据向那条边流。</strong>  <strong>Ford-fulkerson算法</strong></p>
<ol>
<li><strong>读入所有有向边，并且加入流量为0的反向边</strong></li>
<li><strong>DFS查找所有点u的未被遍历的边(u,v)</strong></li>
<li><strong>如果满足这条边流量大于0，更新这条边以及它的反向边的流量（同时会DFS遍历v点）</strong></li>
<li><strong>重复2操作，直到所有点被遍历完成</strong></li>
</ol>
<p><strong>算法复杂度：O(m+n)≈O(n^2)</strong>  <strong>Dinic算法</strong> <strong>原理：利用BFS求最短路的方法将所有的边按从源点到汇点的距离排序，从而避免不必要的增广</strong></p>
<ol>
<li><strong>BFS求源点到所有点的距离</strong></li>
<li><strong>DFS 遍历所有边(u,v)</strong></li>
<li><strong>如果dis[v]==dis[u]+1且边的长度大于0，那么更新这条边以及它的反向边的流量（同时DFS遍历了v点）</strong></li>
</ol>
<p><strong>用dis数组的好处：不仅减少了不必要的增广步骤，而且使增广顺序有序，不必记录点是否已被遍历</strong></p>
<ol>
<li><strong>重复2操作，直到没有符合条件的边为止</strong> <strong>算法复杂度：</strong>O(n^2<em>m)。*</em>（最坏情况，平均情况大大优于<strong>**FF算法）</strong></li>
</ol>
<p><strong>割</strong> <strong>在网络中，将源点与汇点通过割边的方式划分成两个部分，割掉的所有边都是割，其中，s到t为正向割边，t到s为逆向割边</strong> <strong>割的容量：所有正向割边的容量和</strong> <strong>最小割：容量和最小的割</strong> **      定理1：如果f是网络中的一个流，那么f的流为割的正向边与逆向边容量之差** **      定理二：如果f是一个流，CUT (S,T)是一个割，且f的值等于割CUT(S,T)的容量，那么f是一个最大流，CUT(S,T)是一个最小割。** **      推论：f的流量&lt;=此流的割的容量** <strong>求最小割与求最大网络流等价</strong>   POJ 1273 Drainage Ditches <strong>Description</strong> Every time itrains on Farmer John’s fields, a pond forms over Bessie’s favorite cloverpatch. This means that the clover is covered by water for awhile and takesquite a long time to regrow. Thus, Farmer John has built a set of drainageditches so that Bessie’s clover patch is never covered in water. Instead, thewater is drained to a nearby stream. Being an ace engineer, Farmer John hasalso installed regulators at the beginning of each ditch, so he can control atwhat rate water flows into that ditch. Farmer John knows not only how many gallons of water each ditch can transportper minute but also the exact layout of the ditches, which feed out of the pondand into each other and stream in a potentially complex network. Given all this information, determine the maximum rate at which water can betransported out of the pond and into the stream. For any given ditch, waterflows in only one direction, but there might be a way that water can flow in acircle. <strong>Input</strong> <strong><em>The input includesseveral cases.</em></strong> For each case, the first line contains twospace-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200).N is the number of ditches that Farmer John has dug. M is the number of intersectionspoints for those ditches. Intersection 1 is the pond. Intersection point M isthe stream. Each of the following N lines contains three integers, Si, Ei, andCi. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections betweenwhich this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0&lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow throughthe ditch. <strong>Output</strong> For each case,output a single integer, the maximum rate at which water may emptied from thepond. <strong>Sample Input</strong> 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10 <strong>Sample Output</strong> 50 <strong>题意</strong> 现在有m个池塘(从1到m开始编号,1为源点,m为汇点),及n条水渠,给出这n条水渠所连接的点和所能流过的最大流量，  <strong>Ford-Fulkerson算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">600</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],nxt[MAX],go[MAX],flow[MAX],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//加边 </span></span><br><span class="line">	nxt[++arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum]=b;</span><br><span class="line">	flow[arcnum]=c;<span class="comment">//记录该边容量 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> minc)</span></span>&#123;<span class="comment">//起点u，终点t，整条路径中流量最小为minc</span></span><br><span class="line"> 	<span class="keyword">if</span>(u==t) <span class="keyword">return</span> minc;</span><br><span class="line"> 	vis[u]=<span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line"> 		<span class="keyword">int</span> v=go[p];</span><br><span class="line"> 		<span class="keyword">if</span>(!vis[v]&amp;&amp;flow[p]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">int</span> f=Dfs(v,t,min(minc,flow[p]));</span><br><span class="line"> 			<span class="keyword">if</span>(f&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> 				flow[p]-=f;<span class="comment">//正向边减去算出的流量 </span></span><br><span class="line"> 				flow[p^<span class="number">1</span>]+=f;<span class="comment">//逆向边加上算出的流量</span></span><br><span class="line"> 				<span class="comment">/* n为任意偶自然数，那么n^1=n+1;(n+1)^1=n    */</span></span><br><span class="line">				<span class="keyword">return</span> f; </span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果都不符合条件，返回0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">int</span> f=Dfs(s,t,<span class="number">99999999</span>);</span><br><span class="line">		<span class="keyword">if</span>(f&lt;=<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">		ans+=f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m,a,b,c;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">		arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			addarc(a,b,c);<span class="comment">//正向边流量为c </span></span><br><span class="line">			addarc(b,a,<span class="number">0</span>);<span class="comment">//逆向边流量为0 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxFlow(<span class="number">1</span>,n));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Dinic算法**</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],go[MAX],nxt[MAX],flow[MAX],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> que[MAX*MAX],dis[MAX],top,rear,current[MAX],vis[MAX];</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	nxt[++arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum]=b;</span><br><span class="line">	flow[arcnum]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> minc)</span></span>&#123;</span><br><span class="line"><span class="comment">//	printf("dfs %d %d start\n",u,t);</span></span><br><span class="line">	<span class="keyword">if</span>(u==t) <span class="keyword">return</span> minc;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=current[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">	</span><br><span class="line">		current[u]=p;</span><br><span class="line">		<span class="keyword">int</span> v=go[p]; </span><br><span class="line"><span class="comment">//		printf("%d: %d-&gt;%d\n",p,u,v);</span></span><br><span class="line">		<span class="keyword">if</span>(dis[v]==dis[u]+<span class="number">1</span>&amp;&amp;flow[p]&gt;<span class="number">0</span>)&#123;<span class="comment">//边一定要存在 </span></span><br><span class="line">			<span class="keyword">int</span> f=DFS(v,t,min(minc,flow[p]));</span><br><span class="line">			<span class="keyword">if</span>(f)&#123;</span><br><span class="line">				flow[p]-=f;</span><br><span class="line">				flow[p^<span class="number">1</span>]+=f;</span><br><span class="line">				<span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;<span class="comment">//BFS优化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">	top=rear=<span class="number">0</span>;</span><br><span class="line">	que[rear++]=s;</span><br><span class="line">	dis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u=que[top++],v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p];</span><br><span class="line">			<span class="keyword">if</span>(flow[p]&gt;<span class="number">0</span>&amp;&amp;dis[v]==INF)&#123;<span class="comment">//边存在且点未被更新时才更新 </span></span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">				que[rear++]=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=rear);</span><br><span class="line">	<span class="keyword">return</span> dis[t]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;<span class="comment">//Dinic算法 </span></span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,f;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			current[i]=first[i];<span class="comment">//每次BFS后都要重置current数组</span></span><br><span class="line">		<span class="keyword">while</span>(f=DFS(s,t,INF))</span><br><span class="line">			ans+=f;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">		arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			addarc(a,b,c);</span><br><span class="line">			addarc(b,a,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/*		for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">			printf("%d %d\n",i,first[i]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf("node end\n");</span></span><br><span class="line"><span class="comment">		for(int i=1;i&lt;=2*m;i++)&#123;</span></span><br><span class="line"><span class="comment">			printf("%d %d %d\n",i,go[i],nxt[i]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf("edge end\n");*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxFlow(<span class="number">1</span>,n));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>HDU4183 Pahom on Water</strong> <strong>Problem Description</strong> Pahom on Water isan interactive computer game inspired by a short story of Leo Tolstoy about apoor man who, in his lust for land, forfeits everything. The game’s startingscreen displays a number of circular pads painted with colours from the visiblelight spectrum. More than one pad may be painted with the same colour (definedby a certain frequency) except for the two colours red and violet. The displaycontains only one red pad (the lowest frequency of 400 THz) and one violet pad(the highest frequency of 789 THz). A pad may intersect, or even containanother pad with a different colour but never merely touch its boundary. Thedisplay also shows a figure representing Pahom standing on the red pad. The game’s objective is to walk the figure of Pahom from the red pad to theviolet pad and return back to the red pad. The walk must observe the followingrules: 1.If pad α and pad β have a common intersection and the frequency of the colourof pad α is strictly smaller than the frequency of the colour of pad β, thenPahom figure can walk from α to β during the walk from the red pad to theviolet pad 2. If pad α and pad β have a common intersection and the frequency of thecolour of pad α is strictly greater than the frequency of the colour of pad β,then Pahom figure can walk from α to β during the walk from the violet pad tothe red pad 3. A coloured pad, with the exception of the red pad, disappears from displaywhen the Pahom figure walks away from it. The developer of the game has programmed all the whizzbang features of thegame. All that is left is to ensure that Pahom has a chance to succeed in eachinstance of the game (that is, there is at least one valid walk from the redpad to the violet pad and then back again to the red pad.) Your task is towrite a program to check whether at least one valid path exists in eachinstance of the game.   <strong>Input</strong> The input startswith an integer K (1 &lt;= K &lt;= 50) indicating the number of scenarios on aline by itself. The description for each scenario starts with an integer N (2&lt;= N &lt;= 300) indicating the number of pads, on a line by itself, followedby N lines that describe the colors, locations and sizes of the N pads. Eachline contains the frequency, followed by the x- and y-coordinates of the pad’scenter and then the radius. The frequency is given as a real value with no morethan three decimal places. The coordinates and radius are given, in meters, asintegers. All values are separated by a single space. All integer values are inthe range of -10,000 to 10,000 inclusive. In each scenario, all frequencies arein the range of 400.0 to 789.0 inclusive. Exactly one pad will have a frequencyof “400.0” and exactly one pad will have a frequency of “789.0”.   <strong>Output</strong> The output foreach scenario consists of a single line that contains: Game is VALID, or Gameis NOT VALID   <strong>Sample Input</strong> 2 2 400.0 0 0 4 789.0 7 0 2 4 400.0 0 0 4 789.0 7 0 2 500.35 5 0 2 500.32 5 0 3   <strong>Sample Output</strong> Game is NOT VALID Game is VALID   <strong>题目大意：</strong> 有多个点，每个点给出坐标与半径，加入两个点相交，就可以从这两个点走。题目要求先从起点到终点，再从终点回到起点。从起点到终点的过程中，只能从频率小的走到频率大的点（前提是两点相交），从终点到起点的过程中，只能从频率大的走到频率小的。在走的过程中，除了起点与终点，别的只要走过就会消失，就是说只能走一次。问可不可以从起点到终点又回到起点。  <strong>找到输入数据中最小和最大的两个，求两个之间的最大网络流</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1500</span>;</span><br><span class="line"><span class="keyword">double</span> data[MAX];</span><br><span class="line"><span class="keyword">int</span> first[MAX],go[MAX],nxt[MAX],arcnum=<span class="number">1</span>,x[MAX],y[MAX],r[MAX];</span><br><span class="line"><span class="keyword">int</span> flow[MAX],que[MAX],top,rear,dis[MAX],vis[MAX];</span><br><span class="line"><span class="keyword">int</span> k,n,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	nxt[++arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum]=b;</span><br><span class="line">	flow[arcnum]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> minc)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==t) <span class="keyword">return</span> minc;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">		<span class="keyword">int</span> v=go[p],f;</span><br><span class="line">		<span class="keyword">if</span>(dis[v]==dis[u]+<span class="number">1</span>&amp;&amp;flow[p]&gt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">if</span>(f=DFS(v,t,min(minc,flow[p])))&#123;</span><br><span class="line">				flow[p]-=f;</span><br><span class="line">				flow[p^<span class="number">1</span>]+=f;</span><br><span class="line">				<span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">	top=rear=<span class="number">0</span>;</span><br><span class="line">	que[rear++]=s;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u=que[top++],v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p];</span><br><span class="line">			<span class="keyword">if</span>(dis[v]==INF&amp;&amp;flow[p]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">				que[rear++]=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=rear);</span><br><span class="line">	<span class="keyword">return</span> dis[t]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,f;</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))</span><br><span class="line">		<span class="keyword">while</span>(f=DFS(s,t,INF))</span><br><span class="line">			ans+=f;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> red=<span class="number">0</span>,purple=n+<span class="number">1</span>;</span><br><span class="line">		data[<span class="number">0</span>]=<span class="number">9999</span>; data[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%f%d%d%d"</span>,&amp;data[i],&amp;x[i],&amp;y[i],&amp;r[i]);</span><br><span class="line">			<span class="keyword">if</span>(data[i]&lt;data[red]) red=i;</span><br><span class="line">			<span class="keyword">if</span>(data[i]&gt;data[purple]) purple=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				<span class="keyword">if</span>(data[i]&lt;data[j]&amp;&amp;<span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))&lt;=r[i]+r[j])</span><br><span class="line">					addarc(i,j,<span class="number">1</span>),addarc(j,i,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(MaxFlow(red,purple)&lt;<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"Game is NOT VALID\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Game is VALID\n"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/1acd21ea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/1acd21ea/" class="post-title-link" itemprop="url">Tarjan算法求无向图割边割点、最近公共祖先的总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:43:10" itemprop="dateCreated datePublished" datetime="2018-12-06T23:43:10+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:41:54" itemprop="dateModified" datetime="2019-05-05T13:41:54+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="无向图tarjan求割边割点、最近公共祖先总结"><a href="#无向图tarjan求割边割点、最近公共祖先总结" class="headerlink" title="无向图tarjan求割边割点、最近公共祖先总结"></a>无向图tarjan求割边割点、最近公共祖先总结</h1><p><strong>割点：删除这个点之后整个图变成不连通的两个部分的点</strong> <strong>割点集合：在一个无向图中删除该集合中的所有点，能使原图变成互不相连的连通块的点的集合</strong> <strong>点连通度：最小割点集合点数</strong> <strong>割边（桥）：类似于割点，删除一条边后会使一个连通图变得不完全连通</strong> <strong>割边集合：所有割边的集合</strong> <strong>边连通度：最小割边集合边数</strong>  <strong>与有割边割点的图对应，有一种无向图，它的边连通度（或点连通度）大于1，那么我们称它为双连通分量，即删掉任意点（或边），图仍然是连通的</strong>  <strong>用tarjan算法求割点</strong> <strong>原理：在一棵DFS树中</strong> <strong>根root是割顶当且仅当它至少有两个儿子</strong> <strong>其他点v是割顶当且仅当它有一个儿子u,从u或者u的后代出发没有指向v祖先(不含v)的B边,则删除v以后u和v的父亲不连通,故为割顶</strong></p>
<ol>
<li><p><strong>基本算法同tarjan经典算法</strong></p>
</li>
<li><p><strong>每遍历一个新的（颜色为白色）u的儿子v都记录个数</strong></p>
</li>
<li><p><strong>low[u]值更新后进行以下判断（前提v未被遍历过）：</strong></p>
</li>
<li><p><strong>u为树根，且儿子个数大于1</strong></p>
</li>
<li><p><strong>u不为树根，但low[v]&gt;=dfn[u]（说明v及其子节点都不能达到u以上的父亲节点）</strong></p>
</li>
</ol>
<p><strong>满足以上任意条件u便为割点，记录在数组里，tarjan完成后再输出（中途输出会重复）</strong>  <strong>用tarjan算法求割边（桥）</strong> <strong>原理</strong> <strong>发现T边(u,v)时若发现v和它的后代不存在一条连接u或其祖先的B边,则删除(u,v)后u和v不连通,因此(u,v)为桥</strong> <strong>桥的判定算法</strong> <strong>发现T边(u, v)时若low[v]&gt;=dfn[u],则(u,v)为桥</strong></p>
<ol>
<li><p><strong>基本算法同tarjan经典算法</strong></p>
</li>
<li><p><strong>形参加上father，作用为记录u的父亲节点，避免在遍历v时遇到重边重新更新low[u]</strong></p>
</li>
<li><p><strong>在“v已被遍历”的位置加上判断 如果v点等于father，那么就不执行更新low[u]值</strong></p>
</li>
<li><p><strong>Tarjan算法结束后，遍历所有节点u及其子节点v，如果low[u]==low[v]，那么这条边就为割边</strong></p>
<p><strong>求点双连通分支(去掉割点之后所得的双连通分量)</strong></p>
</li>
<li><p><strong>tarjan求割点</strong></p>
</li>
<li><p><strong>每找到一个割点，将它上面的所有点弹出栈，所得的点集就是双连通分量</strong></p>
<p><strong>求边双连通分支</strong></p>
</li>
<li><p><strong>tarjan找桥边</strong></p>
</li>
<li><p><strong>删除桥边（1、2两步同时完成）</strong></p>
</li>
<li><p><strong>剩余各部分则为双连通分量</strong></p>
<p><strong>有桥的连通图，加边变成双连通图</strong></p>
</li>
<li><p><strong>tarjan找桥边并删除桥边</strong></p>
</li>
<li><p><strong>将点双连通分量收缩成为一个顶点</strong></p>
</li>
<li><p><strong>加回桥边，统计度为1的顶点个数</strong></p>
</li>
<li><p><strong>根据规律，需要加入的桥边最少为(n+1)/2条</strong></p>
<p><strong>最近公共祖先LCA</strong> <strong>原理：在一棵树中，父亲结点与儿子结点的最近公共祖先为父亲结点</strong></p>
</li>
<li><p><strong>建立并查集</strong></p>
</li>
<li><p><strong>DFS先序遍历一棵树</strong></p>
</li>
<li><p><strong>在每个结点上，进行以下操作：</strong></p>
</li>
<li><p><strong>涂黑该结点</strong></p>
</li>
<li><p><strong>如果有关于该结点a的询问，搜索另一询问的结点b，如果b也被涂黑，那么它们的公共祖先为b所在并查集的祖先，输出结果</strong></p>
<p><strong>拓展：求一棵树中两个结点的距离</strong></p>
</li>
<li><p><strong>建立dis[]数组，记录从树根到i点的距离dis[i]</strong></p>
</li>
<li><p><strong>则a与b的距离为</strong></p>
</li>
</ol>
<p><strong>d=dis[a]-dis[LCA]+dis[b]-dis[LCA]=dis[a]+dis[b]-2*dis[LCA]</strong>    </p>
<p><strong>Poj 1144</strong> </p>
<p><strong>描述</strong> 一个电话线公司（简称TLC）正在建立一个新的电话线缆网络。他们连接了若干个地点分别从1到N编号。没有两个地点有相同的号码。这些线是双向的并且能使两个地点保持通讯。每个地点的线都终结于电话交换机。每个地点都有一个电话交换机。从每个地点都能通过线缆到达其他任意的地点，然而它并不需要直接连接，它可以通过若干个交换机来到达目的地。有时候某个地点供电出问题时，交换机就会停止工作。TLC的工作人员意识到，除非这个地点是不可达的，否则这种情况就会发生，它还会导致一些其它的地点不能互相通讯。在这种情况下我们会称这个地点（错误发生的地方）为critical。现在工作人员想要写一个程序找到所有critical地点的数量。帮帮他们。 </p>
<p><strong>输入</strong> 输入文件包括若组测试数据。每一组是一个网络，每一组测试数据的第一行是地点的总数量N&lt;100.每个接下来最多N行包括一个数字表示一个地点和与它相连接的地点的数字。这些最多N行完全描述了整个网络，比如，网络中每个直接连接的两个地点被至少一行包括。一行内的所有数字都要用空格隔开。每组数据需要用单独的一个0结束。最后的块只有一行即N=0。</p>
<p> <strong>输出</strong> 输出除了最后一个组其他每一个组的critical地点的数量，每个块用一行输出。 </p>
<p><strong>样例输入：</strong> 5 5 1 2 3 4 0 6 2 1 3 5 4 6 2 0 0 </p>
<p><strong>样例输出</strong> 1 2 </p>
<p><strong>提示：</strong></p>
<p> 你需要确定每行的结束。为了方便判断，每行的结束都没有多余的空白 </p>
<p><strong>读入是难点，其余就是找割点的部分</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> first[<span class="number">120</span>],go[<span class="number">10000</span>],nxt[<span class="number">10000</span>],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">120</span>],low[<span class="number">120</span>],idx;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">100000</span>],top,ans[<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++idx;</span><br><span class="line"><span class="comment">//	stack[++top]=u;</span></span><br><span class="line">	<span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">		<span class="keyword">int</span> v=go[p];</span><br><span class="line">		<span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;</span><br><span class="line">			tarjan(v); son++;</span><br><span class="line">			low[u]=min(low[u],low[v]);</span><br><span class="line">			<span class="keyword">if</span>((u==<span class="number">1</span>&amp;&amp;son&gt;<span class="number">1</span>)||(u!=<span class="number">1</span>&amp;&amp;low[v]&gt;=dfn[u])) ans[u]++;<span class="comment">//一定使用这种方法记录u是否为割点 </span></span><br><span class="line">		<span class="comment">//		printf("u=%d son=%d ans=%d low[v]=%d dfn[u]=%d\n",u,son,ans,low[v],dfn[u]);</span></span><br><span class="line">		&#125;<span class="keyword">else</span> low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,a,b;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">		<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">		arcnum=<span class="number">1</span>; top=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a)&amp;&amp;a!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">do</span>&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b);</span><br><span class="line">				<span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;<span class="comment">//一定不考虑自环 </span></span><br><span class="line">				addarc(a,b);</span><br><span class="line">				addarc(b,a);</span><br><span class="line">				c=getchar();</span><br><span class="line">			&#125;<span class="keyword">while</span>(c!=<span class="string">'\n'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		tarjan(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(ans[i])</span><br><span class="line">				sum++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​        
​        </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p>**POJ1523</p>
<p> <strong>描述</strong> 考虑一下下图所示的两个网络。假设在这些网络中数据只能在两个直接连接的节点中传输。在左图网络中一个单独节点3的错误就会阻止一些其它可用节点的互相通信。节点1和2可以保持通信，4和5也是如此，但是其他的配对就无法再保持通信了。 因此3节点就是这个网络中的SinglePoint of Failure（SPF）。严格来讲，如果一个任意的不可用节点会阻止原有全通网络中至少一对可用节点保持通信，那么这就是一个SPF。注意在右图的网络中并没有这种节点。因此这个网络就没有SPF。至少有两台机器需要错误才能导致这个网络中有可用的节点对无法通信。</p>
<p> <strong>输入</strong> 输入会包括若干网络的描述。一个网络描述会包括若干对的整数，每行一对整数来描述节点的连接情况，先后顺序是无关的，如：1 2和2 1描述了相同的连接。所有的节点编码会从1到1000.一个单独的0行来结束连接节点的列表。一个空的网络描述结束输入。输入文档中空白的行要被忽略。</p>
<p> <strong>输出</strong> 对于每个输入的网络中，你需要输出存在的SPF节点的列表在文档中。 文档中第一个网络需要用“Network #1”来定义，第二个则是” Network #2”等等（如样例）。每个SPF节点，输出一行，方式如下方例子所示，列出节点的编号和当这个节点失效时完全连通的子网络的个数。如果网络中没有SPF节点，输出“NO SPF nodes“即可。 </p>
<p><strong>样例输入：</strong> 1 2 5 4 3 1 3 2 3 4 3 5 0 1 2 2 3 3 4 4 5 5 1 0 1 2 2 3 3 4 4 6 6 3 2 5 5 1 0 0 </p>
<p><strong>样例输出</strong></p>
<p> Network #1 </p>
<p>SPFnode 3 leaves 2 subnets </p>
<p>Network #2 </p>
<p>NoSPF nodes </p>
<p>Network #3 SPFnode 2 leaves 2 subnets SPFnode 3 leaves 2 subnets </p>
<p><strong>读入是难点，接下来是找割点，删除割点并且DFS找点双连通分量</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> first[<span class="number">1200</span>],go[<span class="number">10000</span>],nxt[<span class="number">10000</span>],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">1200</span>],low[<span class="number">1200</span>],exist[<span class="number">1200</span>],rt,idx,ans[<span class="number">1200</span>];</span><br><span class="line"><span class="keyword">int</span> cut,vis[<span class="number">1200</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++idx;</span><br><span class="line">	<span class="keyword">int</span> son=<span class="number">0</span>,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">		v=go[p];</span><br><span class="line">		<span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;</span><br><span class="line">			tarjan(v); son++;</span><br><span class="line">			low[u]=min(low[u],low[v]);</span><br><span class="line">			<span class="keyword">if</span>((u==rt&amp;&amp;son&gt;<span class="number">1</span>)||(u!=rt&amp;&amp;low[v]&gt;=dfn[u])) ans[u]=<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> low[u]=min(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//DFS找相连子网络 </span></span><br><span class="line">	<span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])</span><br><span class="line">		<span class="keyword">if</span>(go[p]!=cut)</span><br><span class="line">			dfs(go[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> a,b,k=<span class="number">0</span>,cnt;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a))&#123;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">		<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">		<span class="built_in">memset</span>(exist,<span class="number">0</span>,<span class="keyword">sizeof</span>(exist));</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">		arcnum=<span class="number">1</span>; idx=<span class="number">0</span>; cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b);</span><br><span class="line">			exist[a]=exist[b]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;<span class="comment">//忽略自环 </span></span><br><span class="line">			addarc(a,b);</span><br><span class="line">			addarc(b,a);</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a)&amp;&amp;a!=<span class="number">0</span>);</span><br><span class="line">		rt=b;</span><br><span class="line">		tarjan(rt);</span><br><span class="line">		<span class="keyword">if</span>(k&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network #%d\n"</span>,k);</span><br><span class="line">		<span class="keyword">for</span>(cut=<span class="number">1</span>;cut&lt;=<span class="number">1000</span>;cut++)</span><br><span class="line">			<span class="keyword">if</span>(exist[cut]&amp;&amp;ans[cut])&#123;</span><br><span class="line">				<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">					<span class="keyword">if</span>(exist[i]&amp;&amp;!vis[i]&amp;&amp;!ans[i])<span class="comment">//一定不能遍历割点本身 </span></span><br><span class="line">						dfs(i),sum++;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"  SPF node %d leaves %d subnets\n"</span>,cut,sum);</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"  No SPF nodes\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p><strong>POJ3177</strong> </p>
<p><strong>描述</strong> 为了从F（1≤F≤5000）个牧场（从1到F进行编号）中的一个到达另一个牧场，Bessie和他的牛只能穿过烂苹果林。这些牛现在都累了，不想老走这个特殊的小路而是想要建一些新的小路，这样它们就有至少两种选择在任意牧场之间穿梭。在任意的两个牧场之间，它们现在至少有一条路径而他们想要至少有2条路径。 现在给出建好的R（F-1≤R≤10000）条路，每条都连接了两个不同的牧场，确定新修道路的最小数量（每个也是连接两个牧场）使得任意两个牧场之间都能有两条路连通。道路都是不同的，不会有相同的小路，即使他们在沿路的中间会碰到相同的牧场。 这里可能已经有一对牧场有超过一条小路的，并且你可能也会修一条新的另外的小路来连接相同的牧场。 </p>
<p><strong>输入</strong> 第一行：两个空格隔开的整数：F和R 第二到第R+1行：每行包括两个空格隔开的整数，表示一些小路端点所在的牧场。 </p>
<p><strong>输出</strong> 第一行：一个单独的整数，表述新修小道的数量 </p>
<p><strong>样例输入</strong> 7 7 1 2 2 3 3 4 2 5 4 5 5 6 5 7 </p>
<p><strong>样例输出</strong> 2 </p>
<p><strong>提示</strong> 例子的解释： 一个形象化的小路： 1  2   3 +—+—+ |  | |  | 6 +—+—+ 4 / 5 / / 7 + 建一个从1到6和从4到7的新路可以满足条件。</p>
<pre><code>  1   2   3

  +---+---+  

  :   |   |

  :   |   |

6 +---+---+ 4

     / 5  :

    /     :

   /      :

7 + - - - - </code></pre><p>检查一些路径： 1 – 2: 1 –&gt; 2 and 1 –&gt; 6 –&gt; 5 –&gt; 2 1 – 4: 1 –&gt; 2 –&gt; 3 –&gt; 4 and 1 –&gt; 6 –&gt; 5 –&gt; 4 3 – 7: 3 –&gt; 4 –&gt; 7 and 3 –&gt; 2 –&gt; 5 –&gt; 7 可以看出每对牧场都是由两条路连接的 有可能加一些别的下路也能解决这个问题（比如6到7加一条道）。然而加两条已经是最小了。 </p>
<p><strong>POJ3352</strong> <strong>描述：</strong> 夏天的建造时间到了。这一年，遥远热带小岛上的街道的管理员要修复并且升级岛上街道，这些街道连接了小岛上不同的景点。 这些街道很有意思。由于这个小岛的奇怪传统，这些街道需要被规划的没有任何十字路口，但是可以用桥和隧道来连通。在这种情况下，每条路就会在特定的景点之间连接，这样旅客就不会迷路了。 不幸的是，每条路都需要修理和升级，当建筑公司在一条特定的道路上工作时，这条道路是无法使用的。这就会导致一个问题，即使这个公司一次只修一条路，仍然有两个景点是无法访问的，。 所以，这个岛上的道路部门就决定召唤你的咨询服务来帮助他们解决这个问题。最后决定在景点之间建设新的道路。如果一条道路在建设中，这些新的道路能使任意两个景点之间仍然有路能够到达。你的任务就是找到这个新修道路的最小数量。</p>
<p> <strong>输入</strong> 第一行的输入包括两个正整数n和r，其中3≤n≤1000是景点的数量，2≤r≤1000是道路的数量。景点则是从1到n进行标号。每个接下来的r行会包括两个整数，v和w，中间空格隔开，表示一个街道连接了标号为v和w的景点。注意街道是双向的，并且任意一对景点之间会有至多一条路直接连接它们。当然，你也要保证在现在的这个配置下，任意两个景点是连通的。</p>
<p> <strong>输出</strong> 一行，包括一个整数，给出我们需要添加的街道的最小数量</p>
<p> <strong>输入样例</strong> Sample Input 1 10 12 1 2 1 3 1 4 2 5 2 6 5 6 3 7 3 8 7 8 4 9 4 10 9 10 Sample Input 2 3 3 1 2 2 3 1 3 </p>
<p><strong>输出样例</strong> Output for Sample Input 1 2 Output for Sample Input 2 0  </p>
<p><strong>两道题完全相同，都是求有桥连通图变为双连通图所需要最少的边的个数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5000</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">10000</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAXN],go[MAXM],nxt[MAXM],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> low[MAXN],dfn[MAXN],dex,cnt[MAXN],<span class="built_in">map</span>[MAXN][MAXN],sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++dex;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">		<span class="keyword">int</span> v=go[p];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			tarjan(v,u);</span><br><span class="line">			low[u]=min(low[u],low[v]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v!=father) low[u]=min(low[u],dfn[v]);<span class="comment">//如果引出v，而v是u的父亲，那么就不能更新low[u] </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,a,b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			<span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[min(a,b)][max(a,b)]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">map</span>[min(a,b)][max(a,b)]=<span class="number">1</span>;</span><br><span class="line">			addarc(a,b);</span><br><span class="line">			addarc(b,a);</span><br><span class="line">		&#125;</span><br><span class="line">		tarjan(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">				<span class="keyword">int</span> v=go[p];</span><br><span class="line">				<span class="keyword">if</span>(low[u]!=low[v])</span><br><span class="line">					cnt[low[u]]++;<span class="comment">//计算度数 </span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(cnt[i]==<span class="number">1</span>)</span><br><span class="line">				sum++;<span class="comment">//统计度为1的点的个数 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,(sum+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        
​        </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/874d0da0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/874d0da0/" class="post-title-link" itemprop="url">Tarjan算法求强连通分量总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:42:41" itemprop="dateCreated datePublished" datetime="2018-12-06T23:42:41+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:39:32" itemprop="dateModified" datetime="2019-05-05T13:39:32+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> Tarjan算法求强连通分量总结</p>
<p> <strong>首先明确强连通分量的概念：如果图中的任意两个点都能互相到达，则为强连通分量。极大强连通分量：不被其它任何强连通分量包含的强连通分量。</strong> <strong>强连通分量主要与两种边有关：交叉边和后向边。</strong> <strong>交叉边是两个无关系的点之间所构成的，而后向边是根节点的子节点指向根结点的一种边</strong> <strong>Tarjan算法原理：</strong></p>
<ol>
<li><p><strong>建立low数组（用于记录该点所在的连通子图的根节点的搜索子树所遍历的时间）与dfn数组（记录当前点遍历的时间）Index：记录搜索过程所进行的时间</strong></p>
</li>
<li><p><strong>初始化dfn、index，当前点u的初始值为时间</strong></p>
</li>
<li><p><strong>u入栈并标记</strong></p>
</li>
<li><p><strong>遍历与u相连的所有点（记为v）</strong></p>
</li>
<li><p><strong>如果v未被遍历，递归遍历v点，然后更新low[u]     low[u]=min(low[u],low[v]);</strong></p>
</li>
<li><p><strong>如果 v已经被遍历且在栈中直接更新low[u]</strong> <strong>low[u]=min(low[u],dfn[v]);</strong></p>
</li>
<li><p><strong>判断low[u]==low[v]如果成立，将包括u在内的所有点出栈并记录，则求得强连通分量之一</strong></p>
</li>
<li><p><strong>继续遍历，直至结束</strong></p>
</li>
<li><p><strong>注意：在一个图中，起点不唯一，所以tarjan算法应该遍历所有未被遍历的点(vis[i]==0)</strong></p>
<p><strong>本算法主要应用范围是对复杂的有向图的缩点优化。如果某些点构成一个环，完全可以把它们看作一个点，加快程序运行效率</strong>  <strong>Question:如果是有向有权图使用缩点时应该怎么处理权值的问题？</strong>   </p>
</li>
</ol>
<p><strong>FZOJ1638求强连通分量</strong> </p>
<p><strong>描述</strong> 输入一个图，输出该图中的最大强连通分量。 </p>
<p><strong>输入</strong> 第一行：n和m（n&lt;=10000,m&lt;=100000,n为节点个数，m为边的条数） 接下来m行，每行两个数：a，b，表示a指向b的边（a,b为非负整数）；</p>
<p> <strong>输出</strong> 输出最大强连通分量的节点，按照节点编号从小到大输出，如果有多个强连通分量节点数相同，则输出节点编号字典序较小的。</p>
<p> <strong>样例输入</strong> 6 8 1 3 3 5 5 6 1 2 4 1 2 4 4 6 3 4 </p>
<p><strong>样例输出</strong> 1 2 3 4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> first[<span class="number">10020</span>],nxt[<span class="number">100200</span>],go[<span class="number">100200</span>],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">10020</span>],low[<span class="number">10020</span>],<span class="built_in">stack</span>[<span class="number">100200</span>],top,dex,vis[<span class="number">10020</span>];</span><br><span class="line"><span class="keyword">int</span> rt,ans[<span class="number">10020</span>],temp[<span class="number">10020</span>],sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    nxt[arcnum]=first[a];</span><br><span class="line">    first[a]=arcnum;</span><br><span class="line">    go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dex;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=u; vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=go[p];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>)</span><br><span class="line">            low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v; sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            v=<span class="built_in">stack</span>[top--];</span><br><span class="line">            vis[v]=<span class="number">2</span>;</span><br><span class="line">            temp[++sum]=v;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">        <span class="keyword">if</span>(rt&lt;sum)&#123;</span><br><span class="line">        	rt=sum;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">        		ans[i]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        addarc(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    	<span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">    		top=<span class="number">0</span>;dex=<span class="number">0</span>;</span><br><span class="line">    		<span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    		<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">    		<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">    		tarjan(i);</span><br><span class="line">    	&#125;</span><br><span class="line">    		</span><br><span class="line">    sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=rt;i++)</span><br><span class="line"> 	    <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p>**Poj2186Popular Cows</p>
<p> <strong>Description</strong> </p>
<p>Every cow’s dream is to become the mostpopular cow in the herd. In a herd of N (1 &lt;= N &lt;= 10,000) cows, you aregiven up to M (1 &lt;= M &lt;= 50,000) ordered pairs of the form (A, B) thattell you that cow A thinks that cow B is popular. Since popularity is transitive,if A thinks B is popular and B thinks C is popular, then A will also think thatC is popular, even if this is not explicitlyspecified by an ordered pair in the input. Your task is to compute the numberof cows that are considered popular by every other cow.</p>
<p> <strong>Input</strong> * Line 1: Two space-separated integers, Nand M * Lines 2..1+M: Two space-separated numbersA and B, meaning that A thinks B is popular. Output </p>
<p><strong>output</strong> * Line 1: A single integer that is thenumber of cows who are considered popular by every other cow. </p>
<p><strong>Sample Input</strong> 3 3 1 2 2 1 2 3</p>
<p> <strong>Sample Output</strong> 1</p>
<p> <strong>Hint</strong> Cow 3 is the only cow of high popularity. </p>
<p><strong>题目大意</strong> N头奶牛(N≤10000) M对关系（a , b），表示a认为b是受欢迎的 关系具有传递性，即若(a,b),(b,c)→(a,c) 询问有多少头奶牛是被其他所有奶牛认为是受欢迎的</p>
<p> <strong>这道题据说不使用强连通算法优化也能做出来，就是说tarjan算法只是进行优化。</strong> <strong>进过分析可以发现，在有向无环图DAG图中，要想一头（群）牛被其它所有牛欢迎，必须满足只有它自己的出度为0，其它的牛所构成的圈子（环）的出度必须大于零才可以</strong> <strong>这样就得到了解决方法，用tarjan算法算出所有的强连通分量并将它们合并成一个点，再做一次搜索，如果这个环对外的出度为0则其中所有牛对其他牛的出度都为0</strong> <strong>如果一个DAG图有两个以上出度为0得点，那么总有一个点无法到达其它任意一个点</strong> <strong>遍历所有环与点，如果出度为0的只有一个则输出答案，否则答案为0</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10000</span>+<span class="number">200</span>,MAXM=<span class="number">50000</span>+<span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAXN],nxt[MAXM],go[MAXM],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],low[MAXN],<span class="built_in">stack</span>[MAXM],top;</span><br><span class="line"><span class="keyword">int</span> scc[MAXN],idx,cscc,vis[MAXN];<span class="comment">//记录强连通分量 </span></span><br><span class="line"><span class="keyword">int</span> cd[MAXN],cd_scc[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">	cd[a]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++idx;</span><br><span class="line">	<span class="built_in">stack</span>[++top]=u; vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">		<span class="keyword">int</span> v=go[p];</span><br><span class="line">		<span class="keyword">if</span>(vis[v]==<span class="number">0</span>)&#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u]=min(low[u],low[v]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>)</span><br><span class="line">			low[u]=min(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		cscc++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			v=<span class="built_in">stack</span>[top--];</span><br><span class="line">			vis[v]=<span class="number">2</span>;</span><br><span class="line">			scc[v]=cscc; </span><br><span class="line">		&#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m,a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">		addarc(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">			tarjan(i);</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">if</span>(idx&lt;n)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			<span class="keyword">int</span> v=go[p];</span><br><span class="line">			<span class="keyword">if</span>(scc[u]!=scc[v])</span><br><span class="line">				cd_scc[scc[u]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> c1=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cscc;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cd_scc[i]==<span class="number">0</span>&amp;&amp;c1==<span class="number">0</span>)</span><br><span class="line">			c1=i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c1!=<span class="number">0</span>&amp;&amp;cd_scc[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(scc[i]==c1)</span><br><span class="line">			ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/28cf1e0f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/28cf1e0f/" class="post-title-link" itemprop="url">拓扑排序以及关键路径总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:42:05" itemprop="dateCreated datePublished" datetime="2018-12-06T23:42:05+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:18:07" itemprop="dateModified" datetime="2019-05-05T13:18:07+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  拓扑排序以及关键路径的总结 </p>
<p><strong>拓扑排序：首先纠正一个读音问题：拓扑(tuopu)话说我好几次都读成(tabu) (tuobu)好吗！</strong>     </p>
<p>​    拓扑排序是针对AOV图（即有向无边图，且图中不允许环的存在）的一种排序算法，它用于将一个AOV图按照顺序排成线性序列</p>
<p>​    基本操作如下：</p>
<p><strong>1.记录每个节点的入度</strong> </p>
<p><strong>2.每次找到入度为零的点入栈，并将与之相连的节点入度减一</strong> </p>
<p><strong>3.重复2的动作，直到栈为空</strong> </p>
<p><strong>4.判断当前操作进行的次数，少于n次则有环，否则输出拓扑序列</strong> </p>
<p>家谱树 </p>
<p>【问题描述】 有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。 给出每个人的孩子的信息。 输出一个序列，使得每个人的后辈都比那个人后列出。 </p>
<p>【输入格式】 第1行一个整数N（1&lt;=N&lt;=100），表示家族的人数。 接下来N行，第I行描述第I个人的儿子。 每行最后是0表示描述完毕。 </p>
<p>【输出格式】 输出一个序列，使得每个人的后辈都比那个人后列出。 如果有多解输出任意一解。 【输入样例】 5 0 4 5 1 0 1 0 5 3 0 3 0 </p>
<p>【输出样例】 2 4 5 3 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],nxt[MAX],go[MAX],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rd[MAX],<span class="built_in">stack</span>[MAX],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m)!=EOF &amp;&amp;m!=<span class="number">0</span>)</span><br><span class="line">			addarc(i,m),rd[m]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> now=<span class="built_in">stack</span>[top--];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,now);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[now];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			rd[go[p]]--;</span><br><span class="line">			<span class="keyword">if</span>(rd[go[p]]==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">stack</span>[++top]=go[p];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>​        
​        return 0;<br>​    }</p>
<p><strong>该题是明显的拓扑排序题，按照标准格式写程序即可</strong> </p>
<p> <strong>奖金</strong> （<a href="http://fzoj.xndxfz.com/JudgeOnline/problem.php?id=1624）" target="_blank" rel="noopener">http://fzoj.xndxfz.com/JudgeOnline/problem.php?id=1624）</a> </p>
<p><strong>描述</strong> 由于无敌的凡凡在2005年世界英俊帅气男总决选中胜出，Yali Company总经理Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。</p>
<p> <strong>输入</strong> 第一行两个整数n,m，表示员工总数和代表数；以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。 输出 若无法找到合理方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。</p>
<p> <strong>样例输入</strong> 2 1 1 2 </p>
<p><strong>样例输出</strong> 201 </p>
<p><strong>提示</strong> 80％的数据满足n&lt;=1000，m&lt;=2000；100％的数据满足n&lt;=10000，m&lt;=20000。 </p>
<p><strong>此题比上一题多加入了点的权值</strong> <strong>也就是计算拓扑序列中权值和最小是多少</strong> <strong>标准做法：使用拓扑排序，在去掉某个点后，遍历它的相连节点时，计算该点的权值，是在(val[v],val[u]+1),其中u为起点，v为中点，中取最大值，开始我的理解出现的偏差，不能在那个点入度为0的时候才计算那个点的权值，因为那个点要满足的条件是比它之前的所有点权值都要小</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">300000</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],nxt[MAX],go[MAX],arcnum=<span class="number">1</span>,rd[MAX];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAX],val[MAX],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m,a,b,k=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">		addarc(b,a);<span class="comment">//b比a工资低 </span></span><br><span class="line">		rd[a]++;<span class="comment">//入度+1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>)<span class="comment">//将入度为0的点入栈 </span></span><br><span class="line">			<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	<span class="keyword">while</span>(top!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> now=<span class="built_in">stack</span>[top--];<span class="comment">//当前点 </span></span><br><span class="line">		k++; tot+=<span class="number">100</span>+val[now]; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[now];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			val[go[p]]=max(val[go[p]],val[now]+<span class="number">1</span>);<span class="comment">//不应当在入度为0时才更新val[]，而应当每次都更新，取最大值 </span></span><br><span class="line">			<span class="keyword">if</span>(--rd[go[p]]==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">stack</span>[++top]=go[p];</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(k==n) <span class="built_in">printf</span>(<span class="string">"%d"</span>,tot);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Poor Xed"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​    </p>
<p><strong>fzoj1621:烦人的幻灯片</strong> </p>
<p><strong>题目描述</strong> </p>
<p>李教授于今天下午做一个非常重要的演讲。不幸的是他不是一个非常爱整洁的人，他把自己做演讲要用的幻灯片随便堆放在一起。因此，演讲之前他不得不去整理这些幻灯片。做为一个讲求效率的学者，他希望尽可能简单地完成它。情况是这样，教授这次演讲一共要用n张幻灯片（n&lt;=26），这n张幻灯片按照演讲要使用的顺序已经用数字1，2，…，n在上面编上了号。因为幻灯片是透明的，所以我们不能一下子看清每一个数字所对应的幻灯片。 现在我们用大写字母A，B，C，。。。再次把幻灯片依次编号。你的任务是编写一个程序，把幻灯片的数字编号和字母编号对应起来，显然这种对应应该是唯一的；若出现多种对应的情况或是某些数字编号和字母对应不起来，我们就称对应是无法实现的。 </p>
<p><strong>输入</strong> 第一行：只有一个数n，表示有n张幻灯片。 接下来的n行：包括4个整数Xmin，Xmax，Ymin，Ymax（整数之间用空格分开），为幻灯片的坐标（该区域为幻灯片），这n张幻灯片按其在输入文件中出现的顺序从前到后依次编号为A，B，C，…再接下来的n行依次为n个数字编号的坐标X，Y，显然在幻灯片之外是不会有数字的。 </p>
<p><strong>输出</strong> 若是对应可以实现，你的输出应该包括n行，每一行为一个字母和一个数字，中间以一个空格隔开，并且各行以字母的升序排列，注意输出的字母要大写并且顶格；反之，若是对应无法实现，在第一行顶格输出None即可。行首行末无多余空格。 </p>
<p><strong>样例输入</strong> 4 6 22 10 20 4 18 6 16 8 20 2 18 10 24 4 8 9 15 19 17 11 7 21 11</p>
<p> <strong>样例输出</strong> A 4 B 1 C 2 D 3 </p>
<p><strong>这道题并不完全是拓扑排序题，但却用到了拓扑排序的思想</strong> </p>
<p><strong>读懂题意是关键，本题意思是每个数字都对应了一个或多个幻灯片，然后要求从中找出数字与幻灯片的一一对应关系</strong> <strong>节点个数很少，直接用邻接矩阵存储</strong> <strong>由于是数字对应幻灯片，所以我选择存储每个数字的出度，当某个数字出度为1时，寻找它所对应的幻灯片，记录，并且将与该幻灯片连接的其余数字全部断绝联系，出度也减1</strong> <strong>这样，n次之后就可以得到完整的一一对应关系</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> X1[MAX],X2[MAX],Y1[MAX],Y2[MAX],<span class="built_in">map</span>[MAX][MAX],cd[MAX],ans[MAX];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAX],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInside</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span>&#123;<span class="comment">//第t张输入的幻灯片</span></span><br><span class="line">	<span class="keyword">return</span> x&gt;X1[t]&amp;&amp;x&lt;X2[t]&amp;&amp;y&gt;Y1[t]&amp;&amp;y&lt;Y2[t];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,x,y,k=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;X1[i],&amp;X2[i],&amp;Y1[i],&amp;Y2[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(IsInside(x,y,j))</span><br><span class="line">				<span class="built_in">map</span>[i][j]=<span class="number">1</span>,cd[i]++;<span class="comment">//第i个数字在j-'A'+1的幻灯片中 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(cd[i]==<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u=<span class="built_in">stack</span>[top--];</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)	</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[u][v]==<span class="number">1</span>)&#123;<span class="comment">//如果u到v有路径 则u属于v </span></span><br><span class="line">				ans[v]=u;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>[i][v]==<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">map</span>[i][v]=<span class="number">0</span>; cd[i]--;</span><br><span class="line">					<span class="keyword">if</span>(cd[i]==<span class="number">1</span>)</span><br><span class="line">						<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(k!=n) <span class="built_in">printf</span>(<span class="string">"None"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,<span class="string">'A'</span>+i<span class="number">-1</span>,ans[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>关键路径：</strong> <strong>建立在一种新图上：AOV图（用点表示时间，边表示活动，边的权值表示活动持续的时间的一种图）</strong> <strong>四个重要的量</strong></p>
<ol>
<li><strong>事件最早发生时间ve[]</strong></li>
<li><strong>事件最晚发生时间vl[]</strong></li>
<li><strong>活动最早开始时间e[]</strong></li>
<li><strong>活动最晚开始时间l[]</strong></li>
</ol>
<p><strong>各个量的求法及求解顺序：</strong></p>
<ol>
<li><strong>Ve，以Ve[1]=0开始，所有起点u终点v都按照ve[v]=max(ve[v],ve[u]+dis[u][v])的方法进行计算，并且记录下拓扑序列</strong></li>
<li><strong>Vl，顺序：逆拓扑序列，以Vl[n]=Ve[n]开始，（因为终点是关键事件，所以最早和最晚开始时间相等）起点u终点v都按照vl[v]=min(vl[v],vl[u]-dis[u][v])的方法求解（此处注意，程序开头必须memset）</strong></li>
<li><strong>e，事件的最早发生时间就等于活动的最早开始时间</strong></li>
<li><strong>l，对于起点x终点y之间的活动i，l[i]=vl[y]-dis[x][y]</strong></li>
</ol>
<p><strong>如果e[i]==l[i]则说它是关键活动</strong> <strong>结束。</strong>  <strong>Question：活动的最早最晚开始时间和事件的最早最晚发生时间有什么关系，它们各自属于实际问题中的那一个量？（我只会求，但并不能完全明白它们的差别或者用途）</strong> <strong>前面奖金一题所用的方法是不是关键路径中的求事件最早发生时间？</strong> </p>
<h2 id="关键路径计算"><a href="#关键路径计算" class="headerlink" title="关键路径计算"></a>关键路径计算</h2><p>（<a href="http://fz.openjudge.cn/graph/015/）" target="_blank" rel="noopener">http://fz.openjudge.cn/graph/015/）</a> <strong>描述</strong> 给出一个AOE图，请输出其关键路径； <strong>输入</strong> 第一行：n，m（n,m&lt;=100分别表示节点个数与边的条数） 接下来m行，第i+1行，表示第i条边，每行三个数：ai,bi,ci，表示存在一条ai指向bi权值为ci的边。 注意：起点为结点1，终点为结点n <strong>输出</strong> 将关键路径的边的编号从小到大输出 <strong>样例输入</strong> 9 11 1 2 6 1 3 4 1 4 5 2 5 1 3 5 1 4 6 2 5 7 9 5 8 7 6 8 4 7 9 2 8 9 4 <strong>样例输出</strong> 1 4 7 8 10 11 <strong>标准问题，注意在输出之前要排序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],go[MAX],nxt[MAX],dis[MAX][MAX],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAX],top,ve[MAX],vl[MAX],e[MAX],l[MAX],rd[MAX];</span><br><span class="line"><span class="keyword">int</span> order[MAX],ans[MAX],sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">	dis[a][b]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m,a,b,c,k=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(vl,<span class="number">127</span>,<span class="keyword">sizeof</span>(vl));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		addarc(a,b,c);</span><br><span class="line">		rd[b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">stack</span>[++top]=i;<span class="comment">//入栈 </span></span><br><span class="line">	<span class="keyword">do</span>&#123;<span class="comment">//第一次，求事件最早发生时间 </span></span><br><span class="line">		<span class="keyword">int</span> u=<span class="built_in">stack</span>[top--],v; k++;</span><br><span class="line">		order[k]=u;<span class="comment">//记录顺序 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p]; rd[v]--;</span><br><span class="line">			ve[v]=max(ve[v],ve[u]+dis[u][v]);</span><br><span class="line">			<span class="keyword">if</span>(rd[v]==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">stack</span>[++top]=v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	vl[n]=ve[n];<span class="comment">//中点的事件最晚发生时间等于最早发生时间 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> u=order[i],v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p];</span><br><span class="line">			vl[u]=min(vl[u],vl[v]-dis[u][v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;<span class="comment">//计算活动的最早发生时间和最晚发生时间 </span></span><br><span class="line">		<span class="keyword">int</span> u=order[i],v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p];</span><br><span class="line">			e[p]=ve[u];<span class="comment">//活动最早发生时间等于起始点的最早发生时间 </span></span><br><span class="line">			l[p]=vl[v]-dis[u][v];<span class="comment">//活动最晚发生时间等于终点最晚发生时间减去活动的长度 </span></span><br><span class="line">			<span class="keyword">if</span>(e[p]==l[p]) ans[++sum]=p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+sum);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HDU4109-Instrction-Arrangement"><a href="#HDU4109-Instrction-Arrangement" class="headerlink" title="HDU4109 Instrction Arrangement"></a>HDU4109 Instrction Arrangement</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4109" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4109</a> </p>
<p><strong>Problem Description</strong> 阿狸这个学期学了计算机组织结构课程。他知道了指令之间可能有依存关系，像WAR（write after read，读之后写），WAW，RAW。如果两个指令之间的时间小于安全时间，它就会导致危险，从而引起错误的结果。所以我们需要设计特殊的回路去消除危险。然而，解决这个问题最简单的方法是添加等待时间（或者由其它的操作填充），如果没有其它的操作填充就意味着需要浪费时间去保证两个指令之间的时间不小于安全时间。 两个指令之间的时间的定义就是它们起始时间差。 现在我们有很多指令，并且我们知道依存关系和指令之间的安全事件。我们也有非常强大的无限核的CPU。所以你可以在同一时间想跑多少指令就跑多少指令。这个CPU可以只消耗1ns就完成任何指令。 你的工作就是重新安排这些指令顺序所以CPU就可以用最短时间完成所有的指令。</p>
<p> <strong>Input</strong> 输入包括几个测试案例 头两行有两个整数N,M（N&lt;=1000,M&lt;=1000），其中N表示N条指令和M表示M个依存关系 接下来的M行，每行包括3个整数X,Y,Z，意思是X和Y之间的安全时间是Z，而且Y必须在X之后运行。这些指令从0到N-1标号。</p>
<p> <strong>Output</strong> 打印一个整数，CPU运行的最短时间</p>
<p> <strong>Sample Input</strong> 5 2 1 2 1 3 4 1 </p>
<p><strong>Sample Output</strong> 2 </p>
<p><strong>HINT</strong> 在第1ns中，指令0，1和3被执行了。 在第2ns中，指令2,和4被执行了 所以答案是2</p>
<p> <strong>也是求事件最早发生时间（这些指令什么时候最早全部执行完）的题</strong> </p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>memset！！！！！！！</strong></li>
<li><strong>指令由0到n-1编号，注意转换</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],nxt[<span class="number">10200</span>],go[<span class="number">10200</span>],arcnum;</span><br><span class="line"><span class="keyword">int</span> dis[MAX][MAX],rd[MAX],val[MAX],<span class="built_in">stack</span>[<span class="number">10200</span>],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">	dis[a][b]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m,x,y,z,maxx;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">		<span class="built_in">memset</span>(rd,<span class="number">0</span>,<span class="keyword">sizeof</span>(rd));</span><br><span class="line">		<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span>(val));</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		maxx=<span class="number">-1</span>; arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			val[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			addarc(++x,++y,z);</span><br><span class="line">			rd[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)	</span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u=<span class="built_in">stack</span>[top--],v;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">				v=go[p];</span><br><span class="line">				val[v]=max(val[v],val[u]+dis[u][v]);</span><br><span class="line">				maxx=max(val[v],maxx);</span><br><span class="line">				<span class="keyword">if</span>(--rd[v]==<span class="number">0</span>)</span><br><span class="line">					<span class="built_in">stack</span>[++top]=v;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>Poj3687 Labeling Balls</strong> <strong>escription</strong> Windy有N个不同重量的求，现在他打算给他们贴上1到N的标签： 没有两个相同的球 这些标签要符合规则例如“标签a球轻于标签b球” 你能帮他解决这个问题吗？ <strong>Input</strong> 第一行是数据个数.每组数据第一行是两个整数： N (1 ≤ N ≤ 200)和 M (0 ≤ M ≤ 40,000).接下来M行，每行两个整数a和 b表示 标签a球轻于标签b球. (1 ≤ a, b ≤ N) 每组数据后有一个空行</p>
<p> <strong>Output</strong> 每组测试数据输出一行，按照小球的1~N，小球的重量输出，如果有多组解： you should output the one with the smallest weight for label 1, then with the smallest weight for label 2, then with the smallest weight for label 3 and so on…如果无解，输出-1。 </p>
<p><strong>Sample Input</strong> 5 4 0 4 1 1 1 4 2 1 2 2 1 4 1 2 1 4 1 3 2 </p>
<p><strong>Sample Output</strong> 1 2 3 4 -1 -1 2 1 3 4 1 3 2 4 </p>
<p><strong>这道题至今未通过。初步思路是建立小顶堆和拓扑排序，以便在几个球重量相等时输出编号最小的。</strong> <strong>但是问题来了，在我操作入度为0的节点时，可能会又有新的节点加入堆，从而导致我整个答案完全不对。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> first[<span class="number">300</span>],nxt[<span class="number">40200</span>],go[<span class="number">40200</span>],arcnum;</span><br><span class="line"><span class="keyword">int</span> rd[<span class="number">300</span>],<span class="built_in">stack</span>[<span class="number">40200</span>],ans[<span class="number">300</span>],heap[<span class="number">10000</span>],len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=heap[<span class="number">1</span>],now=<span class="number">1</span>,next;</span><br><span class="line">	heap[<span class="number">1</span>]=heap[len--];</span><br><span class="line">	<span class="keyword">while</span>(now*<span class="number">2</span>&lt;=len)&#123;</span><br><span class="line">		next=now*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(next&lt;len&amp;&amp;cmp(heap[next+<span class="number">1</span>],heap[next])) next++;</span><br><span class="line">		<span class="keyword">if</span>(cmp(heap[now],heap[next])) <span class="keyword">break</span>;</span><br><span class="line">		swap(heap[now],heap[next]);</span><br><span class="line">		now=next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=++len,next;</span><br><span class="line">	heap[len]=p;</span><br><span class="line">	<span class="keyword">while</span>(now&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		next=now&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!cmp(heap[now],heap[next])) <span class="keyword">break</span>;</span><br><span class="line">		swap(heap[now],heap[next]);	</span><br><span class="line">		now=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,n,m,a,b,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		arcnum=<span class="number">1</span>; k=<span class="number">0</span>; len=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(rd,<span class="number">0</span>,<span class="keyword">sizeof</span>(rd));</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			addarc(a,b);</span><br><span class="line">			rd[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>)</span><br><span class="line">				Put(i);</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u=Get(),v;</span><br><span class="line">			ans[u]=++k;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">				v=go[p];</span><br><span class="line">				<span class="keyword">if</span>(--rd[v]==<span class="number">0</span>)</span><br><span class="line">					Put(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(len&gt;<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(k!=n) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>又想到把拓扑排序后的点记录下来，来个快排，但是有的球没有限制条件，强行把权设为0又会错。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> first[<span class="number">300</span>],nxt[<span class="number">40200</span>],go[<span class="number">40200</span>],arcnum;</span><br><span class="line"><span class="keyword">int</span> rd[<span class="number">300</span>],<span class="built_in">stack</span>[<span class="number">40200</span>],top;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val,id;</span><br><span class="line">&#125;ans[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	nxt[arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum++]=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.val!=b.val)</span><br><span class="line">		<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,n,m,a,b,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		arcnum=<span class="number">1</span>; k=<span class="number">0</span>; top=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(rd,<span class="number">0</span>,<span class="keyword">sizeof</span>(rd));</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			ans[i].id=i,ans[i].val=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			addarc(a,b);</span><br><span class="line">			rd[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u=<span class="built_in">stack</span>[top--],v;</span><br><span class="line">			k++;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">				v=go[p];</span><br><span class="line">				ans[v].val=max(ans[v].val,ans[u].val+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(--rd[v]==<span class="number">0</span>)</span><br><span class="line">					<span class="built_in">stack</span>[++top]=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(top!=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(k!=n) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+n,cmp);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i].id);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>据说建立大顶堆就可以解决问题？？？？</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/f8a544ad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/f8a544ad/" class="post-title-link" itemprop="url">最小生成树总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:41:33" itemprop="dateCreated datePublished" datetime="2018-12-06T23:41:33+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:17:25" itemprop="dateModified" datetime="2019-05-05T13:17:25+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  啊，先纪念一下吧，难得一天这么666 AC完了所有题 （次小生成树代码看懂） 今天学到了最小生成树算法中的Prim算法和Kruskal算法。从宏观上来讲prim更适合稠密图，krustal更适合稀疏图，但对于我们来说暂时没有什么区别啦。 Prim算法中主要注意的点是</p>
<ol>
<li><strong>在visit数组与minn数组（最小到达某点的权边的权值）上 注意只有未遍历而且小于当前所存的权才可以更新</strong></li>
<li><strong>循环次数为n-1次，错误的次数会导致答案错误</strong></li>
<li><strong>除自身为0以外，所有点之间的初始距离为正无穷</strong> </li>
</ol>
<p><strong>Kruskal算法中主要注意的点是</strong></p>
<ol>
<li><strong>所有的边要用结构体存，方便快排</strong></li>
<li><strong>注意并查集的Getfather函数的压缩路径和union函数的是否父亲相同的判断</strong></li>
<li><strong>注意变量k的维护，k满足k==n-1时必须及时跳出循环</strong></li>
</ol>
<p>还有一个很容易忽略的问题！！就是memset，特别是有多组数据的时候必须在前面重置内存** 附上我对次小生成树代码的注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 次小生成树</span></span><br><span class="line"><span class="comment"> * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权</span></span><br><span class="line"><span class="comment"> * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案</span></span><br><span class="line"><span class="comment"> * 点的编号从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//最大值 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//点是否已使用 </span></span><br><span class="line"><span class="keyword">int</span> lowc[MAXN];<span class="comment">//到每一个点权值最短的路径的权值 </span></span><br><span class="line"><span class="keyword">int</span> pre[MAXN];<span class="comment">//存父亲 </span></span><br><span class="line"><span class="keyword">int</span> Max[MAXN][MAXN];<span class="comment">//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN][MAXN];<span class="comment">//边是否已使用 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> cost[][MAXN],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(Max,<span class="number">0</span>,<span class="keyword">sizeof</span>(Max));</span><br><span class="line">    <span class="built_in">memset</span>(used,<span class="literal">false</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">    vis[<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//已遍历 </span></span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">-1</span>;<span class="comment">//起始点没有父亲 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        lowc[i]=cost[<span class="number">0</span>][i];</span><br><span class="line">        pre[i]=<span class="number">0</span>;<span class="comment">//设置父亲 </span></span><br><span class="line">    &#125;</span><br><span class="line">    lowc[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minc=INF;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">-1</span>;<span class="comment">//将要选择的下一个点 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;minc&gt;lowc[j])&#123;</span><br><span class="line">                minc=lowc[j];<span class="comment">//选择距离最小的边 </span></span><br><span class="line">                p=j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(minc==INF) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//该图不是连通图 </span></span><br><span class="line">        ans+=minc;<span class="comment">//权值和计算 </span></span><br><span class="line">        vis[p]=<span class="literal">true</span>;<span class="comment">//点已遍历 </span></span><br><span class="line">        used[p][pre[p]]=used[pre[p]][p]=<span class="literal">true</span>;<span class="comment">//边已遍历 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]) Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);<span class="comment">//DP计算j到p的路径中权值最大的边的权值 </span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j])&#123;<span class="comment">//更新lowc数组 </span></span><br><span class="line">                lowc[j]=cost[p][j];</span><br><span class="line">                pre[j]=p;<span class="comment">//设置父亲 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smst</span><span class="params">(<span class="keyword">int</span> cost[][MAXN],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Min=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(cost[i][j]!=INF &amp;&amp; !used[i][j])<span class="comment">//如果这条边存在而且未被使用 </span></span><br><span class="line">            	Min=min(Min,ans+cost[i][j]-Max[i][j]);<span class="comment">//取最小差值 </span></span><br><span class="line">    <span class="keyword">if</span>(Min==INF) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在</span></span><br><span class="line">    <span class="keyword">return</span> Min;<span class="comment">//返回次小生成树的权值和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) cost[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> cost[i][j]=INF;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            u--;v--;</span><br><span class="line">            cost[u][v]=cost[v][u]=w;<span class="comment">//u到v的距离 </span></span><br><span class="line">        &#125;</span><br><span class="line">        ans=Prim(cost,n);</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==smst(cost,n)) <span class="built_in">printf</span>(<span class="string">"Not Unique!\n"</span>);<span class="comment">//权值和完全相同 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">//输出最小生成树的权值和 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/93b1f5dc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/93b1f5dc/" class="post-title-link" itemprop="url">暑期人生测试一总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:40:34" itemprop="dateCreated datePublished" datetime="2018-12-06T23:40:34+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-05 13:17:42" itemprop="dateModified" datetime="2019-05-05T13:17:42+08:00">2019-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   <strong>暑期测试一</strong></p>
<p><strong>数学作业</strong></p>
<p><strong>（homework.cpp）</strong></p>
<p><strong>【问题描述】 </strong></p>
<p>求：方程x1+2x2+„+nxn=m的所有非负整数解（x1,x2,„,xn）的个数。例如，方程：x1+2x2+3x3+4x4+5x5=5有7组解：（5,0,0,0,0）、（3,1,0 ,0,0）、……、（0,0,0,0,1）。</p>
<p><strong> 【输入数据】(homework.in) </strong></p>
<p>2个整数n，m</p>
<p><strong>【输出数据】(homework.out)</strong></p>
<p>方程非负整数解的个数ans，如果解超过10^9，只需输出ansmod 10^9。</p>
<p><strong>【输入样例】</strong> 55</p>
<p><strong>【输出样例】</strong> 7</p>
<p><strong>【数据范围】 </strong></p>
<p>1≤n≤5000；0≤m≤5000。</p>
<p>这道题可以将方程中的x1x2…..看作n个有价值的物品，要使这个方程刚好有解，则我们可以联想到完全背包问题中找方案类型的题目。抽象出来则可以描述为：有n件物品，重量依次为1到n，要将这些物品放入背包且刚好装满背包，求总方案数。接着粘上标准代码，AC；</p>
<p>注意！！！！！！每次状态转移后记得将求解的子问题答案Mod 10^9！！</p>
<p>否则变量爆掉！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">"homework.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"homework.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j++)<span class="comment">//分配i到m个空间 </span></span><br><span class="line">			f[j]=(f[j]+f[j-i])%<span class="number">1000000000</span>;		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[m]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p><strong>魔法石的诱惑</strong></p>
<p><strong>（rob.cpp）</strong></p>
<p><strong>问题描述</strong></p>
<p>修罗魔王远远地看见邪狼王狂奔而来，问道：“慌慌张张干什么？”</p>
<p>邪狼王大口大口初期：“我路过一家魔法石店，看到摆着那么多高阶魔法石，我就去抢了一大袋。”</p>
<p>修罗王怒道：“光天化日之下，朗朗乾坤，众目睽睽之下，你也敢抢？”</p>
<p>狼王：“我只看到了魔法石，没有看到人。。。”</p>
<p>修罗王：“。。。。。”</p>
<p>其实邪狼王的贪婪也很容易理解，因为高阶魔法石有一个特征，即它的重量进行阶乘运算后末尾有几个0，就拥有同等重量普通魔法石几倍的法力，例如5！=5<em>4</em>3<em>2</em>1=120,所以120有一个0，这意味着该魔法石拥有同等重量的普通魔法石1倍的魔法力，你的任务是找到最小的自然数N，使N！在十进制下有Q个0结尾。</p>
<p><strong>输入格式(rob.in)</strong></p>
<p>一个数Q（0≤Q≤10^8）</p>
<p><strong>输出格式(rob.out)</strong></p>
<p>如果无解，输出”No solution”，否则输出N</p>
<p><strong>输入样例</strong></p>
<p>2</p>
<p><strong>输出样例</strong></p>
<p>10</p>
<p>二分枚举答案，同时算出该数的阶乘所包含的0的个数</p>
<p>如何算阶乘中0的个数：10由2*5组成，阶乘中2远远大于5，所以只用关注5的个数，注意25 125等数中包含多个5，需要另行判断</p>
<p>枚举答案后还获得最优解，要进行判断处理才得出最优解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DuiShu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//取以5为底，n的对数 </span></span><br><span class="line">	<span class="keyword">int</span> pre=<span class="number">1</span>,nxt=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;=pre&amp;&amp;n&lt;nxt) <span class="keyword">return</span> i;</span><br><span class="line">		pre*=<span class="number">5</span>; nxt*=<span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//计算n的阶乘有多少个5</span></span><br><span class="line">	<span class="keyword">int</span> ds=DuiShu(n),sum=<span class="number">0</span>;<span class="comment">//取对数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> pre=<span class="number">5</span>,nxt=<span class="number">25</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ds;i++)&#123;<span class="comment">//每5^i个数产生一个0</span></span><br><span class="line">		sum+=n/pre;</span><br><span class="line">		pre*=<span class="number">5</span>; nxt*=<span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;<span class="comment">//二分查找最佳答案 </span></span><br><span class="line">	<span class="keyword">int</span> mid,ans;</span><br><span class="line">	<span class="keyword">while</span>(s&lt;=e)&#123;</span><br><span class="line">		mid=(s+e)/<span class="number">2</span>;</span><br><span class="line">		ans=calc(mid);</span><br><span class="line">		<span class="keyword">if</span>(ans==Q)</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans&gt;Q)<span class="comment">//0多了 </span></span><br><span class="line">			e=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans&lt;Q)<span class="comment">//0少了</span></span><br><span class="line">			s=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindBest</span><span class="params">(<span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ans%<span class="number">5</span>!=<span class="number">0</span>)<span class="comment">//如果不是最优解</span></span><br><span class="line">		ans=ans-(ans%<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">"rob.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"rob.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line">	<span class="keyword">if</span>(Q==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=BinarySearch(<span class="number">5</span>,<span class="number">200000000</span>);</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No solution"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,FindBest(ans));</span><br><span class="line"></span><br><span class="line"><span class="comment">//	printf("%d",DuiShu(30));//测试 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p>  **<strong>架设电话线</strong></p>
<p><strong>(phoneline.cpp)</strong></p>
<p>FarmerJohn打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。</p>
<p>FJ的农场周围分布着N(1&lt;= N &lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1&lt; = P &lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。</p>
<p>第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为L_i(1 &lt;= L_i &lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。</p>
<p>经过谈判，电信公司最终同意免费为FJ连结K(0 &lt;= K &lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过K对，那么FJ的总支出为0。</p>
<p>请你计算一下，FJ最少需要在电话线上花多少钱。</p>
<p><strong>输入(phoneline.in)</strong></p>
<ul>
<li>第1行: 3个用空格隔开的整数：N，P，以及K</li>
<li>第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i</li>
</ul>
<p><strong>输出(phoneline.out)</strong></p>
<ul>
<li>第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成，输出-1</li>
</ul>
<p><strong>样例输入</strong></p>
<p>5 7 1 1 2 5 3 1 4 2 4 8 3 2 35 2 9 3 4 7 4 5 6</p>
<p><strong>样例输出</strong></p>
<p>4</p>
<p><strong>提示</strong></p>
<p>输入说明:</p>
<p>一共有5根废弃的电话线杆。电话线杆1不能直接与电话线杆4、5相连。电话线杆5不能直接与电话线杆1、3相连。其余所有电话线杆间均可拉电话线。电信公司可以免费为FJ连结一对电话线杆。</p>
<p>输出说明:</p>
<p>FJ选择如下的连结方案：1-&gt;3；3-&gt;2；2-&gt;5，这3对电话线杆间需要的电话线的长度分别为4、3、9。FJ让电信公司提供那条长度为9的电话线，于是，他所需要购买的电话线的最大长度为4。</p>
<p>这么明显的二分加最短路算法竟然没想到！！！</p>
<p>1.首先二分枚举一个电话线长度标准aim，大于此标准的线交给电信部门，自己支付aim元</p>
<p>2.生成带权边，由于要使电信公司刚好支付大于aim的所有线的费用，所以John选择的最佳路线中长度大于aim的电话线数量应该刚好等于K，即大于aim权边为1否则为0，使权和为K即可。权和大于K则表示aim太小，小于K则表示aim太大</p>
<p>3.做SPFA最短路径，结合二分法得出答案</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mrh929</p>
  <div class="site-description" itemprop="description">Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/posts">
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mrh929</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
