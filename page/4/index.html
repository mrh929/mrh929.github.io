<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>mrh929&#39;s home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="mrh929&#39;s home">
<meta property="og:url" content="http://mrh1s.top/page/4/index.html">
<meta property="og:site_name" content="mrh929&#39;s home">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mrh929&#39;s home">
<meta name="twitter:description" content="Blog">
  
    <link rel="alternate" href="/atom.xml" title="mrh929&#39;s home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mrh929&#39;s home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mrh1s.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93/" class="article-date">
  <time datetime="2018-12-06T15:41:33.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93/">最小生成树总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  啊，先纪念一下吧，难得一天这么666 AC完了所有题 （次小生成树代码看懂） 今天学到了最小生成树算法中的Prim算法和Kruskal算法。从宏观上来讲prim更适合稠密图，krustal更适合稀疏图，但对于我们来说暂时没有什么区别啦。 Prim算法中主要注意的点是</p>
<ol>
<li><strong>在visit数组与minn数组（最小到达某点的权边的权值）上 注意只有未遍历而且小于当前所存的权才可以更新</strong></li>
<li><strong>循环次数为n-1次，错误的次数会导致答案错误</strong></li>
<li><strong>除自身为0以外，所有点之间的初始距离为正无穷</strong> </li>
</ol>
<p><strong>Kruskal算法中主要注意的点是</strong></p>
<ol>
<li><strong>所有的边要用结构体存，方便快排</strong></li>
<li><strong>注意并查集的Getfather函数的压缩路径和union函数的是否父亲相同的判断</strong></li>
<li><strong>注意变量k的维护，k满足k==n-1时必须及时跳出循环</strong></li>
</ol>
<p><strong> 还有一个很容易忽略的问题！！就是memset，特别是有多组数据的时候必须在前面重置内存</strong> 附上我对次小生成树代码的注释：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
using namespace std;

/*
 * 次小生成树
 * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权
 * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案
 * 点的编号从0开始
 */
const int MAXN=110;
const int INF=0x3f3f3f3f;//最大值 
bool vis[MAXN];//点是否已使用 
int lowc[MAXN];//到每一个点权值最短的路径的权值 
int pre[MAXN];//存父亲 
int Max[MAXN][MAXN];//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权
bool used[MAXN][MAXN];//边是否已使用 
int Prim(int cost[][MAXN],int n){
    int ans=0;
    memset(vis,false,sizeof(vis));
    memset(Max,0,sizeof(Max));
    memset(used,false,sizeof(used));
    vis[0]=true;//已遍历 
    pre[0]=-1;//起始点没有父亲 
    for(int i=1;i&lt;n;i++){
        lowc[i]=cost[0][i];
        pre[i]=0;//设置父亲 
    }
    lowc[0]=0;
    for(int i=1;i&lt;n;i++){
        int minc=INF;
        int p=-1;//将要选择的下一个点 
        for(int j=0;j&lt;n;j++)
            if(!vis[j]&amp;&amp;minc&gt;lowc[j]){
                minc=lowc[j];//选择距离最小的边 
                p=j;
            }
        if(minc==INF) return -1;//该图不是连通图 
        ans+=minc;//权值和计算 
        vis[p]=true;//点已遍历 
        used[p][pre[p]]=used[pre[p]][p]=true;//边已遍历 
        for(int j=0;j&lt;n;j++){
            if(vis[j]) Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);//DP计算j到p的路径中权值最大的边的权值 
            if(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j]){//更新lowc数组 
                lowc[j]=cost[p][j];
                pre[j]=p;//设置父亲 
            }
        }
    }
    return ans;
}
int ans;
int smst(int cost[][MAXN],int n){
    int Min=INF;
    for(int i=0;i&lt;n;i++)
        for(int j=i+1;j&lt;n;j++)
            if(cost[i][j]!=INF &amp;&amp; !used[i][j])//如果这条边存在而且未被使用 
                Min=min(Min,ans+cost[i][j]-Max[i][j]);//取最小差值 
    if(Min==INF) return -1;//不存在
    return Min;//返回次小生成树的权值和 
}
int cost[MAXN][MAXN];
int main(){
    int T;
    int n,m;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--){
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        int u,v,w;
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++){
                if(i==j) cost[i][j]=0;
                else cost[i][j]=INF;
            }
        while(m--){
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            u--;v--;
            cost[u][v]=cost[v][u]=w;//u到v的距离 
        }
        ans=Prim(cost,n);
        if(ans==-1){
            printf(&quot;Not Unique!\n&quot;);
            continue;
        }
        if(ans==smst(cost,n)) printf(&quot;Not Unique!\n&quot;);//权值和完全相同 
        else printf(&quot;%d\n&quot;,ans);//输出最小生成树的权值和 
    }
    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93/" data-id="cjv7vtpwz000ozgetkdfl7rln" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93/" class="article-date">
  <time datetime="2018-12-06T15:40:34.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93/">暑期人生测试一总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>**暑期测试一** **数学作业** **（homework.cpp）** **【问题描述】** 求：方程x1+2x2+„+nxn=m的所有非负整数解（x1,x2,„,xn）的个数。例如，方程：x1+2x2+3x3+4x4+5x5=5有7组解：（5,0,0,0,0）、（3,1,0 ,0,0）、……、（0,0,0,0,1）。 **【输入数据】(homework.in)** 2个整数n，m **【输出数据】(homework.out)** 方程非负整数解的个数ans，如果解超过10^9，只需输出ansmod 10^9。 **【输入样例】** 55 **【输出样例】** 7 **【数据范围】** 1≤n≤5000；0≤m≤5000。 这道题可以将方程中的x1x2.....看作n个有价值的物品，要使这个方程刚好有解，则我们可以联想到完全背包问题中找方案类型的题目。抽象出来则可以描述为：有n件物品，重量依次为1到n，要将这些物品放入背包且刚好装满背包，求总方案数。接着粘上标准代码，AC； 注意！！！！！！每次状态转移后记得将求解的子问题答案Mod 10^9！！ 否则变量爆掉！！ 

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
long long f[10000];
int main()
{
    freopen(&quot;homework.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;homework.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    if(m==0){
        printf(&quot;1&quot;);
        return 0;
    }

    f[0]=1;
    for(int i=1;i&lt;=n;i++)
        for(int j=i;j&lt;=m;j++)//分配i到m个空间 
            f[j]=(f[j]+f[j-i])%1000000000;        
    printf(&quot;%lld&quot;,f[m]);

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p><strong>魔法石的诱惑</strong> <strong>（rob.cpp）</strong> <strong>问题描述</strong> 修罗魔王远远地看见邪狼王狂奔而来，问道：“慌慌张张干什么？” 邪狼王大口大口初期：“我路过一家魔法石店，看到摆着那么多高阶魔法石，我就去抢了一大袋。” 修罗王怒道：“光天化日之下，朗朗乾坤，众目睽睽之下，你也敢抢？” 狼王：“我只看到了魔法石，没有看到人。。。” 修罗王：“。。。。。” 其实邪狼王的贪婪也很容易理解，因为高阶魔法石有一个特征，即它的重量进行阶乘运算后末尾有几个0，就拥有同等重量普通魔法石几倍的法力，例如5！=5*4*3*2*1=120,所以120有一个0，这意味着该魔法石拥有同等重量的普通魔法石1倍的魔法力，你的任务是找到最小的自然数N，使N！在十进制下有Q个0结尾。   <strong>输入格式(rob.in)</strong> 一个数Q（0≤Q≤10^8） <strong>输出格式(rob.out)</strong> 如果无解，输出”No solution”，否则输出N <strong>输入样例</strong> 2 <strong>输出样例</strong> 10 二分枚举答案，同时算出该数的阶乘所包含的0的个数 如何算阶乘中0的个数：10由2*5组成，阶乘中2远远大于5，所以只用关注5的个数，注意25 125等数中包含多个5，需要另行判断 枚举答案后还获得最优解，要进行判断处理才得出最优解  </p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int Q;

int DuiShu(int n){//取以5为底，n的对数 
    int pre=1,nxt=5;
    for(int i=0;i&lt;=20;i++){
        if(n&gt;=pre&amp;&amp;n&lt;nxt) return i;
        pre*=5; nxt*=5;
    }
}

int calc(int n){//计算n的阶乘有多少个5
    int ds=DuiShu(n),sum=0;//取对数

    int pre=5,nxt=25;
    for(int i=1;i&lt;=ds;i++){//每5^i个数产生一个0
        sum+=n/pre;
        pre*=5; nxt*=5;
    }
    return sum;
} 

int BinarySearch(int s,int e){//二分查找最佳答案 
    int mid,ans;
    while(s&lt;=e){
        mid=(s+e)/2;
        ans=calc(mid);
        if(ans==Q)
            return mid;
        else if(ans&gt;Q)//0多了 
            e=mid-1;
        else if(ans&lt;Q)//0少了
            s=mid+1;
    }
    return -1;
}

int FindBest(int ans){
    if(ans%5!=0)//如果不是最优解
        ans=ans-(ans%5);
    return ans;
}

int main()
{
    freopen(&quot;rob.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;rob.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;Q);
    if(Q==0){
        printf(&quot;1&quot;);
        return 0;
    }
    int ans=BinarySearch(5,200000000);
    if(ans==-1)
        printf(&quot;No solution&quot;);
    else
        printf(&quot;%d&quot;,FindBest(ans));

//    printf(&quot;%d&quot;,DuiShu(30));//测试 

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p>  <strong>架设电话线</strong> <strong>(phoneline.cpp)</strong> FarmerJohn打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。 FJ的农场周围分布着N(1&lt;= N &lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1&lt; = P &lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。 第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为L_i(1 &lt;= L_i &lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。 经过谈判，电信公司最终同意免费为FJ连结K(0 &lt;= K &lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过K对，那么FJ的总支出为0。 请你计算一下，FJ最少需要在电话线上花多少钱。 <strong>输入(phoneline.in)</strong> * 第1行: 3个用空格隔开的整数：N，P，以及K <em> 第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i <strong>输出(phoneline.out)</strong> \</em> 第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成，输出-1 <strong>样例输入</strong> 5 7 1 1 2 5 3 1 4 2 4 8 3 2 35 2 9 3 4 7 4 5 6 <strong>样例输出</strong> 4 <strong>提示</strong> 输入说明: 一共有5根废弃的电话线杆。电话线杆1不能直接与电话线杆4、5相连。电话线杆5不能直接与电话线杆1、3相连。其余所有电话线杆间均可拉电话线。电信公司可以免费为FJ连结一对电话线杆。 输出说明: FJ选择如下的连结方案：1-&gt;3；3-&gt;2；2-&gt;5，这3对电话线杆间需要的电话线的长度分别为4、3、9。FJ让电信公司提供那条长度为9的电话线，于是，他所需要购买的电话线的最大长度为4。 这么明显的二分加最短路算法竟然没想到！！！ 1.首先二分枚举一个电话线长度标准aim，大于此标准的线交给电信部门，自己支付aim元 2.生成带权边，由于要使电信公司刚好支付大于aim的所有线的费用，所以John选择的最佳路线中长度大于aim的电话线数量应该刚好等于K，即大于aim权边为1否则为0，使权和为K即可。权和大于K则表示aim太小，小于K则表示aim太大 3.做SPFA最短路径，结合二分法得出答案</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93/" data-id="cjv7vtpx2000vzgetidhq4b6a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:39:25.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3/">打印月历题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="24-打印月历"><a href="#24-打印月历" class="headerlink" title="24:打印月历"></a>24:打印月历</h2><p>总时间限制: 1000ms   内存限制: 65536kB 描述 给定年月，打印当月的月历表。 输入 输入为一行两个整数，第一个整数是年份year（1900 ≤ year ≤ 2099），第二个整数是月份month（1 ≤ month ≤ 12），中间用单个空格隔开。 输出 输出为月历表。月历表第一行为星期表头，如下所示： Sun Mon Tue Wed Thu Fri Sat 其余各行一次是当月各天的日期，从1日开始到31日（30日或28日）。 日期数字应于星期表头右对齐，即各位数与星期表头相应缩写的最后一个字母对齐。日期中间用空格分隔出空白。 样例输入 2006 5 样例输出 Sun Mon Tue Wed Thu Fri Sat 1   2   3   4   5   6 7   8   9  10  11  12  13 14  15  16  17  18  19  20 21  22  23  24  25  26  27 28  29  30  31 提示 闰年判断方法：能被4整除但不能被100整除，或者能被400整除。 1900年1月1日是周一。     题解： 这道题是典型的模拟日期变更的题目。为了节省时间提高效率，可把目标年份的1月1日的星期算出来，然后通过循环模拟，最终算出目标月份的1日的星期。 计算部分在本题还算简单，但重要的是如何输出。 首先输出固定格式， 我们知道日历的开头通常都是有空格的（1日是星期天除外），由此我们可以写循环来输出日历前面的空格。 接下来依次输出每个日期，这里又会有个问题，就是换行的问题，这个问题可以通过声明一个变量判断日历是否打印到行尾，是就换行，不是就输出空格。 还有一点细节需要注意，当日期到最后一天时，是不允许有空格出现的，所以我们应该在最后加一个条件判断，这样程序就完整了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;

int main()
{
    int year,month;
    scanf(&quot;%d %d&quot;,&amp;year,&amp;month);
    int day=1;
    for(int i=1;i&lt;=year-1900;i++)
    {
        int sum=1900+i-1;
        if((sum%4==0&amp;&amp;sum%100!=0)||sum%400==0)
            day+=2;
        else
            day++;
        if(day&gt;=8)
            day-=7;
    }


    for(int i=1;i&lt;month;i++)
    {
        if(i!=2)
        {
            switch(i)
            {
                case 1:case 3:case 5:case 7:case 8:case 10:case 12:day+=31%7;break;
                case 4:case 6:case 9:case 11:day+=30%7;break;

            }
        }
        else
        {
            if((year%4==0&amp;&amp;year%100!=0)||year%400==0)
                day+=29%7;
            else
                day+=28%7;
        }
        if(day&gt;=8)
            day-=7;
    }

    int count;
    if(month!=2)
    {
        switch(month)
        {
            case 1:case 3:case 5:case 7:case 8:case 10:case 12:count=31;break;
            case 4:case 6:case 9:case 11:count=30;break;
        }
    }
    else
    {
        if((year%4==0&amp;&amp;year%100!=0)||year%400==0)
            count=29;
        else
            count=28;
    }

    printf(&quot;Sun Mon Tue Wed Thu Fri Sat\n&quot;);
    for(int i=day==7?0:day;i!=0;i--)
    {
        printf(&quot;    &quot;);
    }
    int n=day;
    for(int i=1;i&lt;=count;i++)
    {
        if(i&lt;=9)
            printf(&quot;  %d&quot;,i);
        else
            printf(&quot; %d&quot;,i);
        if(i==count)
            ;
        else if(n%7==6)
            printf(&quot;\n&quot;);
        else
            printf(&quot; &quot;);
        n++;
    }

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpx0000qzgetkcla61ac" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:39:02.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3/">大整数乘法题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>09:大整数乘法</strong> 总时间限制: 1000ms 内存限制: 65536kB 描述 求两个不超过200位的非负整数的积。 输入 有两行，每行是一个不超过200位的非负整数，没有多余的前导0。 输出 一行，即相乘后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。 样例输入 12345678900 98765432100 样例输出 1219326311126352690000 来源 程序设计实习2007 <strong>题解：</strong> <strong>        这道题的参数过大，甚至不能用长整型变量解决，那么就应该使用高精度算法。我们曾经写过高精度加法，本题算法只是高精度加法的延伸。</strong> <strong>将两个数用字符串数组读入，再转化成整型数组储存，此时储存顺序应该为倒序，即第一位用来存放个位，第二位存放十位，以此类推……（这样的目的是在于它能方便我们进位时的数据存放），好了这里有一个问题，题目并没有提到输入数据中不是先序0（如00003、0000等），所以这里可以添加判断语句只截取有意义的部分（当然也可以在计算之后判断再最高位的数字，如果为0则不输出）</strong> <strong>       接下来是整个算法的核心部分！！我们知道，高精度加法是对应位相加，如果结果大于等于10则进一位，然而乘法只是加法的一个高级形式而已，所以我们也可以将此高精度乘法转化为多个高精度加法，即a数中的每一位数去乘b数中的每一位数，最后求和。</strong> <strong>       经过观察，我们可以发现，当我们将某x位的数乘某y位的数时，两个数除了最高位之外其余位都为0，运算结果为两数之积，而它所在的位数为x+y，用两个for循环，就可以实现a数中的每一位数去乘b数中的每一位数。而得到的结果则ans[x+y]+=两数之积 ，这样就得到了未进位的两大数相乘的结果（源码中我使用了进位，实际上可以删除）。</strong> <strong>       最后一步，进位操作。从最低位算起</strong> <strong>ans[i+1]=ans[i]/10;</strong> <strong>ans[i]%=10;</strong> <strong>输出。AC！！喜悦！！</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

int a[300],b[300],ans[1000];
int work(int n,bool t)//n输入的字符（数字） t是否转换成数字 
{//字符与数字的转换函数 
    if(t==1)
        return n-&apos;0&apos;;
    else
        return &apos;0&apos;+n;
}

int main()
{
    char c[300];
    int len_a,len_b;
    gets(c);
    len_a=strlen(c);
    for(int i=len_a;i&gt;=1;i--)
        a[len_a-i]=work(c[i-1],1);//以倒序整型读入两个数
    gets(c);
    len_b=strlen(c);    
    for(int i=len_b;i&gt;=1;i--)
        b[len_b-i]=work(c[i-1],1);

    int ji;    //对两个数进行操作，但不进位，保存在ans[]中 
    for(int i=0;i&lt;=len_a-1;i++)
        for(int j=0;j&lt;=len_b-1;j++)
        {
            ji=a[i]*b[j];
            ans[i+j+1]+=ji/10;
            ans[i+j]+=ji%10;//此处累赘，可以不用进位，到最后一同进位 
        }

    int j=0,log;
    while(j&lt;=len_a+len_b-2)//进位操作 
    {
        log=ans[j];
        if(log&gt;=10)
        {
            ans[j]=log%10;
            ans[j+1]+=log/10;
        }
        j++;
    }
    /*if(ans[len_a+len_b-2]==0)
        j--;*/
    while(ans[j]==0&amp;&amp;j&gt;=0)
        j--;
    if(j==-1)
        j++;
    for(int i=j;i&gt;=0;i--)//输出数字
        printf(&quot;%c&quot;,work(ans[i],0));

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpww000izgetyb866xqa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:38:31.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3/">2的幂次方表示题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="8758-2的幂次方表示"><a href="#8758-2的幂次方表示" class="headerlink" title="8758:2的幂次方表示"></a>8758:2的幂次方表示</h2><p>总时间限制: 1000ms 内存限制: 65536kB 描述 任何一个正整数都可以用2的幂次方表示。例如： 137=27+23+20 同时约定方次用括号来表示，即ab可表示为a(b)。由此可知，137可表示为： 2(7)+2(3)+2(0) 进一步：7=22+2+20（21用2表示） 3=2+20 所以最后137可表示为： 2(2(2)+2+2(0))+2(2+2(0))+2(0) 又如： 1315=210+28+25+2+1 所以1315最后可表示为： 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) 输入 一个正整数n（n≤20000）。 输出 一行，符合约定的n的0，2表示（在表示中不能有空格）。 样例输入 137 样例输出 2(2(2)+2+2(0))+2(2+2(0))+2(0) 来源 NOIP1998复赛 普及组 第一题     <strong>题解：将一个大数拆分为若干个2的n次方的和，并且将次方和再拆分成若干个部分，这样很容易就可以想起递归算法。</strong> <strong>       实际上问题大致分为两步：</strong> <strong>1.    将数字分解为2的n次方</strong> <strong>2.    将n再次分解为2的n次方（调用自身，如果n==2则结束printf(“2”);</strong> <strong>如果n==1 则printf(“2(0)”);）</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;


void work(int n)
{
    if(n==1)//初始判断条件，如果n为1或2则直接输出 
    {
        printf(&quot;2(0)&quot;);
        return;
    }
    else if(n==2)
    {
        printf(&quot;2&quot;);
        return; 
    } 
    else
    {
        int j=1,i=0;//j每次乘2,如果大于了n就分解结束，i为当前次数 
        do
        {
            j*=2;
            if(j&gt;n)
            {
                j/=2;
                if(i==1)//这步非常重要，确定是否需要继续 2() 
                    printf(&quot;2&quot;);
                else
                {
                    printf(&quot;2(&quot;);
                    work(i);
                    printf(&quot;)&quot;);
                }    
                if(n-j!=0)//如果n分解之后还有剩余的数，那么继续分解 
                {
                    printf(&quot;+&quot;);
                    work(n-j);
                }
                return;
            }
            else
                i++;


        }while(1);
    }    


}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    work(n);
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpwr0009zgetlj597423" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:38:07.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3/">逆波兰表达式题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1696-逆波兰表达式"><a href="#1696-逆波兰表达式" class="headerlink" title="1696:逆波兰表达式"></a>1696:逆波兰表达式</h2><p>  总时间限制: 1000ms 内存限制: 65536kB 描述 逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) <em> 4的逆波兰表示法为</em> + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - <em> /四个。 输入 输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 输出 输出为一行，表达式的值。 可直接用printf(“%f\n”, v)输出表达式的值v。 样例输入 </em> + 11.0 12.0 + 24.0 35.0 样例输出 1357.000000 提示 可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。 此题可使用函数递归调用的方法求解。 来源 计算概论05     <strong>题解：看到逆波兰表达式，首先我们要详细了解逆波兰表达式的用法。通过观察，我们可以大致明白一个逆波兰表达式是由</strong> <strong>表达式=符号(+,-,*,/)  + 数字1（或子表达式） +   数字2（或子表达式）</strong> <strong>组成的，每个子表达式只需要两个参数的输入，所以参数的读入可以在运算时进行，以避免不知道读入数据的个数。PS：我做题时用while(getchar()!=‘ ’) scanf(“%d”,a) 做直接超时！（因为数据已经输入完成，而程序还在等待输入）</strong>  <strong>既然我们有了表达式到子表达式的过程，那么这其实是一个递归的过程，可以写一个递归的函数来处理问题。结束条件无需定义，因为每个子表达式只需两个参数，输入两个参数自动结束。</strong> <strong>      读入一个字符串，判断它是否为数字，如果为数字便直接以双精度形式return atof(a)，数字的判断以a[0]是否属于数字为准；如果是一个符号，就继续调用自身，获取两个参数，运算后返回。return f(x) 运算(+,-,*,/) f(x)，用switch语句判断符号。</strong> <strong>      大致过程如下：</strong> <img src="http://img.blog.csdn.net/20160124153009539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动">​</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

int n=1;
char a[3000];
double work()
{
    scanf(&quot;%s&quot;,a);
    int len=strlen(a);
    if(len==1&amp;&amp;!(a[0]&gt;=&apos;0&apos;&amp;&amp;a[0]&lt;=&apos;9&apos;))
        switch(a[0])
        {
            case &apos;+&apos;:return work() + work();
            case &apos;-&apos;:return work() - work();
            case &apos;*&apos;:return work() * work();
            case &apos;/&apos;:return work() / work();
        }
    else
    {
        return atof(a);
    }
}

int main()
{
    printf(&quot;%f&quot;,work());
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpx60013zget68cq9q38" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:37:40.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3/">Vigenère密码题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="08-Vigenere密码"><a href="#08-Vigenere密码" class="headerlink" title="08:Vigenère密码"></a>08:Vigenère密码</h2><p>总时间限制: 1000ms 内存限制: 65536kB 描述 16世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 在密码学中，我们称需要加密的信息为明文，用M表示；称加密后的信息为密文，用C表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为k。在Vigenère密码中，密钥k是一个字母串，k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中ci=mi®ki，运算®的规则如下表所示： <img src="http://img.blog.csdn.net/20160123190547906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动">​ Vigenère加密在操作时需要注意： 1. ®运算忽略参与运算的字母的大小写，并保持字母在明文M中的大小写形式； 2. 当明文M的长度大于密钥k的长度时，将密钥k重复使用。 例如，明文M=Helloworld，密钥k=abc时，密文C=Hfnlpyosnd。</p>
<p>明文</p>
<p>H</p>
<p>e</p>
<p>l</p>
<p>l</p>
<p>o</p>
<p>w</p>
<p>o</p>
<p>r</p>
<p>l</p>
<p>d</p>
<p>密钥</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>a</p>
<p>密文</p>
<p>H</p>
<p>f</p>
<p>n</p>
<p>l</p>
<p>p</p>
<p>y</p>
<p>o</p>
<p>s</p>
<p>n</p>
<p>d</p>
<p>  输入 输入共2行。 第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母。 对于100%的数据，输入的密钥的长度不超过100，输入的密文的长度不超过1000，且都仅包含英文字母。 输出 输出共1行，一个字符串，表示输入密钥和密文所对应的明文。 样例输入 CompleteVictory Yvqgpxaimmklongnzfwpvxmniytm 样例输出 Wherethereisawillthereisaway 来源 NOIP2012复赛 提高组 第一题 <strong>题解：注意本题是由密文解密为原文。由于密钥和密文需要进行相互运算，所以转换大小写是必不可少的，题目有要求原文大小写与密文一致，所以我们可以用一个数组</strong> <strong>int miwen_x[2000] 来储存原文大小写的数据</strong> <strong>读入密文、密钥，转换大小写并且记录密文的大小写状况</strong> </p>
<h2 id="接着就是解密数据了，让我们来观察一下Vigenere密码的规律吧"><a href="#接着就是解密数据了，让我们来观察一下Vigenere密码的规律吧" class="headerlink" title="接着就是解密数据了，让我们来观察一下Vigenère密码的规律吧"></a>接着就是解密数据了，让我们来观察一下Vigenère密码的规律吧</h2><p><img src="http://img.blog.csdn.net/20160123190547906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动">​</p>
<p><strong>本表指 一对密钥与原文可以加密成密文，现在要翻译密文，也就是知道对应的点，也知道了y轴坐标，求x轴坐标。</strong> <strong>1.</strong> <strong>当密文≥密钥时，我们发现数据是依次递增的，则此时ans[i]=</strong> <strong>miwen[i]-key[j]+’a’</strong> <strong>2.</strong> <strong>当密文&lt;密钥时，数据由最右端向左依次递减，此时ans[i]=</strong> <strong>‘z’-(key[j]-miwen[i]-1)</strong> <strong>j的意义在后面。</strong>  <strong>注意这里还有一个易错点，密钥的长度可能小于密文的长度，那么当密钥较短时就要运用循环多次使用此密钥</strong> <strong>int j=0;</strong> <strong>并且在每次循环后</strong> <strong>j++;</strong> <strong>if(j==strlen(key))</strong> <strong>      j=0;</strong> <strong>最后通过miwen_x[i]的值将原文的大小写形式恢复原样</strong> <strong>这样就解决此问题了</strong>  <strong>本题总思路：</strong> <strong>1.     读入密钥、密文并转换成小写（大写也可），同时记录密文的大小写情况</strong> <strong>2.     运用算法算出原文</strong> <strong>3.     通过大小写情况恢复原文的大小写</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

int change(int i)//大小写转换 
{
    return (i&gt;=&apos;A&apos;&amp;&amp;i&lt;=&apos;Z&apos;)?i+&apos;a&apos;-&apos;A&apos;:i;
}


int main()
{
    char key[120];
    char miwen[1200];
    int miwen_x[1200];//密文大小写 1小写 2大写 
    scanf(&quot;%s %s&quot;,key,miwen);
    int len=strlen(key);
    for(int i=0;i&lt;=len-1;i++)
        key[i]=change(key[i]);
    for(int i=0;i&lt;=strlen(miwen)-1;i++)
    {
        if(miwen[i]&gt;=&apos;A&apos;&amp;&amp;miwen[i]&lt;=&apos;Z&apos;)
            miwen_x[i]=2;
        else
            miwen_x[i]=1;
        miwen[i]=change(miwen[i]);
    }

    char ans[1200];
    int j=0;
    for(int i=0;i&lt;=strlen(miwen)-1;i++)
    {
        if(miwen[i]&gt;=key[j])
            ans[i]=miwen[i]-key[j]+&apos;a&apos;;
        else
            ans[i]=&apos;z&apos;-(key[j]-miwen[i]-1);
        if(miwen_x[i]==2)
            ans[i]=ans[i]-(&apos;a&apos;-&apos;A&apos;);
        j++;
        if(j==len)
            j=0;
    }
    ans[strlen(miwen)]=0;
    printf(&quot;%s&quot;,ans);


    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpxa001dzgetrzf5r742" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:36:10.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3/">铺地毯题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="14-铺地毯"><a href="#14-铺地毯" class="headerlink" title="14:铺地毯"></a>14:铺地毯</h2><p>总时间限制: 1000ms 内存限制: 65536kB 描述 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有n张地毯，编号从1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出样例1说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（2，2）的最上面一张地毯是3号地毯。 输入输出样例2说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（4，5）的最上面一张地毯是3号地毯。   输入 输入共n+2行。 第一行，一个整数n，表示总共有n张地毯。 接下来的n行中，第i+1行表示编号i的地毯的信息，包含四个正整数a，b，g，k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x轴和y轴方向的长度。 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标（x，y）。 对于30%的数据，有n≤2； 对于50%的数据，0≤a, b, g, k≤100； 对于100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。 输出 输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。 样例输入 样例 #1： 3 1 0 2 3 0 2 3 3 2 1 3 3 2 2   样例 #2： 3 1 0 2 3 0 2 3 3 2 1 3 3 4 5 样例输出 样例 #1： 3   样例 #2： -1 来源 NOIP2011复赛 提高组 第一题     题解 根据习惯性思维，看到这道题我们通常会建一个二维数组，用二维数组的每个元素来表示各个点的地毯覆盖情况。这样的方法可行，但是效率较低，不适合数据过大的运算，本题n&lt;=10000。 仔细审题，我们发现题目所需要的仅仅是一个点的地毯覆盖情况，所以撒大网的方式并不是最优的算法。 于是就考虑对于目标点单独进行操作，题目给出了毯子左下角的坐标，也给出了毯子的长宽，通过这两组数据我们就可以求到毯子的四个角所在的坐标，然后判断该点是否存在于此范围中，然后进行操作就可以了。 先建立一个二维数组，第一个下标表示毯子的次序，第二个下标分别用1,2,3,4来表示该毯子的左下角坐标a，b 和 长宽g，k int a[20020][4]; int log=-1 读入相应数据与目标点后，开始操作 循环判断目标点是否在相应毯子中，如果是则将负责记录的变量更新 for(int i=1;i&lt;=n;i++) if(x&lt;=a[i][1]+a[i][3]&amp;&amp;x&gt;=a[i][1]&amp;&amp;y&lt;=a[i][2]+a[i][4]&amp;&amp;y&gt;=a[i][2]) log=i; 如果无一个毯子符合条件，则log=-1 输出，AC！</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int main()
{
    int n;
    int a[10001][5];
    int x,y;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d %d %d %d&quot;,&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]);
    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);

    int log=-1;
    for(int i=1;i&lt;=n;i++)
        if(x&lt;=a[i][1]+a[i][3]&amp;&amp;x&gt;=a[i][1]&amp;&amp;y&lt;=a[i][2]+a[i][4]&amp;&amp;y&gt;=a[i][2])
            log=i;

    printf(&quot;%d&quot;,log);

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpx70016zgetemmovffd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:33:09.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3/">螺旋矩阵题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  螺旋矩阵 (matrix.cpp) 【问题描述】 一个n行n列的螺旋矩阵可由如下方法生成： 从矩阵的左上角（第1行第1列）出发，初始时向右移动；如果前方是未曾经过的格子， 则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入1, 2, 3, … , n2，便构成了一个螺旋矩阵。 下图是一个n = 4 时的螺旋矩阵。  现给出矩阵大小n以及i和j，请你求出该矩阵中第i行第j列的数是多少。   【输入】 输入文件名为matrix.in。 输入共一行，包含三个整数n，i，j，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。   【输出】 输出文件名为matrix.out。 输出共一行，包含一个整数，表示相应矩阵中第i行第j列的数。   【输入输出样例】 matrix.in matrix.out 4 2 3 14   【数据说明】 对于50%的数据，1 ≤ n ≤ 100; 对于100%的数据，1 ≤ n ≤ 30,000，1 ≤ i ≤ n，1 ≤ j ≤ n</p>
<blockquote>
<p>首先看到这个题目 能想到的是数字由内而外的螺旋矩阵，就可以从内圈开始逐步模拟推出各个方框的数字，最后得出结果。 这样就可以得到规律：以左上角为坐标原点，向下为y轴正半轴，向右为x轴正半轴。 当n为偶数时，起点在(n/2+1,(n+1)/2)处。 当n为奇数时，起点在((n+1)/2, (n+1)/2)处。 那么就令int x,y为相应的数作为起点坐标，旋转规律如下： 数字递减的方向由 右 上 左 下的顺序进行旋转，每次改变方向，该点便沿此方向平移k次，然后再旋转，平移k（k=1）次，然后旋转，此时平移k+1次，以此类推，方向每改变两次，k=k+1。 运用int dir来储存方向 dir/4=1,2,3,4为每次平移的方向。 建立循环 for(int p=n;p&gt;=1;p–) 将矩阵枚举出来后，就可以输出相应点的值了。 但是本题n&lt;=30000 那么数组就要开9*10^8，既浪费空间也浪费时间，而且无法开出，所以这种方法在本题只适用前50%的数据。 那么怎么在不开数组、尽量不计算无关点的值就得出目标值呢？ 通过观察，发现矩阵是由n/2层构成，每层格数相差2格，对顶角上的点的值变化也有规律，如果我们找到了目标点所在的层数，就能通过较少的平移求出答案，而不是浪费资源。 至于层数的寻找，在i,j∈n/2时是容易的， i,j中的最小值即为层数，层数ceng=i&gt;j?j:i。 如果目标在其他位置，可通过对称的方式用相同的方法求出层数。 当i&gt;n/2 i’=1+(n-i) j同理。 接下来可求到此层左上角的点的值： int p=1 for(int m=1;m&lt;=ceng;m++) P+=4*(n-1); 运用刚才的平移法则，可求到相应的点。 再优化： 当j&gt;x且i=y时p(目标)=p+(j-x) ，平移判断 当i&gt;y且j=x时p(目标)=p+(i-y) ，平移 判断 当x&gt;j且i=y时p(目标)=p+(x-j) ，平移 判断 当y&gt;i且j=x时p(目标)=p+(y-i) 判断 这样就可以AC了</p>
</blockquote>
<p><del>~#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include<algorithm> int main() { freopen(“matrix.in”,”r”,stdin); freopen(“matrix.out”,”w”,stdout); int n,i,j; scanf(“%d %d %d”,&amp;n,&amp;i,&amp;j); int x=j,y=i; int a=n/2; <pre><code>if(n%2==0)//判断该数属于第几行 { if(x&gt;a) x=1+(n-x); if(y&gt;a) y=1+(n-y); } else { if(x&gt;a+1) x=1+(n-x); if(y&gt;a+1) y=1+(n-y); } int ceng=x&lt;y?x:y; x=1;y=1; int p=1; for(int m=1;m&lt;ceng;m++) { p+=4*(n-1); n-=2; x++; y++; } if(y==i) { p+=j-x; printf(“%d”,p); return 0; } p+=n-1; x+=n-1; if(x==j) { p+=i-y; printf(“%d”,p); return 0; } p+=n-1; y+=n-1; if(y==i) { p+=x-j; printf(“%d”,p); return 0; } p+=n-1; x-=n-1; if(x==j) { p+=y-i; printf(“%d”,p); return 0; } return 0; </code></pre> }</algorithm></del>~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3/" data-id="cjv7vtpx3000xzgetvvkhqhh0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e6-9d-a5-e4-b8-80-e6-ac-a1-e8-bf-81-e7-a7-bb-e5-b7-a5-e4-bd-9c-e5-90-a7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-9d-a5-e4-b8-80-e6-ac-a1-e8-bf-81-e7-a7-bb-e5-b7-a5-e4-bd-9c-e5-90-a7/" class="article-date">
  <time datetime="2018-12-06T15:22:31.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/牢骚/">牢骚</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-9d-a5-e4-b8-80-e6-ac-a1-e8-bf-81-e7-a7-bb-e5-b7-a5-e4-bd-9c-e5-90-a7/">来一次迁移工作吧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CSDN闲置很久没用了，今天登上去发现大量两年前写的题解，甚是怀念，现把其全部迁移至本博客</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-9d-a5-e4-b8-80-e6-ac-a1-e8-bf-81-e7-a7-bb-e5-b7-a5-e4-bd-9c-e5-90-a7/" data-id="cjv7vtpx1000tzget7yu96sr0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/">write up</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/cgctf/">cgctf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/cnss-recruit-201809/">cnss_recruit_201809</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/hgame-20190122/">hgame_20190122</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/nationalCTF-20190421/">nationalCTF_20190421</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/nctf-20181124/">nctf_20181124</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/牢骚/">牢骚</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RE-Dynamic/">RE_Dynamic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RE-Static/">RE_Static</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/RE-Dynamic/" style="font-size: 10px;">RE_Dynamic</a> <a href="/tags/RE-Static/" style="font-size: 20px;">RE_Static</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/28/bbvvmm/">bbvvmm</a>
          </li>
        
          <li>
            <a href="/2019/04/28/e5-8d-97-e4-ba-ac-e9-82-ae-e7-94-b5-e5-a4-a7-e5-ad-a6-re-wxyvm2/">南京邮电大学 RE-WxyVM2</a>
          </li>
        
          <li>
            <a href="/2019/04/13/e5-a3-b3-e7-9b-b8-e5-85-b3/">壳相关</a>
          </li>
        
          <li>
            <a href="/2019/03/22/shinyshot/">ShinyShot!</a>
          </li>
        
          <li>
            <a href="/2019/03/21/happyvm/">HappyVM</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 mrh929<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>