<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>mrh929&#39;s home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="mrh929&#39;s home">
<meta property="og:url" content="http://mrh1s.top/page/4/index.html">
<meta property="og:site_name" content="mrh929&#39;s home">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mrh929&#39;s home">
<meta name="twitter:description" content="Blog">
  
    <link rel="alternate" href="/atom.xml" title="mrh929&#39;s home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mrh929&#39;s home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mrh1s.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-e6-8b-93-e6-89-91-e6-8e-92-e5-ba-8f-e4-bb-a5-e5-8f-8a-e5-85-b3-e9-94-ae-e8-b7-af-e5-be-84-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-8b-93-e6-89-91-e6-8e-92-e5-ba-8f-e4-bb-a5-e5-8f-8a-e5-85-b3-e9-94-ae-e8-b7-af-e5-be-84-e6-80-bb-e7-bb-93/" class="article-date">
  <time datetime="2018-12-06T15:42:05.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-8b-93-e6-89-91-e6-8e-92-e5-ba-8f-e4-bb-a5-e5-8f-8a-e5-85-b3-e9-94-ae-e8-b7-af-e5-be-84-e6-80-bb-e7-bb-93/">拓扑排序以及关键路径总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  拓扑排序以及关键路径的总结 <strong>拓扑排序：首先纠正一个读音问题：拓扑(tuopu)话说我好几次都读成(tabu) (tuobu)好吗！</strong> <strong>      拓扑排序是针对AOV图（即有向无边图，且图中不允许环的存在）的一种排序算法，它用于将一个AOV图按照顺序排成线性序列</strong> <strong>       基本操作如下：</strong> <strong>1.记录每个节点的入度</strong> <strong>2.每次找到入度为零的点入栈，并将与之相连的节点入度减一</strong> <strong>3.重复2的动作，直到栈为空</strong> <strong>4.判断当前操作进行的次数，少于n次则有环，否则输出拓扑序列</strong> 家谱树 【问题描述】 有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。 给出每个人的孩子的信息。 输出一个序列，使得每个人的后辈都比那个人后列出。 【输入格式】 第1行一个整数N（1&lt;=N&lt;=100），表示家族的人数。 接下来N行，第I行描述第I个人的儿子。 每行最后是0表示描述完毕。 【输出格式】 输出一个序列，使得每个人的后辈都比那个人后列出。 如果有多解输出任意一解。 【输入样例】 5 0 4 5 1 0 1 0 5 3 0 3 0 【输出样例】 2 4 5 3 1</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=10000;
int first[MAX],nxt[MAX],go[MAX],arcnum=1;
int rd[MAX],stack[MAX],top;
void addarc(int a,int b){
    nxt[arcnum]=first[a];
    first[a]=arcnum;
    go[arcnum++]=b;
}

int main()
{
//    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    int n,m;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        while(scanf(&quot;%d&quot;,&amp;m)!=EOF &amp;&amp;m!=0)
            addarc(i,m),rd[m]++;
    for(int i=1;i&lt;=n;i++)
        if(rd[i]==0)
            stack[++top]=i;
    do{
        int now=stack[top--];
        printf(&quot;%d &quot;,now);
        for(int p=first[now];p!=0;p=nxt[p]){
            rd[go[p]]--;
            if(rd[go[p]]==0)
                stack[++top]=go[p];
        }
    }while(top!=0);


    return 0;
}
</code></pre><p><strong>该题是明显的拓扑排序题，按照标准格式写程序即可</strong>  <strong>奖金</strong> （<a href="http://fzoj.xndxfz.com/JudgeOnline/problem.php?id=1624）" target="_blank" rel="noopener">http://fzoj.xndxfz.com/JudgeOnline/problem.php?id=1624）</a> <strong>描述</strong> 由于无敌的凡凡在2005年世界英俊帅气男总决选中胜出，Yali Company总经理Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。 <strong>输入</strong> 第一行两个整数n,m，表示员工总数和代表数；以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。 输出 若无法找到合理方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。 <strong>样例输入</strong> 2 1 1 2 <strong>样例输出</strong> 201 <strong>提示</strong> 80％的数据满足n&lt;=1000，m&lt;=2000；100％的数据满足n&lt;=10000，m&lt;=20000。 <strong>此题比上一题多加入了点的权值</strong> <strong>也就是计算拓扑序列中权值和最小是多少</strong> <strong>标准做法：使用拓扑排序，在去掉某个点后，遍历它的相连节点时，计算该点的权值，是在(val[v],val[u]+1),其中u为起点，v为中点，中取最大值，开始我的理解出现的偏差，不能在那个点入度为0的时候才计算那个点的权值，因为那个点要满足的条件是比它之前的所有点权值都要小</strong></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=300000;
int first[MAX],nxt[MAX],go[MAX],arcnum=1,rd[MAX];
int stack[MAX],val[MAX],top;
void addarc(int a,int b){
    nxt[arcnum]=first[a];
    first[a]=arcnum;
    go[arcnum++]=b;
}
int main()
{
//    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    int n,m,a,b,k=0,tot=0;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        addarc(b,a);//b比a工资低 
        rd[a]++;//入度+1 
    }
    for(int i=1;i&lt;=n;i++)
        if(rd[i]==0)//将入度为0的点入栈 
            stack[++top]=i;
    while(top!=0){
        int now=stack[top--];//当前点 
        k++; tot+=100+val[now]; 
        for(int p=first[now];p!=0;p=nxt[p]){
            val[go[p]]=max(val[go[p]],val[now]+1);//不应当在入度为0时才更新val[]，而应当每次都更新，取最大值 
            if(--rd[go[p]]==0)
                stack[++top]=go[p];
            }
    }

    if(k==n) printf(&quot;%d&quot;,tot);
    else printf(&quot;Poor Xed&quot;);


    return 0;

}
</code></pre><p><strong>fzoj1621:烦人的幻灯片</strong> <strong>题目描述</strong> 李教授于今天下午做一个非常重要的演讲。不幸的是他不是一个非常爱整洁的人，他把自己做演讲要用的幻灯片随便堆放在一起。因此，演讲之前他不得不去整理这些幻灯片。做为一个讲求效率的学者，他希望尽可能简单地完成它。情况是这样，教授这次演讲一共要用n张幻灯片（n&lt;=26），这n张幻灯片按照演讲要使用的顺序已经用数字1，2，…，n在上面编上了号。因为幻灯片是透明的，所以我们不能一下子看清每一个数字所对应的幻灯片。 现在我们用大写字母A，B，C，。。。再次把幻灯片依次编号。你的任务是编写一个程序，把幻灯片的数字编号和字母编号对应起来，显然这种对应应该是唯一的；若出现多种对应的情况或是某些数字编号和字母对应不起来，我们就称对应是无法实现的。 <strong>输入</strong> 第一行：只有一个数n，表示有n张幻灯片。 接下来的n行：包括4个整数Xmin，Xmax，Ymin，Ymax（整数之间用空格分开），为幻灯片的坐标（该区域为幻灯片），这n张幻灯片按其在输入文件中出现的顺序从前到后依次编号为A，B，C，…再接下来的n行依次为n个数字编号的坐标X，Y，显然在幻灯片之外是不会有数字的。 <strong>输出</strong> 若是对应可以实现，你的输出应该包括n行，每一行为一个字母和一个数字，中间以一个空格隔开，并且各行以字母的升序排列，注意输出的字母要大写并且顶格；反之，若是对应无法实现，在第一行顶格输出None即可。行首行末无多余空格。 <strong>样例输入</strong> 4 6 22 10 20 4 18 6 16 8 20 2 18 10 24 4 8 9 15 19 17 11 7 21 11 <strong>样例输出</strong> A 4 B 1 C 2 D 3 <strong>这道题并不完全是拓扑排序题，但却用到了拓扑排序的思想</strong> <strong>读懂题意是关键，本题意思是每个数字都对应了一个或多个幻灯片，然后要求从中找出数字与幻灯片的一一对应关系</strong> <strong>节点个数很少，直接用邻接矩阵存储</strong> <strong>由于是数字对应幻灯片，所以我选择存储每个数字的出度，当某个数字出度为1时，寻找它所对应的幻灯片，记录，并且将与该幻灯片连接的其余数字全部断绝联系，出度也减1</strong> <strong>这样，n次之后就可以得到完整的一一对应关系</strong> </p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=1000;
int X1[MAX],X2[MAX],Y1[MAX],Y2[MAX],map[MAX][MAX],cd[MAX],ans[MAX];
int stack[MAX],top;

bool IsInside(int x,int y,int t){//第t张输入的幻灯片
    return x&gt;X1[t]&amp;&amp;x&lt;X2[t]&amp;&amp;y&gt;Y1[t]&amp;&amp;y&lt;Y2[t];
} 
int main()
{
//    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    int n,x,y,k=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d%d%d%d&quot;,&amp;X1[i],&amp;X2[i],&amp;Y1[i],&amp;Y2[i]);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        for(int j=1;j&lt;=n;j++)
            if(IsInside(x,y,j))
                map[i][j]=1,cd[i]++;//第i个数字在j-&apos;A&apos;+1的幻灯片中 
    }

    for(int i=1;i&lt;=n;i++)
        if(cd[i]==1)
            stack[++top]=i;
    do{
        int u=stack[top--];
        k++;
        for(int v=1;v&lt;=n;v++)    
            if(map[u][v]==1){//如果u到v有路径 则u属于v 
                ans[v]=u;
                for(int i=1;i&lt;=n;i++)
                if(map[i][v]==1){
                    map[i][v]=0; cd[i]--;
                    if(cd[i]==1)
                        stack[++top]=i;
                }
                break;
            }

    }while(top!=0);
    if(k!=n) printf(&quot;None&quot;);
    else
        for(int i=1;i&lt;=n;i++)
            printf(&quot;%c %d\n&quot;,&apos;A&apos;+i-1,ans[i]);

    return 0;
}
</code></pre><p>  <strong>关键路径：</strong> <strong>建立在一种新图上：AOV图（用点表示时间，边表示活动，边的权值表示活动持续的时间的一种图）</strong> <strong>四个重要的量</strong></p>
<ol>
<li><strong>事件最早发生时间ve[]</strong></li>
<li><strong>事件最晚发生时间vl[]</strong></li>
<li><strong>活动最早开始时间e[]</strong></li>
<li><strong>活动最晚开始时间l[]</strong></li>
</ol>
<p><strong>各个量的求法及求解顺序：</strong></p>
<ol>
<li><strong>Ve，以Ve[1]=0开始，所有起点u终点v都按照ve[v]=max(ve[v],ve[u]+dis[u][v])的方法进行计算，并且记录下拓扑序列</strong></li>
<li><strong>Vl，顺序：逆拓扑序列，以Vl[n]=Ve[n]开始，（因为终点是关键事件，所以最早和最晚开始时间相等）起点u终点v都按照vl[v]=min(vl[v],vl[u]-dis[u][v])的方法求解（此处注意，程序开头必须memset）</strong></li>
<li><strong>e，事件的最早发生时间就等于活动的最早开始时间</strong></li>
<li><strong>l，对于起点x终点y之间的活动i，l[i]=vl[y]-dis[x][y]</strong></li>
</ol>
<p><strong>如果e[i]==l[i]则说它是关键活动</strong> <strong>结束。</strong>  <strong>Question：活动的最早最晚开始时间和事件的最早最晚发生时间有什么关系，它们各自属于实际问题中的那一个量？（我只会求，但并不能完全明白它们的差别或者用途）</strong> <strong>前面奖金一题所用的方法是不是关键路径中的求事件最早发生时间？</strong> </p>
<h2 id="关键路径计算"><a href="#关键路径计算" class="headerlink" title="关键路径计算"></a>关键路径计算</h2><p>（<a href="http://fz.openjudge.cn/graph/015/）" target="_blank" rel="noopener">http://fz.openjudge.cn/graph/015/）</a> <strong>描述</strong> 给出一个AOE图，请输出其关键路径； <strong>输入</strong> 第一行：n，m（n,m&lt;=100分别表示节点个数与边的条数） 接下来m行，第i+1行，表示第i条边，每行三个数：ai,bi,ci，表示存在一条ai指向bi权值为ci的边。 注意：起点为结点1，终点为结点n <strong>输出</strong> 将关键路径的边的编号从小到大输出 <strong>样例输入</strong> 9 11 1 2 6 1 3 4 1 4 5 2 5 1 3 5 1 4 6 2 5 7 9 5 8 7 6 8 4 7 9 2 8 9 4 <strong>样例输出</strong> 1 4 7 8 10 11 <strong>标准问题，注意在输出之前要排序</strong></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=1000;
int first[MAX],go[MAX],nxt[MAX],dis[MAX][MAX],arcnum=1;
int stack[MAX],top,ve[MAX],vl[MAX],e[MAX],l[MAX],rd[MAX];
int order[MAX],ans[MAX],sum;
void addarc(int a,int b,int c){
    nxt[arcnum]=first[a];
    first[a]=arcnum;
    go[arcnum++]=b;
    dis[a][b]=c;
}
int main(){
//    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    int n,m,a,b,c,k=0;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    memset(vl,127,sizeof(vl));
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        addarc(a,b,c);
        rd[b]++;
    }
    for(int i=1;i&lt;=n;i++)
        if(rd[i]==0)
            stack[++top]=i;//入栈 
    do{//第一次，求事件最早发生时间 
        int u=stack[top--],v; k++;
        order[k]=u;//记录顺序 
        for(int p=first[u];p!=0;p=nxt[p]){
            v=go[p]; rd[v]--;
            ve[v]=max(ve[v],ve[u]+dis[u][v]);
            if(rd[v]==0)
                stack[++top]=v;
        }
    }while(top!=0);

    vl[n]=ve[n];//中点的事件最晚发生时间等于最早发生时间 
    for(int i=n-1;i&gt;=1;i--){
        int u=order[i],v;
        for(int p=first[u];p!=0;p=nxt[p]){
            v=go[p];
            vl[u]=min(vl[u],vl[v]-dis[u][v]);
        }
    }

    for(int i=1;i&lt;=n-1;i++){//计算活动的最早发生时间和最晚发生时间 
        int u=order[i],v;
        for(int p=first[u];p!=0;p=nxt[p]){
            v=go[p];
            e[p]=ve[u];//活动最早发生时间等于起始点的最早发生时间 
            l[p]=vl[v]-dis[u][v];//活动最晚发生时间等于终点最晚发生时间减去活动的长度 
            if(e[p]==l[p]) ans[++sum]=p;
        }
    }

    sort(ans+1,ans+1+sum);
    for(int i=1;i&lt;=sum;i++)
        printf(&quot;%d\n&quot;,ans[i]);
    return 0;
}
</code></pre><h1 id="HDU4109-Instrction-Arrangement"><a href="#HDU4109-Instrction-Arrangement" class="headerlink" title="HDU4109 Instrction Arrangement"></a>HDU4109 Instrction Arrangement</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4109" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4109</a> <strong>Problem Description</strong> 阿狸这个学期学了计算机组织结构课程。他知道了指令之间可能有依存关系，像WAR（write after read，读之后写），WAW，RAW。如果两个指令之间的时间小于安全时间，它就会导致危险，从而引起错误的结果。所以我们需要设计特殊的回路去消除危险。然而，解决这个问题最简单的方法是添加等待时间（或者由其它的操作填充），如果没有其它的操作填充就意味着需要浪费时间去保证两个指令之间的时间不小于安全时间。 两个指令之间的时间的定义就是它们起始时间差。 现在我们有很多指令，并且我们知道依存关系和指令之间的安全事件。我们也有非常强大的无限核的CPU。所以你可以在同一时间想跑多少指令就跑多少指令。这个CPU可以只消耗1ns就完成任何指令。 你的工作就是重新安排这些指令顺序所以CPU就可以用最短时间完成所有的指令。 <strong>Input</strong> 输入包括几个测试案例 头两行有两个整数N,M（N&lt;=1000,M&lt;=1000），其中N表示N条指令和M表示M个依存关系 接下来的M行，每行包括3个整数X,Y,Z，意思是X和Y之间的安全时间是Z，而且Y必须在X之后运行。这些指令从0到N-1标号。 <strong>Output</strong> 打印一个整数，CPU运行的最短时间 <strong>Sample Input</strong> 5 2 1 2 1 3 4 1 <strong>Sample Output</strong> 2 <strong>HINT</strong> 在第1ns中，指令0，1和3被执行了。 在第2ns中，指令2,和4被执行了 所以答案是2 <strong>也是求事件最早发生时间（这些指令什么时候最早全部执行完）的题</strong> <strong>注意：</strong></p>
<ol>
<li><strong>memset！！！！！！！</strong></li>
<li><p><strong>指令由0到n-1编号，注意转换</strong></p>
<p>#include<cstdio><br>#include<cstring><br>#include<algorithm><br>using namespace std;<br>const int MAX=1020;<br>int first[MAX],nxt[10200],go[10200],arcnum;<br>int dis[MAX][MAX],rd[MAX],val[MAX],stack[10200],top;<br>void addarc(int a,int b,int c){</algorithm></cstring></cstdio></p>
<pre><code>nxt[arcnum]=first[a];
first[a]=arcnum;
go[arcnum++]=b;
dis[a][b]=c;
</code></pre><p>}</p>
<p>int main()<br>{<br>//    freopen(“in.txt”,”r”,stdin);</p>
<pre><code>int n,m,x,y,z,maxx;
while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){
    memset(dis,0,sizeof(dis));
    memset(rd,0,sizeof(rd));
    memset(val,0,sizeof(val));
    memset(first,0,sizeof(first));
    maxx=-1; arcnum=1;
    for(int i=1;i&lt;=n;i++)
        val[i]=1;
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
        addarc(++x,++y,z);
        rd[y]++;
    }
    for(int i=1;i&lt;=n;i++)    
        if(rd[i]==0)
            stack[++top]=i;
    do{
        int u=stack[top--],v;
        for(int p=first[u];p!=0;p=nxt[p]){
            v=go[p];
            val[v]=max(val[v],val[u]+dis[u][v]);
            maxx=max(val[v],maxx);
            if(--rd[v]==0)
                stack[++top]=v;
        }

    }while(top!=0);
    printf(&quot;%d\n&quot;,maxx);
}
return 0;
</code></pre><p>}</p>
<p><strong>Poj3687 Labeling Balls</strong> <strong>escription</strong> Windy有N个不同重量的求，现在他打算给他们贴上1到N的标签： 没有两个相同的球 这些标签要符合规则例如“标签a球轻于标签b球” 你能帮他解决这个问题吗？ <strong>Input</strong> 第一行是数据个数.每组数据第一行是两个整数： N (1 ≤ N ≤ 200)和 M (0 ≤ M ≤ 40,000).接下来M行，每行两个整数a和 b表示 标签a球轻于标签b球. (1 ≤ a, b ≤ N) 每组数据后有一个空行 <strong>Output</strong> 每组测试数据输出一行，按照小球的1~N，小球的重量输出，如果有多组解： you should output the one with the smallest weight for label 1, then with the smallest weight for label 2, then with the smallest weight for label 3 and so on…如果无解，输出-1。 <strong>Sample Input</strong> 5 4 0 4 1 1 1 4 2 1 2 2 1 4 1 2 1 4 1 3 2 <strong>Sample Output</strong> 1 2 3 4 -1 -1 2 1 3 4 1 3 2 4 <strong>这道题至今未通过。初步思路是建立小顶堆和拓扑排序，以便在几个球重量相等时输出编号最小的。</strong> <strong>但是问题来了，在我操作入度为0的节点时，可能会又有新的节点加入堆，从而导致我整个答案完全不对。</strong></p>
<p>#include<cstdio><br>#include<cstring><br>#include<algorithm><br>using namespace std;<br>int first[300],nxt[40200],go[40200],arcnum;<br>int rd[300],stack[40200],ans[300],heap[10000],len;<br>void addarc(int a,int b){</algorithm></cstring></cstdio></p>
<pre><code>nxt[arcnum]=first[a];
first[a]=arcnum;
go[arcnum++]=b;
</code></pre><p>}</p>
<p>bool cmp(int a,int b){</p>
<pre><code>return a&lt;b;
</code></pre><p>}</p>
<p>int Get(){</p>
<pre><code>int t=heap[1],now=1,next;
heap[1]=heap[len--];
while(now*2&lt;=len){
    next=now*2;
    if(next&lt;len&amp;&amp;cmp(heap[next+1],heap[next])) next++;
    if(cmp(heap[now],heap[next])) break;
    swap(heap[now],heap[next]);
    now=next;
}
return t;
</code></pre><p>}</p>
<p>void Put(int p){</p>
<pre><code>int now=++len,next;
heap[len]=p;
while(now&gt;1){
    next=now&gt;&gt;1;
    if(!cmp(heap[now],heap[next])) break;
    swap(heap[now],heap[next]);    
    now=next;
}
</code></pre><p>}</p>
<p>int main()<br>{</p>
<pre><code>int t,n,m,a,b,k;
scanf(&quot;%d&quot;,&amp;t);
while(t--){
    arcnum=1; k=0; len=0;
    memset(first,0,sizeof(first));
    memset(rd,0,sizeof(rd));
    memset(ans,0,sizeof(ans));
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        addarc(a,b);
        rd[b]++;
    }
    for(int i=1;i&lt;=n;i++)
        if(rd[i]==0)
            Put(i);
    do{
        int u=Get(),v;
        ans[u]=++k;
        for(int p=first[u];p!=0;p=nxt[p]){
            v=go[p];
            if(--rd[v]==0)
                Put(v);
        }
    }while(len&gt;0);
    if(k!=n) printf(&quot;-1\n&quot;);
    else{
        for(int i=1;i&lt;=n;i++)
            printf(&quot;%d &quot;,ans[i]);
        printf(&quot;\n&quot;);
    }
}

return 0;
</code></pre><p>}</p>
</li>
</ol>
<p><strong>又想到把拓扑排序后的点记录下来，来个快排，但是有的球没有限制条件，强行把权设为0又会错。</strong></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int first[300],nxt[40200],go[40200],arcnum;
int rd[300],stack[40200],top;
struct node{
    int val,id;
}ans[300];

void addarc(int a,int b){
    nxt[arcnum]=first[a];
    first[a]=arcnum;
    go[arcnum++]=b;
}

bool cmp(node a,node b){
    if(a.val!=b.val)
        return a.val&lt;b.val;
    return a.id&lt;b.id;
}

int main()
{
    int t,n,m,a,b,k;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        arcnum=1; k=0; top=0;
        memset(first,0,sizeof(first));
        memset(rd,0,sizeof(rd));
        memset(ans,0,sizeof(ans));
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i=1;i&lt;=n;i++)
            ans[i].id=i,ans[i].val=0;
        for(int i=1;i&lt;=m;i++){
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            addarc(a,b);
            rd[b]++;
        }
        for(int i=1;i&lt;=n;i++)
            if(rd[i]==0)
                stack[++top]=i;
        do{
            int u=stack[top--],v;
            k++;
            for(int p=first[u];p!=0;p=nxt[p]){
                v=go[p];
                ans[v].val=max(ans[v].val,ans[u].val+1);
                if(--rd[v]==0)
                    stack[++top]=v;
            }
        }while(top!=0);
        if(k!=n) printf(&quot;-1\n&quot;);
        else{
            sort(ans+1,ans+1+n,cmp);
            for(int i=1;i&lt;=n;i++)
                printf(&quot;%d &quot;,ans[i].id);
            printf(&quot;\n&quot;);
        }
    }

    return 0;
}
</code></pre><p><strong>据说建立大顶堆就可以解决问题？？？？</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-8b-93-e6-89-91-e6-8e-92-e5-ba-8f-e4-bb-a5-e5-8f-8a-e5-85-b3-e9-94-ae-e8-b7-af-e5-be-84-e6-80-bb-e7-bb-93/" data-id="cjv7zzedp003zuoet3sv0ff8n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93/" class="article-date">
  <time datetime="2018-12-06T15:41:33.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93/">最小生成树总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  啊，先纪念一下吧，难得一天这么666 AC完了所有题 （次小生成树代码看懂） 今天学到了最小生成树算法中的Prim算法和Kruskal算法。从宏观上来讲prim更适合稠密图，krustal更适合稀疏图，但对于我们来说暂时没有什么区别啦。 Prim算法中主要注意的点是</p>
<ol>
<li><strong>在visit数组与minn数组（最小到达某点的权边的权值）上 注意只有未遍历而且小于当前所存的权才可以更新</strong></li>
<li><strong>循环次数为n-1次，错误的次数会导致答案错误</strong></li>
<li><strong>除自身为0以外，所有点之间的初始距离为正无穷</strong> </li>
</ol>
<p><strong>Kruskal算法中主要注意的点是</strong></p>
<ol>
<li><strong>所有的边要用结构体存，方便快排</strong></li>
<li><strong>注意并查集的Getfather函数的压缩路径和union函数的是否父亲相同的判断</strong></li>
<li><strong>注意变量k的维护，k满足k==n-1时必须及时跳出循环</strong></li>
</ol>
<p><strong> 还有一个很容易忽略的问题！！就是memset，特别是有多组数据的时候必须在前面重置内存</strong> 附上我对次小生成树代码的注释：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
using namespace std;

/*
 * 次小生成树
 * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权
 * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案
 * 点的编号从0开始
 */
const int MAXN=110;
const int INF=0x3f3f3f3f;//最大值 
bool vis[MAXN];//点是否已使用 
int lowc[MAXN];//到每一个点权值最短的路径的权值 
int pre[MAXN];//存父亲 
int Max[MAXN][MAXN];//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权
bool used[MAXN][MAXN];//边是否已使用 
int Prim(int cost[][MAXN],int n){
    int ans=0;
    memset(vis,false,sizeof(vis));
    memset(Max,0,sizeof(Max));
    memset(used,false,sizeof(used));
    vis[0]=true;//已遍历 
    pre[0]=-1;//起始点没有父亲 
    for(int i=1;i&lt;n;i++){
        lowc[i]=cost[0][i];
        pre[i]=0;//设置父亲 
    }
    lowc[0]=0;
    for(int i=1;i&lt;n;i++){
        int minc=INF;
        int p=-1;//将要选择的下一个点 
        for(int j=0;j&lt;n;j++)
            if(!vis[j]&amp;&amp;minc&gt;lowc[j]){
                minc=lowc[j];//选择距离最小的边 
                p=j;
            }
        if(minc==INF) return -1;//该图不是连通图 
        ans+=minc;//权值和计算 
        vis[p]=true;//点已遍历 
        used[p][pre[p]]=used[pre[p]][p]=true;//边已遍历 
        for(int j=0;j&lt;n;j++){
            if(vis[j]) Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);//DP计算j到p的路径中权值最大的边的权值 
            if(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j]){//更新lowc数组 
                lowc[j]=cost[p][j];
                pre[j]=p;//设置父亲 
            }
        }
    }
    return ans;
}
int ans;
int smst(int cost[][MAXN],int n){
    int Min=INF;
    for(int i=0;i&lt;n;i++)
        for(int j=i+1;j&lt;n;j++)
            if(cost[i][j]!=INF &amp;&amp; !used[i][j])//如果这条边存在而且未被使用 
                Min=min(Min,ans+cost[i][j]-Max[i][j]);//取最小差值 
    if(Min==INF) return -1;//不存在
    return Min;//返回次小生成树的权值和 
}
int cost[MAXN][MAXN];
int main(){
    int T;
    int n,m;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--){
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        int u,v,w;
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++){
                if(i==j) cost[i][j]=0;
                else cost[i][j]=INF;
            }
        while(m--){
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            u--;v--;
            cost[u][v]=cost[v][u]=w;//u到v的距离 
        }
        ans=Prim(cost,n);
        if(ans==-1){
            printf(&quot;Not Unique!\n&quot;);
            continue;
        }
        if(ans==smst(cost,n)) printf(&quot;Not Unique!\n&quot;);//权值和完全相同 
        else printf(&quot;%d\n&quot;,ans);//输出最小生成树的权值和 
    }
    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93/" data-id="cjv7zzec8001duoetsai8rogg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93/" class="article-date">
  <time datetime="2018-12-06T15:40:34.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93/">暑期人生测试一总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>**暑期测试一** **数学作业** **（homework.cpp）** **【问题描述】** 求：方程x1+2x2+„+nxn=m的所有非负整数解（x1,x2,„,xn）的个数。例如，方程：x1+2x2+3x3+4x4+5x5=5有7组解：（5,0,0,0,0）、（3,1,0 ,0,0）、……、（0,0,0,0,1）。 **【输入数据】(homework.in)** 2个整数n，m **【输出数据】(homework.out)** 方程非负整数解的个数ans，如果解超过10^9，只需输出ansmod 10^9。 **【输入样例】** 55 **【输出样例】** 7 **【数据范围】** 1≤n≤5000；0≤m≤5000。 这道题可以将方程中的x1x2.....看作n个有价值的物品，要使这个方程刚好有解，则我们可以联想到完全背包问题中找方案类型的题目。抽象出来则可以描述为：有n件物品，重量依次为1到n，要将这些物品放入背包且刚好装满背包，求总方案数。接着粘上标准代码，AC； 注意！！！！！！每次状态转移后记得将求解的子问题答案Mod 10^9！！ 否则变量爆掉！！ 

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
long long f[10000];
int main()
{
    freopen(&quot;homework.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;homework.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    if(m==0){
        printf(&quot;1&quot;);
        return 0;
    }

    f[0]=1;
    for(int i=1;i&lt;=n;i++)
        for(int j=i;j&lt;=m;j++)//分配i到m个空间 
            f[j]=(f[j]+f[j-i])%1000000000;        
    printf(&quot;%lld&quot;,f[m]);

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p><strong>魔法石的诱惑</strong> <strong>（rob.cpp）</strong> <strong>问题描述</strong> 修罗魔王远远地看见邪狼王狂奔而来，问道：“慌慌张张干什么？” 邪狼王大口大口初期：“我路过一家魔法石店，看到摆着那么多高阶魔法石，我就去抢了一大袋。” 修罗王怒道：“光天化日之下，朗朗乾坤，众目睽睽之下，你也敢抢？” 狼王：“我只看到了魔法石，没有看到人。。。” 修罗王：“。。。。。” 其实邪狼王的贪婪也很容易理解，因为高阶魔法石有一个特征，即它的重量进行阶乘运算后末尾有几个0，就拥有同等重量普通魔法石几倍的法力，例如5！=5*4*3*2*1=120,所以120有一个0，这意味着该魔法石拥有同等重量的普通魔法石1倍的魔法力，你的任务是找到最小的自然数N，使N！在十进制下有Q个0结尾。   <strong>输入格式(rob.in)</strong> 一个数Q（0≤Q≤10^8） <strong>输出格式(rob.out)</strong> 如果无解，输出”No solution”，否则输出N <strong>输入样例</strong> 2 <strong>输出样例</strong> 10 二分枚举答案，同时算出该数的阶乘所包含的0的个数 如何算阶乘中0的个数：10由2*5组成，阶乘中2远远大于5，所以只用关注5的个数，注意25 125等数中包含多个5，需要另行判断 枚举答案后还获得最优解，要进行判断处理才得出最优解  </p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int Q;

int DuiShu(int n){//取以5为底，n的对数 
    int pre=1,nxt=5;
    for(int i=0;i&lt;=20;i++){
        if(n&gt;=pre&amp;&amp;n&lt;nxt) return i;
        pre*=5; nxt*=5;
    }
}

int calc(int n){//计算n的阶乘有多少个5
    int ds=DuiShu(n),sum=0;//取对数

    int pre=5,nxt=25;
    for(int i=1;i&lt;=ds;i++){//每5^i个数产生一个0
        sum+=n/pre;
        pre*=5; nxt*=5;
    }
    return sum;
} 

int BinarySearch(int s,int e){//二分查找最佳答案 
    int mid,ans;
    while(s&lt;=e){
        mid=(s+e)/2;
        ans=calc(mid);
        if(ans==Q)
            return mid;
        else if(ans&gt;Q)//0多了 
            e=mid-1;
        else if(ans&lt;Q)//0少了
            s=mid+1;
    }
    return -1;
}

int FindBest(int ans){
    if(ans%5!=0)//如果不是最优解
        ans=ans-(ans%5);
    return ans;
}

int main()
{
    freopen(&quot;rob.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;rob.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;Q);
    if(Q==0){
        printf(&quot;1&quot;);
        return 0;
    }
    int ans=BinarySearch(5,200000000);
    if(ans==-1)
        printf(&quot;No solution&quot;);
    else
        printf(&quot;%d&quot;,FindBest(ans));

//    printf(&quot;%d&quot;,DuiShu(30));//测试 

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>
<p>  <strong>架设电话线</strong> <strong>(phoneline.cpp)</strong> FarmerJohn打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。 FJ的农场周围分布着N(1&lt;= N &lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1&lt; = P &lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。 第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为L_i(1 &lt;= L_i &lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。 经过谈判，电信公司最终同意免费为FJ连结K(0 &lt;= K &lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过K对，那么FJ的总支出为0。 请你计算一下，FJ最少需要在电话线上花多少钱。 <strong>输入(phoneline.in)</strong> * 第1行: 3个用空格隔开的整数：N，P，以及K <em> 第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i <strong>输出(phoneline.out)</strong> \</em> 第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成，输出-1 <strong>样例输入</strong> 5 7 1 1 2 5 3 1 4 2 4 8 3 2 35 2 9 3 4 7 4 5 6 <strong>样例输出</strong> 4 <strong>提示</strong> 输入说明: 一共有5根废弃的电话线杆。电话线杆1不能直接与电话线杆4、5相连。电话线杆5不能直接与电话线杆1、3相连。其余所有电话线杆间均可拉电话线。电信公司可以免费为FJ连结一对电话线杆。 输出说明: FJ选择如下的连结方案：1-&gt;3；3-&gt;2；2-&gt;5，这3对电话线杆间需要的电话线的长度分别为4、3、9。FJ让电信公司提供那条长度为9的电话线，于是，他所需要购买的电话线的最大长度为4。 这么明显的二分加最短路算法竟然没想到！！！ 1.首先二分枚举一个电话线长度标准aim，大于此标准的线交给电信部门，自己支付aim元 2.生成带权边，由于要使电信公司刚好支付大于aim的所有线的费用，所以John选择的最佳路线中长度大于aim的电话线数量应该刚好等于K，即大于aim权边为1否则为0，使权和为K即可。权和大于K则表示aim太小，小于K则表示aim太大 3.做SPFA最短路径，结合二分法得出答案</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93/" data-id="cjv7zzec9001fuoet6w8aphqq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:39:25.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3/">打印月历题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="24-打印月历"><a href="#24-打印月历" class="headerlink" title="24:打印月历"></a>24:打印月历</h2><p>总时间限制: 1000ms   内存限制: 65536kB 描述 给定年月，打印当月的月历表。 输入 输入为一行两个整数，第一个整数是年份year（1900 ≤ year ≤ 2099），第二个整数是月份month（1 ≤ month ≤ 12），中间用单个空格隔开。 输出 输出为月历表。月历表第一行为星期表头，如下所示： Sun Mon Tue Wed Thu Fri Sat 其余各行一次是当月各天的日期，从1日开始到31日（30日或28日）。 日期数字应于星期表头右对齐，即各位数与星期表头相应缩写的最后一个字母对齐。日期中间用空格分隔出空白。 样例输入 2006 5 样例输出 Sun Mon Tue Wed Thu Fri Sat 1   2   3   4   5   6 7   8   9  10  11  12  13 14  15  16  17  18  19  20 21  22  23  24  25  26  27 28  29  30  31 提示 闰年判断方法：能被4整除但不能被100整除，或者能被400整除。 1900年1月1日是周一。     题解： 这道题是典型的模拟日期变更的题目。为了节省时间提高效率，可把目标年份的1月1日的星期算出来，然后通过循环模拟，最终算出目标月份的1日的星期。 计算部分在本题还算简单，但重要的是如何输出。 首先输出固定格式， 我们知道日历的开头通常都是有空格的（1日是星期天除外），由此我们可以写循环来输出日历前面的空格。 接下来依次输出每个日期，这里又会有个问题，就是换行的问题，这个问题可以通过声明一个变量判断日历是否打印到行尾，是就换行，不是就输出空格。 还有一点细节需要注意，当日期到最后一天时，是不允许有空格出现的，所以我们应该在最后加一个条件判断，这样程序就完整了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;

int main()
{
    int year,month;
    scanf(&quot;%d %d&quot;,&amp;year,&amp;month);
    int day=1;
    for(int i=1;i&lt;=year-1900;i++)
    {
        int sum=1900+i-1;
        if((sum%4==0&amp;&amp;sum%100!=0)||sum%400==0)
            day+=2;
        else
            day++;
        if(day&gt;=8)
            day-=7;
    }


    for(int i=1;i&lt;month;i++)
    {
        if(i!=2)
        {
            switch(i)
            {
                case 1:case 3:case 5:case 7:case 8:case 10:case 12:day+=31%7;break;
                case 4:case 6:case 9:case 11:day+=30%7;break;

            }
        }
        else
        {
            if((year%4==0&amp;&amp;year%100!=0)||year%400==0)
                day+=29%7;
            else
                day+=28%7;
        }
        if(day&gt;=8)
            day-=7;
    }

    int count;
    if(month!=2)
    {
        switch(month)
        {
            case 1:case 3:case 5:case 7:case 8:case 10:case 12:count=31;break;
            case 4:case 6:case 9:case 11:count=30;break;
        }
    }
    else
    {
        if((year%4==0&amp;&amp;year%100!=0)||year%400==0)
            count=29;
        else
            count=28;
    }

    printf(&quot;Sun Mon Tue Wed Thu Fri Sat\n&quot;);
    for(int i=day==7?0:day;i!=0;i--)
    {
        printf(&quot;    &quot;);
    }
    int n=day;
    for(int i=1;i&lt;=count;i++)
    {
        if(i&lt;=9)
            printf(&quot;  %d&quot;,i);
        else
            printf(&quot; %d&quot;,i);
        if(i==count)
            ;
        else if(n%7==6)
            printf(&quot;\n&quot;);
        else
            printf(&quot; &quot;);
        n++;
    }

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3/" data-id="cjv7zzec6001auoetprcwu0mg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:39:02.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3/">大整数乘法题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>09:大整数乘法</strong> 总时间限制: 1000ms 内存限制: 65536kB 描述 求两个不超过200位的非负整数的积。 输入 有两行，每行是一个不超过200位的非负整数，没有多余的前导0。 输出 一行，即相乘后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。 样例输入 12345678900 98765432100 样例输出 1219326311126352690000 来源 程序设计实习2007 <strong>题解：</strong> <strong>        这道题的参数过大，甚至不能用长整型变量解决，那么就应该使用高精度算法。我们曾经写过高精度加法，本题算法只是高精度加法的延伸。</strong> <strong>将两个数用字符串数组读入，再转化成整型数组储存，此时储存顺序应该为倒序，即第一位用来存放个位，第二位存放十位，以此类推……（这样的目的是在于它能方便我们进位时的数据存放），好了这里有一个问题，题目并没有提到输入数据中不是先序0（如00003、0000等），所以这里可以添加判断语句只截取有意义的部分（当然也可以在计算之后判断再最高位的数字，如果为0则不输出）</strong> <strong>       接下来是整个算法的核心部分！！我们知道，高精度加法是对应位相加，如果结果大于等于10则进一位，然而乘法只是加法的一个高级形式而已，所以我们也可以将此高精度乘法转化为多个高精度加法，即a数中的每一位数去乘b数中的每一位数，最后求和。</strong> <strong>       经过观察，我们可以发现，当我们将某x位的数乘某y位的数时，两个数除了最高位之外其余位都为0，运算结果为两数之积，而它所在的位数为x+y，用两个for循环，就可以实现a数中的每一位数去乘b数中的每一位数。而得到的结果则ans[x+y]+=两数之积 ，这样就得到了未进位的两大数相乘的结果（源码中我使用了进位，实际上可以删除）。</strong> <strong>       最后一步，进位操作。从最低位算起</strong> <strong>ans[i+1]=ans[i]/10;</strong> <strong>ans[i]%=10;</strong> <strong>输出。AC！！喜悦！！</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

int a[300],b[300],ans[1000];
int work(int n,bool t)//n输入的字符（数字） t是否转换成数字 
{//字符与数字的转换函数 
    if(t==1)
        return n-&apos;0&apos;;
    else
        return &apos;0&apos;+n;
}

int main()
{
    char c[300];
    int len_a,len_b;
    gets(c);
    len_a=strlen(c);
    for(int i=len_a;i&gt;=1;i--)
        a[len_a-i]=work(c[i-1],1);//以倒序整型读入两个数
    gets(c);
    len_b=strlen(c);    
    for(int i=len_b;i&gt;=1;i--)
        b[len_b-i]=work(c[i-1],1);

    int ji;    //对两个数进行操作，但不进位，保存在ans[]中 
    for(int i=0;i&lt;=len_a-1;i++)
        for(int j=0;j&lt;=len_b-1;j++)
        {
            ji=a[i]*b[j];
            ans[i+j+1]+=ji/10;
            ans[i+j]+=ji%10;//此处累赘，可以不用进位，到最后一同进位 
        }

    int j=0,log;
    while(j&lt;=len_a+len_b-2)//进位操作 
    {
        log=ans[j];
        if(log&gt;=10)
        {
            ans[j]=log%10;
            ans[j+1]+=log/10;
        }
        j++;
    }
    /*if(ans[len_a+len_b-2]==0)
        j--;*/
    while(ans[j]==0&amp;&amp;j&gt;=0)
        j--;
    if(j==-1)
        j++;
    for(int i=j;i&gt;=0;i--)//输出数字
        printf(&quot;%c&quot;,work(ans[i],0));

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3/" data-id="cjv7zzebl000guoetshnx3glw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:38:31.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3/">2的幂次方表示题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="8758-2的幂次方表示"><a href="#8758-2的幂次方表示" class="headerlink" title="8758:2的幂次方表示"></a>8758:2的幂次方表示</h2><p>总时间限制: 1000ms 内存限制: 65536kB 描述 任何一个正整数都可以用2的幂次方表示。例如： 137=27+23+20 同时约定方次用括号来表示，即ab可表示为a(b)。由此可知，137可表示为： 2(7)+2(3)+2(0) 进一步：7=22+2+20（21用2表示） 3=2+20 所以最后137可表示为： 2(2(2)+2+2(0))+2(2+2(0))+2(0) 又如： 1315=210+28+25+2+1 所以1315最后可表示为： 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) 输入 一个正整数n（n≤20000）。 输出 一行，符合约定的n的0，2表示（在表示中不能有空格）。 样例输入 137 样例输出 2(2(2)+2+2(0))+2(2+2(0))+2(0) 来源 NOIP1998复赛 普及组 第一题     <strong>题解：将一个大数拆分为若干个2的n次方的和，并且将次方和再拆分成若干个部分，这样很容易就可以想起递归算法。</strong> <strong>       实际上问题大致分为两步：</strong> <strong>1.    将数字分解为2的n次方</strong> <strong>2.    将n再次分解为2的n次方（调用自身，如果n==2则结束printf(“2”);</strong> <strong>如果n==1 则printf(“2(0)”);）</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;


void work(int n)
{
    if(n==1)//初始判断条件，如果n为1或2则直接输出 
    {
        printf(&quot;2(0)&quot;);
        return;
    }
    else if(n==2)
    {
        printf(&quot;2&quot;);
        return; 
    } 
    else
    {
        int j=1,i=0;//j每次乘2,如果大于了n就分解结束，i为当前次数 
        do
        {
            j*=2;
            if(j&gt;n)
            {
                j/=2;
                if(i==1)//这步非常重要，确定是否需要继续 2() 
                    printf(&quot;2&quot;);
                else
                {
                    printf(&quot;2(&quot;);
                    work(i);
                    printf(&quot;)&quot;);
                }    
                if(n-j!=0)//如果n分解之后还有剩余的数，那么继续分解 
                {
                    printf(&quot;+&quot;);
                    work(n-j);
                }
                return;
            }
            else
                i++;


        }while(1);
    }    


}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    work(n);
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3/" data-id="cjv7zzec40018uoetxahxb0o8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:38:07.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3/">逆波兰表达式题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1696-逆波兰表达式"><a href="#1696-逆波兰表达式" class="headerlink" title="1696:逆波兰表达式"></a>1696:逆波兰表达式</h2><p>  总时间限制: 1000ms 内存限制: 65536kB 描述 逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) <em> 4的逆波兰表示法为</em> + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - <em> /四个。 输入 输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 输出 输出为一行，表达式的值。 可直接用printf(“%f\n”, v)输出表达式的值v。 样例输入 </em> + 11.0 12.0 + 24.0 35.0 样例输出 1357.000000 提示 可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。 此题可使用函数递归调用的方法求解。 来源 计算概论05     <strong>题解：看到逆波兰表达式，首先我们要详细了解逆波兰表达式的用法。通过观察，我们可以大致明白一个逆波兰表达式是由</strong> <strong>表达式=符号(+,-,*,/)  + 数字1（或子表达式） +   数字2（或子表达式）</strong> <strong>组成的，每个子表达式只需要两个参数的输入，所以参数的读入可以在运算时进行，以避免不知道读入数据的个数。PS：我做题时用while(getchar()!=‘ ’) scanf(“%d”,a) 做直接超时！（因为数据已经输入完成，而程序还在等待输入）</strong>  <strong>既然我们有了表达式到子表达式的过程，那么这其实是一个递归的过程，可以写一个递归的函数来处理问题。结束条件无需定义，因为每个子表达式只需两个参数，输入两个参数自动结束。</strong> <strong>      读入一个字符串，判断它是否为数字，如果为数字便直接以双精度形式return atof(a)，数字的判断以a[0]是否属于数字为准；如果是一个符号，就继续调用自身，获取两个参数，运算后返回。return f(x) 运算(+,-,*,/) f(x)，用switch语句判断符号。</strong> <strong>      大致过程如下：</strong> <img src="http://img.blog.csdn.net/20160124153009539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动">​</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

int n=1;
char a[3000];
double work()
{
    scanf(&quot;%s&quot;,a);
    int len=strlen(a);
    if(len==1&amp;&amp;!(a[0]&gt;=&apos;0&apos;&amp;&amp;a[0]&lt;=&apos;9&apos;))
        switch(a[0])
        {
            case &apos;+&apos;:return work() + work();
            case &apos;-&apos;:return work() - work();
            case &apos;*&apos;:return work() * work();
            case &apos;/&apos;:return work() / work();
        }
    else
    {
        return atof(a);
    }
}

int main()
{
    printf(&quot;%f&quot;,work());
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3/" data-id="cjv7zzecd001ouoetwei8h45i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:37:40.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3/">Vigenère密码题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="08-Vigenere密码"><a href="#08-Vigenere密码" class="headerlink" title="08:Vigenère密码"></a>08:Vigenère密码</h2><p>总时间限制: 1000ms 内存限制: 65536kB 描述 16世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 在密码学中，我们称需要加密的信息为明文，用M表示；称加密后的信息为密文，用C表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为k。在Vigenère密码中，密钥k是一个字母串，k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中ci=mi®ki，运算®的规则如下表所示： <img src="http://img.blog.csdn.net/20160123190547906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动">​ Vigenère加密在操作时需要注意： 1. ®运算忽略参与运算的字母的大小写，并保持字母在明文M中的大小写形式； 2. 当明文M的长度大于密钥k的长度时，将密钥k重复使用。 例如，明文M=Helloworld，密钥k=abc时，密文C=Hfnlpyosnd。</p>
<p>明文</p>
<p>H</p>
<p>e</p>
<p>l</p>
<p>l</p>
<p>o</p>
<p>w</p>
<p>o</p>
<p>r</p>
<p>l</p>
<p>d</p>
<p>密钥</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>a</p>
<p>密文</p>
<p>H</p>
<p>f</p>
<p>n</p>
<p>l</p>
<p>p</p>
<p>y</p>
<p>o</p>
<p>s</p>
<p>n</p>
<p>d</p>
<p>  输入 输入共2行。 第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母。 对于100%的数据，输入的密钥的长度不超过100，输入的密文的长度不超过1000，且都仅包含英文字母。 输出 输出共1行，一个字符串，表示输入密钥和密文所对应的明文。 样例输入 CompleteVictory Yvqgpxaimmklongnzfwpvxmniytm 样例输出 Wherethereisawillthereisaway 来源 NOIP2012复赛 提高组 第一题 <strong>题解：注意本题是由密文解密为原文。由于密钥和密文需要进行相互运算，所以转换大小写是必不可少的，题目有要求原文大小写与密文一致，所以我们可以用一个数组</strong> <strong>int miwen_x[2000] 来储存原文大小写的数据</strong> <strong>读入密文、密钥，转换大小写并且记录密文的大小写状况</strong> </p>
<h2 id="接着就是解密数据了，让我们来观察一下Vigenere密码的规律吧"><a href="#接着就是解密数据了，让我们来观察一下Vigenere密码的规律吧" class="headerlink" title="接着就是解密数据了，让我们来观察一下Vigenère密码的规律吧"></a>接着就是解密数据了，让我们来观察一下Vigenère密码的规律吧</h2><p><img src="http://img.blog.csdn.net/20160123190547906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动">​</p>
<p><strong>本表指 一对密钥与原文可以加密成密文，现在要翻译密文，也就是知道对应的点，也知道了y轴坐标，求x轴坐标。</strong> <strong>1.</strong> <strong>当密文≥密钥时，我们发现数据是依次递增的，则此时ans[i]=</strong> <strong>miwen[i]-key[j]+’a’</strong> <strong>2.</strong> <strong>当密文&lt;密钥时，数据由最右端向左依次递减，此时ans[i]=</strong> <strong>‘z’-(key[j]-miwen[i]-1)</strong> <strong>j的意义在后面。</strong>  <strong>注意这里还有一个易错点，密钥的长度可能小于密文的长度，那么当密钥较短时就要运用循环多次使用此密钥</strong> <strong>int j=0;</strong> <strong>并且在每次循环后</strong> <strong>j++;</strong> <strong>if(j==strlen(key))</strong> <strong>      j=0;</strong> <strong>最后通过miwen_x[i]的值将原文的大小写形式恢复原样</strong> <strong>这样就解决此问题了</strong>  <strong>本题总思路：</strong> <strong>1.     读入密钥、密文并转换成小写（大写也可），同时记录密文的大小写情况</strong> <strong>2.     运用算法算出原文</strong> <strong>3.     通过大小写情况恢复原文的大小写</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

int change(int i)//大小写转换 
{
    return (i&gt;=&apos;A&apos;&amp;&amp;i&lt;=&apos;Z&apos;)?i+&apos;a&apos;-&apos;A&apos;:i;
}


int main()
{
    char key[120];
    char miwen[1200];
    int miwen_x[1200];//密文大小写 1小写 2大写 
    scanf(&quot;%s %s&quot;,key,miwen);
    int len=strlen(key);
    for(int i=0;i&lt;=len-1;i++)
        key[i]=change(key[i]);
    for(int i=0;i&lt;=strlen(miwen)-1;i++)
    {
        if(miwen[i]&gt;=&apos;A&apos;&amp;&amp;miwen[i]&lt;=&apos;Z&apos;)
            miwen_x[i]=2;
        else
            miwen_x[i]=1;
        miwen[i]=change(miwen[i]);
    }

    char ans[1200];
    int j=0;
    for(int i=0;i&lt;=strlen(miwen)-1;i++)
    {
        if(miwen[i]&gt;=key[j])
            ans[i]=miwen[i]-key[j]+&apos;a&apos;;
        else
            ans[i]=&apos;z&apos;-(key[j]-miwen[i]-1);
        if(miwen_x[i]==2)
            ans[i]=ans[i]-(&apos;a&apos;-&apos;A&apos;);
        j++;
        if(j==len)
            j=0;
    }
    ans[strlen(miwen)]=0;
    printf(&quot;%s&quot;,ans);


    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3/" data-id="cjv7zzech001vuoetlg2bkdvc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:36:10.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3/">铺地毯题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="14-铺地毯"><a href="#14-铺地毯" class="headerlink" title="14:铺地毯"></a>14:铺地毯</h2><p>总时间限制: 1000ms 内存限制: 65536kB 描述 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有n张地毯，编号从1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出样例1说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（2，2）的最上面一张地毯是3号地毯。 输入输出样例2说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（4，5）的最上面一张地毯是3号地毯。   输入 输入共n+2行。 第一行，一个整数n，表示总共有n张地毯。 接下来的n行中，第i+1行表示编号i的地毯的信息，包含四个正整数a，b，g，k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x轴和y轴方向的长度。 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标（x，y）。 对于30%的数据，有n≤2； 对于50%的数据，0≤a, b, g, k≤100； 对于100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。 输出 输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。 样例输入 样例 #1： 3 1 0 2 3 0 2 3 3 2 1 3 3 2 2   样例 #2： 3 1 0 2 3 0 2 3 3 2 1 3 3 4 5 样例输出 样例 #1： 3   样例 #2： -1 来源 NOIP2011复赛 提高组 第一题     题解 根据习惯性思维，看到这道题我们通常会建一个二维数组，用二维数组的每个元素来表示各个点的地毯覆盖情况。这样的方法可行，但是效率较低，不适合数据过大的运算，本题n&lt;=10000。 仔细审题，我们发现题目所需要的仅仅是一个点的地毯覆盖情况，所以撒大网的方式并不是最优的算法。 于是就考虑对于目标点单独进行操作，题目给出了毯子左下角的坐标，也给出了毯子的长宽，通过这两组数据我们就可以求到毯子的四个角所在的坐标，然后判断该点是否存在于此范围中，然后进行操作就可以了。 先建立一个二维数组，第一个下标表示毯子的次序，第二个下标分别用1,2,3,4来表示该毯子的左下角坐标a，b 和 长宽g，k int a[20020][4]; int log=-1 读入相应数据与目标点后，开始操作 循环判断目标点是否在相应毯子中，如果是则将负责记录的变量更新 for(int i=1;i&lt;=n;i++) if(x&lt;=a[i][1]+a[i][3]&amp;&amp;x&gt;=a[i][1]&amp;&amp;y&lt;=a[i][2]+a[i][4]&amp;&amp;y&gt;=a[i][2]) log=i; 如果无一个毯子符合条件，则log=-1 输出，AC！</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int main()
{
    int n;
    int a[10001][5];
    int x,y;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d %d %d %d&quot;,&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]);
    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);

    int log=-1;
    for(int i=1;i&lt;=n;i++)
        if(x&lt;=a[i][1]+a[i][3]&amp;&amp;x&gt;=a[i][1]&amp;&amp;y&lt;=a[i][2]+a[i][4]&amp;&amp;y&gt;=a[i][2])
            log=i;

    printf(&quot;%d&quot;,log);

    return 0;
}
</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt title="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3/" data-id="cjv7zzece001puoetk98chxpe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3/" class="article-date">
  <time datetime="2018-12-06T15:33:09.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3/">螺旋矩阵题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  螺旋矩阵 (matrix.cpp) 【问题描述】 一个n行n列的螺旋矩阵可由如下方法生成： 从矩阵的左上角（第1行第1列）出发，初始时向右移动；如果前方是未曾经过的格子， 则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入1, 2, 3, … , n2，便构成了一个螺旋矩阵。 下图是一个n = 4 时的螺旋矩阵。  现给出矩阵大小n以及i和j，请你求出该矩阵中第i行第j列的数是多少。   【输入】 输入文件名为matrix.in。 输入共一行，包含三个整数n，i，j，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。   【输出】 输出文件名为matrix.out。 输出共一行，包含一个整数，表示相应矩阵中第i行第j列的数。   【输入输出样例】 matrix.in matrix.out 4 2 3 14   【数据说明】 对于50%的数据，1 ≤ n ≤ 100; 对于100%的数据，1 ≤ n ≤ 30,000，1 ≤ i ≤ n，1 ≤ j ≤ n</p>
<blockquote>
<p>首先看到这个题目 能想到的是数字由内而外的螺旋矩阵，就可以从内圈开始逐步模拟推出各个方框的数字，最后得出结果。 这样就可以得到规律：以左上角为坐标原点，向下为y轴正半轴，向右为x轴正半轴。 当n为偶数时，起点在(n/2+1,(n+1)/2)处。 当n为奇数时，起点在((n+1)/2, (n+1)/2)处。 那么就令int x,y为相应的数作为起点坐标，旋转规律如下： 数字递减的方向由 右 上 左 下的顺序进行旋转，每次改变方向，该点便沿此方向平移k次，然后再旋转，平移k（k=1）次，然后旋转，此时平移k+1次，以此类推，方向每改变两次，k=k+1。 运用int dir来储存方向 dir/4=1,2,3,4为每次平移的方向。 建立循环 for(int p=n;p&gt;=1;p–) 将矩阵枚举出来后，就可以输出相应点的值了。 但是本题n&lt;=30000 那么数组就要开9*10^8，既浪费空间也浪费时间，而且无法开出，所以这种方法在本题只适用前50%的数据。 那么怎么在不开数组、尽量不计算无关点的值就得出目标值呢？ 通过观察，发现矩阵是由n/2层构成，每层格数相差2格，对顶角上的点的值变化也有规律，如果我们找到了目标点所在的层数，就能通过较少的平移求出答案，而不是浪费资源。 至于层数的寻找，在i,j∈n/2时是容易的， i,j中的最小值即为层数，层数ceng=i&gt;j?j:i。 如果目标在其他位置，可通过对称的方式用相同的方法求出层数。 当i&gt;n/2 i’=1+(n-i) j同理。 接下来可求到此层左上角的点的值： int p=1 for(int m=1;m&lt;=ceng;m++) P+=4*(n-1); 运用刚才的平移法则，可求到相应的点。 再优化： 当j&gt;x且i=y时p(目标)=p+(j-x) ，平移判断 当i&gt;y且j=x时p(目标)=p+(i-y) ，平移 判断 当x&gt;j且i=y时p(目标)=p+(x-j) ，平移 判断 当y&gt;i且j=x时p(目标)=p+(y-i) 判断 这样就可以AC了</p>
</blockquote>
<p><del>~#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include<algorithm> int main() { freopen(“matrix.in”,”r”,stdin); freopen(“matrix.out”,”w”,stdout); int n,i,j; scanf(“%d %d %d”,&amp;n,&amp;i,&amp;j); int x=j,y=i; int a=n/2; <pre><code>if(n%2==0)//判断该数属于第几行 { if(x&gt;a) x=1+(n-x); if(y&gt;a) y=1+(n-y); } else { if(x&gt;a+1) x=1+(n-x); if(y&gt;a+1) y=1+(n-y); } int ceng=x&lt;y?x:y; x=1;y=1; int p=1; for(int m=1;m&lt;ceng;m++) { p+=4*(n-1); n-=2; x++; y++; } if(y==i) { p+=j-x; printf(“%d”,p); return 0; } p+=n-1; x+=n-1; if(x==j) { p+=i-y; printf(“%d”,p); return 0; } p+=n-1; y+=n-1; if(y==i) { p+=x-j; printf(“%d”,p); return 0; } p+=n-1; x-=n-1; if(x==j) { p+=y-i; printf(“%d”,p); return 0; } return 0; </code></pre> }</algorithm></del>~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrh1s.top/2018/12/06/e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3/" data-id="cjv7zzecb001juoetqc5xq0nf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-plus-plus-2016/">c_plus_plus_2016</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/">write up</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/cgctf/">cgctf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/cnss-recruit-201809/">cnss_recruit_201809</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/hgame-20190122/">hgame_20190122</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/nationalCTF-20190421/">nationalCTF_20190421</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/write-up/nctf-20181124/">nctf_20181124</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/牢骚/">牢骚</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RE-Dynamic/">RE_Dynamic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RE-Static/">RE_Static</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/RE-Dynamic/" style="font-size: 10px;">RE_Dynamic</a> <a href="/tags/RE-Static/" style="font-size: 20px;">RE_Static</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/03/Migration-Success/">Migration_Success!</a>
          </li>
        
          <li>
            <a href="/2019/04/28/bbvvmm/">bbvvmm</a>
          </li>
        
          <li>
            <a href="/2019/04/28/e5-8d-97-e4-ba-ac-e9-82-ae-e7-94-b5-e5-a4-a7-e5-ad-a6-re-wxyvm2/">南京邮电大学 RE-WxyVM2</a>
          </li>
        
          <li>
            <a href="/2019/04/13/e5-a3-b3-e7-9b-b8-e5-85-b3/">壳相关</a>
          </li>
        
          <li>
            <a href="/2019/03/22/shinyshot/">ShinyShot!</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 mrh929<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>