<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://mrh1s.top').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="求最大网络流总结  一个有向图，每条边都有最大可能的数据传输量c，要求一个点到某个点一次能传输的最大数据量，即为求最大网络流，每条边实际的数据传输量称为流量。**  基本思路：使用贪心算法，每次找出能使总流量更大的边，将数据向那条边流。  Ford-fulkerson算法  读入所有有向边，并且加入流量为0的反向边 DFS查找所有点u的未被遍历的边(u,v) 如果满足这条边流量大于0，更新这条">
<meta property="og:type" content="article">
<meta property="og:title" content="求最大网络流（最小割）总结">
<meta property="og:url" content="https://mrh1s.top/posts/675d1a4b/index.html">
<meta property="og:site_name" content="mrh929&#39;s home">
<meta property="og:description" content="求最大网络流总结  一个有向图，每条边都有最大可能的数据传输量c，要求一个点到某个点一次能传输的最大数据量，即为求最大网络流，每条边实际的数据传输量称为流量。**  基本思路：使用贪心算法，每次找出能使总流量更大的边，将数据向那条边流。  Ford-fulkerson算法  读入所有有向边，并且加入流量为0的反向边 DFS查找所有点u的未被遍历的边(u,v) 如果满足这条边流量大于0，更新这条">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-05-04T15:39:44.429Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="求最大网络流（最小割）总结">
<meta name="twitter:description" content="求最大网络流总结  一个有向图，每条边都有最大可能的数据传输量c，要求一个点到某个点一次能传输的最大数据量，即为求最大网络流，每条边实际的数据传输量称为流量。**  基本思路：使用贪心算法，每次找出能使总流量更大的边，将数据向那条边流。  Ford-fulkerson算法  读入所有有向边，并且加入流量为0的反向边 DFS查找所有点u的未被遍历的边(u,v) 如果满足这条边流量大于0，更新这条">

<link rel="canonical" href="https://mrh1s.top/posts/675d1a4b/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>求最大网络流（最小割）总结 | mrh929's home</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mrh929's home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/_posts/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://mrh1s.top/posts/675d1a4b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mrh929">
      <meta itemprop="description" content="Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mrh929's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          求最大网络流（最小割）总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 23:43:33" itemprop="dateCreated datePublished" datetime="2018-12-06T23:43:33+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-04 23:39:44" itemprop="dateModified" datetime="2019-05-04T23:39:44+08:00">2019-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-plus-plus-2016/" itemprop="url" rel="index">
                    <span itemprop="name">c_plus_plus_2016</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>  <strong>求最大网络流总结</strong> </p>
<p>一个有向图，每条边都有最大可能的数据传输量c，要求一个点到某个点一次能传输的最大数据量，即为求最大网络流，每条边实际的数据传输量称为流量。**  <strong>基本思路：使用贪心算法，每次找出能使总流量更大的边，将数据向那条边流。</strong>  <strong>Ford-fulkerson算法</strong></p>
<ol>
<li><strong>读入所有有向边，并且加入流量为0的反向边</strong></li>
<li><strong>DFS查找所有点u的未被遍历的边(u,v)</strong></li>
<li><strong>如果满足这条边流量大于0，更新这条边以及它的反向边的流量（同时会DFS遍历v点）</strong></li>
<li><strong>重复2操作，直到所有点被遍历完成</strong></li>
</ol>
<p><strong>算法复杂度：O(m+n)≈O(n^2)</strong>  <strong>Dinic算法</strong> <strong>原理：利用BFS求最短路的方法将所有的边按从源点到汇点的距离排序，从而避免不必要的增广</strong></p>
<ol>
<li><strong>BFS求源点到所有点的距离</strong></li>
<li><strong>DFS 遍历所有边(u,v)</strong></li>
<li><strong>如果dis[v]==dis[u]+1且边的长度大于0，那么更新这条边以及它的反向边的流量（同时DFS遍历了v点）</strong></li>
</ol>
<p><strong>用dis数组的好处：不仅减少了不必要的增广步骤，而且使增广顺序有序，不必记录点是否已被遍历</strong></p>
<ol>
<li><strong>重复2操作，直到没有符合条件的边为止</strong> <strong>算法复杂度：</strong>O(n^2<em>m)。*</em>（最坏情况，平均情况大大优于<strong>**FF算法）</strong></li>
</ol>
<p><strong>割</strong> <strong>在网络中，将源点与汇点通过割边的方式划分成两个部分，割掉的所有边都是割，其中，s到t为正向割边，t到s为逆向割边</strong> <strong>割的容量：所有正向割边的容量和</strong> <strong>最小割：容量和最小的割</strong> **      定理1：如果f是网络中的一个流，那么f的流为割的正向边与逆向边容量之差** **      定理二：如果f是一个流，CUT (S,T)是一个割，且f的值等于割CUT(S,T)的容量，那么f是一个最大流，CUT(S,T)是一个最小割。** **      推论：f的流量&lt;=此流的割的容量** <strong>求最小割与求最大网络流等价</strong>   POJ 1273 Drainage Ditches <strong>Description</strong> Every time itrains on Farmer John’s fields, a pond forms over Bessie’s favorite cloverpatch. This means that the clover is covered by water for awhile and takesquite a long time to regrow. Thus, Farmer John has built a set of drainageditches so that Bessie’s clover patch is never covered in water. Instead, thewater is drained to a nearby stream. Being an ace engineer, Farmer John hasalso installed regulators at the beginning of each ditch, so he can control atwhat rate water flows into that ditch. Farmer John knows not only how many gallons of water each ditch can transportper minute but also the exact layout of the ditches, which feed out of the pondand into each other and stream in a potentially complex network. Given all this information, determine the maximum rate at which water can betransported out of the pond and into the stream. For any given ditch, waterflows in only one direction, but there might be a way that water can flow in acircle. <strong>Input</strong> <strong><em>The input includesseveral cases.</em></strong> For each case, the first line contains twospace-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200).N is the number of ditches that Farmer John has dug. M is the number of intersectionspoints for those ditches. Intersection 1 is the pond. Intersection point M isthe stream. Each of the following N lines contains three integers, Si, Ei, andCi. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections betweenwhich this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0&lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow throughthe ditch. <strong>Output</strong> For each case,output a single integer, the maximum rate at which water may emptied from thepond. <strong>Sample Input</strong> 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10 <strong>Sample Output</strong> 50 <strong>题意</strong> 现在有m个池塘(从1到m开始编号,1为源点,m为汇点),及n条水渠,给出这n条水渠所连接的点和所能流过的最大流量，  <strong>Ford-Fulkerson算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">600</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],nxt[MAX],go[MAX],flow[MAX],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//加边 </span></span><br><span class="line">	nxt[++arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum]=b;</span><br><span class="line">	flow[arcnum]=c;<span class="comment">//记录该边容量 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> minc)</span></span>&#123;<span class="comment">//起点u，终点t，整条路径中流量最小为minc</span></span><br><span class="line"> 	<span class="keyword">if</span>(u==t) <span class="keyword">return</span> minc;</span><br><span class="line"> 	vis[u]=<span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line"> 		<span class="keyword">int</span> v=go[p];</span><br><span class="line"> 		<span class="keyword">if</span>(!vis[v]&amp;&amp;flow[p]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">int</span> f=Dfs(v,t,min(minc,flow[p]));</span><br><span class="line"> 			<span class="keyword">if</span>(f&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> 				flow[p]-=f;<span class="comment">//正向边减去算出的流量 </span></span><br><span class="line"> 				flow[p^<span class="number">1</span>]+=f;<span class="comment">//逆向边加上算出的流量</span></span><br><span class="line"> 				<span class="comment">/* n为任意偶自然数，那么n^1=n+1;(n+1)^1=n    */</span></span><br><span class="line">				<span class="keyword">return</span> f; </span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果都不符合条件，返回0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">int</span> f=Dfs(s,t,<span class="number">99999999</span>);</span><br><span class="line">		<span class="keyword">if</span>(f&lt;=<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">		ans+=f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,m,a,b,c;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">		arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			addarc(a,b,c);<span class="comment">//正向边流量为c </span></span><br><span class="line">			addarc(b,a,<span class="number">0</span>);<span class="comment">//逆向边流量为0 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxFlow(<span class="number">1</span>,n));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Dinic算法**</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">int</span> first[MAX],go[MAX],nxt[MAX],flow[MAX],arcnum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> que[MAX*MAX],dis[MAX],top,rear,current[MAX],vis[MAX];</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	nxt[++arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum]=b;</span><br><span class="line">	flow[arcnum]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> minc)</span></span>&#123;</span><br><span class="line"><span class="comment">//	printf("dfs %d %d start\n",u,t);</span></span><br><span class="line">	<span class="keyword">if</span>(u==t) <span class="keyword">return</span> minc;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=current[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">	</span><br><span class="line">		current[u]=p;</span><br><span class="line">		<span class="keyword">int</span> v=go[p]; </span><br><span class="line"><span class="comment">//		printf("%d: %d-&gt;%d\n",p,u,v);</span></span><br><span class="line">		<span class="keyword">if</span>(dis[v]==dis[u]+<span class="number">1</span>&amp;&amp;flow[p]&gt;<span class="number">0</span>)&#123;<span class="comment">//边一定要存在 </span></span><br><span class="line">			<span class="keyword">int</span> f=DFS(v,t,min(minc,flow[p]));</span><br><span class="line">			<span class="keyword">if</span>(f)&#123;</span><br><span class="line">				flow[p]-=f;</span><br><span class="line">				flow[p^<span class="number">1</span>]+=f;</span><br><span class="line">				<span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;<span class="comment">//BFS优化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">	top=rear=<span class="number">0</span>;</span><br><span class="line">	que[rear++]=s;</span><br><span class="line">	dis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u=que[top++],v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p];</span><br><span class="line">			<span class="keyword">if</span>(flow[p]&gt;<span class="number">0</span>&amp;&amp;dis[v]==INF)&#123;<span class="comment">//边存在且点未被更新时才更新 </span></span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">				que[rear++]=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=rear);</span><br><span class="line">	<span class="keyword">return</span> dis[t]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;<span class="comment">//Dinic算法 </span></span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,f;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			current[i]=first[i];<span class="comment">//每次BFS后都要重置current数组</span></span><br><span class="line">		<span class="keyword">while</span>(f=DFS(s,t,INF))</span><br><span class="line">			ans+=f;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">		arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			addarc(a,b,c);</span><br><span class="line">			addarc(b,a,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/*		for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">			printf("%d %d\n",i,first[i]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf("node end\n");</span></span><br><span class="line"><span class="comment">		for(int i=1;i&lt;=2*m;i++)&#123;</span></span><br><span class="line"><span class="comment">			printf("%d %d %d\n",i,go[i],nxt[i]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf("edge end\n");*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxFlow(<span class="number">1</span>,n));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>HDU4183 Pahom on Water</strong> <strong>Problem Description</strong> Pahom on Water isan interactive computer game inspired by a short story of Leo Tolstoy about apoor man who, in his lust for land, forfeits everything. The game’s startingscreen displays a number of circular pads painted with colours from the visiblelight spectrum. More than one pad may be painted with the same colour (definedby a certain frequency) except for the two colours red and violet. The displaycontains only one red pad (the lowest frequency of 400 THz) and one violet pad(the highest frequency of 789 THz). A pad may intersect, or even containanother pad with a different colour but never merely touch its boundary. Thedisplay also shows a figure representing Pahom standing on the red pad. The game’s objective is to walk the figure of Pahom from the red pad to theviolet pad and return back to the red pad. The walk must observe the followingrules: 1.If pad α and pad β have a common intersection and the frequency of the colourof pad α is strictly smaller than the frequency of the colour of pad β, thenPahom figure can walk from α to β during the walk from the red pad to theviolet pad 2. If pad α and pad β have a common intersection and the frequency of thecolour of pad α is strictly greater than the frequency of the colour of pad β,then Pahom figure can walk from α to β during the walk from the violet pad tothe red pad 3. A coloured pad, with the exception of the red pad, disappears from displaywhen the Pahom figure walks away from it. The developer of the game has programmed all the whizzbang features of thegame. All that is left is to ensure that Pahom has a chance to succeed in eachinstance of the game (that is, there is at least one valid walk from the redpad to the violet pad and then back again to the red pad.) Your task is towrite a program to check whether at least one valid path exists in eachinstance of the game.   <strong>Input</strong> The input startswith an integer K (1 &lt;= K &lt;= 50) indicating the number of scenarios on aline by itself. The description for each scenario starts with an integer N (2&lt;= N &lt;= 300) indicating the number of pads, on a line by itself, followedby N lines that describe the colors, locations and sizes of the N pads. Eachline contains the frequency, followed by the x- and y-coordinates of the pad’scenter and then the radius. The frequency is given as a real value with no morethan three decimal places. The coordinates and radius are given, in meters, asintegers. All values are separated by a single space. All integer values are inthe range of -10,000 to 10,000 inclusive. In each scenario, all frequencies arein the range of 400.0 to 789.0 inclusive. Exactly one pad will have a frequencyof “400.0” and exactly one pad will have a frequency of “789.0”.   <strong>Output</strong> The output foreach scenario consists of a single line that contains: Game is VALID, or Gameis NOT VALID   <strong>Sample Input</strong> 2 2 400.0 0 0 4 789.0 7 0 2 4 400.0 0 0 4 789.0 7 0 2 500.35 5 0 2 500.32 5 0 3   <strong>Sample Output</strong> Game is NOT VALID Game is VALID   <strong>题目大意：</strong> 有多个点，每个点给出坐标与半径，加入两个点相交，就可以从这两个点走。题目要求先从起点到终点，再从终点回到起点。从起点到终点的过程中，只能从频率小的走到频率大的点（前提是两点相交），从终点到起点的过程中，只能从频率大的走到频率小的。在走的过程中，除了起点与终点，别的只要走过就会消失，就是说只能走一次。问可不可以从起点到终点又回到起点。  <strong>找到输入数据中最小和最大的两个，求两个之间的最大网络流</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1500</span>;</span><br><span class="line"><span class="keyword">double</span> data[MAX];</span><br><span class="line"><span class="keyword">int</span> first[MAX],go[MAX],nxt[MAX],arcnum=<span class="number">1</span>,x[MAX],y[MAX],r[MAX];</span><br><span class="line"><span class="keyword">int</span> flow[MAX],que[MAX],top,rear,dis[MAX],vis[MAX];</span><br><span class="line"><span class="keyword">int</span> k,n,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addarc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	nxt[++arcnum]=first[a];</span><br><span class="line">	first[a]=arcnum;</span><br><span class="line">	go[arcnum]=b;</span><br><span class="line">	flow[arcnum]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> minc)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==t) <span class="keyword">return</span> minc;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">		<span class="keyword">int</span> v=go[p],f;</span><br><span class="line">		<span class="keyword">if</span>(dis[v]==dis[u]+<span class="number">1</span>&amp;&amp;flow[p]&gt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">if</span>(f=DFS(v,t,min(minc,flow[p])))&#123;</span><br><span class="line">				flow[p]-=f;</span><br><span class="line">				flow[p^<span class="number">1</span>]+=f;</span><br><span class="line">				<span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">	top=rear=<span class="number">0</span>;</span><br><span class="line">	que[rear++]=s;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u=que[top++],v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=first[u];p!=<span class="number">0</span>;p=nxt[p])&#123;</span><br><span class="line">			v=go[p];</span><br><span class="line">			<span class="keyword">if</span>(dis[v]==INF&amp;&amp;flow[p]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">				que[rear++]=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(top!=rear);</span><br><span class="line">	<span class="keyword">return</span> dis[t]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,f;</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))</span><br><span class="line">		<span class="keyword">while</span>(f=DFS(s,t,INF))</span><br><span class="line">			ans+=f;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">		<span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">		arcnum=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> red=<span class="number">0</span>,purple=n+<span class="number">1</span>;</span><br><span class="line">		data[<span class="number">0</span>]=<span class="number">9999</span>; data[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%f%d%d%d"</span>,&amp;data[i],&amp;x[i],&amp;y[i],&amp;r[i]);</span><br><span class="line">			<span class="keyword">if</span>(data[i]&lt;data[red]) red=i;</span><br><span class="line">			<span class="keyword">if</span>(data[i]&gt;data[purple]) purple=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				<span class="keyword">if</span>(data[i]&lt;data[j]&amp;&amp;<span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))&lt;=r[i]+r[j])</span><br><span class="line">					addarc(i,j,<span class="number">1</span>),addarc(j,i,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(MaxFlow(red,purple)&lt;<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"Game is NOT VALID\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Game is VALID\n"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>mrh929
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://mrh1s.top/posts/675d1a4b/" title="求最大网络流（最小割）总结">https://mrh1s.top/posts/675d1a4b/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/1acd21ea/" rel="prev" title="Tarjan算法求无向图割边割点、最近公共祖先的总结">
      <i class="fa fa-chevron-left"></i> Tarjan算法求无向图割边割点、最近公共祖先的总结
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/c1dd3892/" rel="next" title="离散hash优化总结">
      离散hash优化总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mrh929</p>
  <div class="site-description" itemprop="description">Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/_posts/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mrh929</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
